<html><head><title>Image Analysis</title></head>
<body bgcolor=#ffffff>
 
<center>
<a href="JAITOC.fm.html"><img src="shared/contents.gif" alt="Contents"></a> <a href="Geom-image-manip.doc.html"><img src="shared/previous.gif" alt="Previous"></a> <a href="Graphics.doc.html"><img src="shared/next.gif" alt="Next"></a> <p><font size=5><i>Programming in Java Advanced Imaging</i></font>
</center>
<br>
 
<center>
<a name="55364">
<table width=90% border=0><tr>
<td align=right><font size=3>C H A P T E R</font><font size=7><img src="shared/sm-space.gif">9</td></table>
</a></center><center>
<a name="55366">
<table width=90% border=0><tr><td align=right>
<hr size=7 noshade>
<font size=6>Image Analysis</font></td></table>
</a></center><blockquote>
<p><br><br><br><P><font size=7><b>T</b></font>HIS chapter describes the JAI API image analysis operators.
<p><a name="50856">
<h2>9.1	<img src="shared/space.gif">Introduction</h2>
</a>The JAI API image analysis operators are used to directly or indirectly extract information from an image. The JAI API supports the following image analysis functions:
<p><ul>
<li>Finding the mean value of an image region<p></ul><ul>
<li>Finding the minimum and maximum values in an image (extrema)<p></ul><ul>
<li>Producing a histogram of an image<p></ul><ul>
<li>Detecting edges in an image<p></ul><ul>
<li>Performing statistical operations<p></ul><a name="54841">
<h2>9.2	<img src="shared/space.gif">Finding the Mean Value of an Image Region</h2>
</a>The <code>Mean</code> operation scans a specified region of an image and computes the image-wise mean pixel value for each band within the region. The region of interest does not have to be a rectangle. If no region is specified (null), the entire image is scanned to generate the histogram. The image data pass through the operation unchanged.
<p>The <code>mean</code> operation takes one rendered source image and three parameters:<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="54846">
Parameter
</a><th><a name="54848">
Type
</a><th><a name="54850">
Description
</a>
<tr valign=top><td><a name="54852">
roi</a><br><td><a name="54854">
ROI</a><br><td><a name="54856">
The region of the image to scan. A null value means the whole image.</a><br>
<tr valign=top><td><a name="54858">
xPeriod</a><br><td><a name="54860">
Integer</a><br><td><a name="54862">
The horizontal sampling rate. May not be less than 1.</a><br>
<tr valign=top><td><a name="54864">
yPeriod</a><br><td><a name="54866">
Integer</a><br><td><a name="54868">
The vertical sampling rate. May not be less than 1.</a><br>

</Table>

<p>The region of interest (ROI) does not have to be a rectangle. It may be <code>null</code>, in which case the entire image is scanned to find the image-wise mean pixel value for each band.
<p>The set of pixels scanned may be reduced by specifying the <code>xPeriod</code> and <code>yPeriod</code> parameters, which define the sampling rate along each axis. These variables may not be less than 1. However, they may be <code>null</code>, in which case the sampling rate is set to 1; that is, every pixel in the ROI is processed.
<p>The image-wise mean pixel value for each band may be retrieved by calling the <code>getProperty</code> method with <code>"mean"</code> as the property name. The return value has type <code>java.lang.Number[#bands]</code>.
<p><a href="Analysis.doc.html#56522">Listing &#32;9-1</a> shows a partial code sample of finding the image-wise mean pixel value of an image in the rendered mode.<p>
<caption><font size=-1><b>
<a name="56522">
<center><font size=-1><b><i>Listing 9-1	</i><img src="shared/sm-blank.gif" border=0> Finding the Mean Value of an Image Region</b></font></center>
</a><p>
</b></font></caption>
<hr>
<tr valign=top><td><pre>     // Set up the parameter block for the source image and
     // the three parameters.
     ParameterBlock pb = new ParameterBlock();
     pb.addSource(im);   // The source image
     pb.add(null);       // null ROI means whole image
     pb.add(1);          // check every pixel horizontally
     pb.add(1);          // check every pixel vertically
</pre>
<tr valign=top><td><pre>     // Perform the mean operation on the source image.
     RenderedImage meanImage = JAI.create("mean", pb, null);
</pre>
<tr valign=top><td><pre>     // Retrieve and report the mean pixel value.
     double[] mean = (double[])meanImage.getProperty("mean");
     System.out.println("Band 0 mean = " + mean[0]);
</pre>

<hr>

<p><a name="54907">
<h2>9.3	<img src="shared/space.gif">Finding the Extrema of an Image</h2>
</a>The <code>Extrema</code> operation scans a specific region of a rendered image and finds the image-wise minimum and maximum pixel values for each band within that region of the image. The image pixel data values pass through the operation unchanged. The <code>extrema</code> operation can be used to obtain information to compute the scale and offset factors for the amplitude rescaling operation (see <a href="Image-enhance.doc.html#76502">Section &#32;7.4, "Amplitude Rescaling</a>").
<p>The region-wise maximum and minimum pixel values may be obtained as properties. Calling the <code>getProperty</code> method on this operation with <code>"extrema"</code> as the property name retrieves both the region-wise maximum and minimum pixel values. Calling it with <code>"maximum"</code> as the property name retrieves the region-wise maximum pixel value, and with <code>"minimum"</code> as the property name retrieves the region-wise minimum pixel value.
<p>The return value for <code>extrema</code> has type <code>double[2][#bands]</code>, and those for <code>maximum</code> and <code>minimum</code> have type <code>double[#bands]</code>.
<p>The region of interest (ROI) does not have to be a rectangle. It may be <code>null</code>, in which case the entire image is scanned to find the image-wise maximum and minimum pixel values for each band.
<p>The <code>extrema</code> operation takes one rendered source image and three parameters:<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="54912">
Parameter
</a><th><a name="54914">
Type
</a><th><a name="54916">
Description
</a>
<tr valign=top><td><a name="54918">
roi</a><br><td><a name="54920">
ROI</a><br><td><a name="54922">
The region of the image to scan.</a><br>
<tr valign=top><td><a name="54924">
xPeriod</a><br><td><a name="54926">
Integer</a><br><td><a name="54928">
The horizontal sampling rate (may not be less than 1).</a><br>
<tr valign=top><td><a name="54930">
yPeriod</a><br><td><a name="54932">
Integer</a><br><td><a name="54934">
The vertical sampling rate (may not be less than 1).</a><br>

</Table>

<p>The set of pixels scanned may be further reduced by specifying the <code>xPeriod</code> and <code>yPeriod</code> parameters that represent the sampling rate along each axis. These variables may not be less than 1. However, they may be <code>null</code>, in which case the sampling rate is set to 1; that is, every pixel in the ROI is processed.
<p><a href="Analysis.doc.html#56559">Listing &#32;9-2</a> shows a partial code sample of using the <code>extrema</code> operation to obtain both the image-wise maximum and minimum pixel values of the source image.<p>
<caption><font size=-1><b>
<a name="56559">
<center><font size=-1><b><i>Listing 9-2	</i><img src="shared/sm-blank.gif" border=0> Finding the Extrema of an Image &#32;</b></font></center>
</a><p>
</b></font></caption>
<hr>
<tr valign=top><td><pre>     // Set up the parameter block for the source image and
     // the constants
     ParameterBlock pb = new ParameterBlock();
     pb.addSource(im);   // The source image
     pb.add(roi);        // The region of the image to scan
     pb.add(50);         // The horizontal sampling rate
     pb.add(50);         // The vertical sampling rate
</pre>
<tr valign=top><td><pre>     // Perform the extrema operation on the source image
     RenderedOp op = JAI.create("extrema", pb);
</pre>
<tr valign=top><td><pre>     // Retrieve both the maximum and minimum pixel value
     double[][] extrema = (double[][]) op.getProperty("extrema");
</pre>

<hr>

<p><a name="54836">
<h2>9.4	<img src="shared/space.gif">Histogram Generation</h2>
</a>An image histogram is an analytic tool used to measure the amplitude distribution of pixels within an image. For example, a histogram can be used to provide a count of the number of pixels at amplitude 0, the number at amplitude 1, and so on. By analyzing the distribution of pixel amplitudes, you can gain some information about the visual appearance of an image. A high-contrast image contains a wide distribution of pixel counts covering the entire amplitude range. A low contrast image has most of the pixel amplitudes congregated in a relatively narrow range.
<p>Usually, the wider histogram represents a more visually-appealing image.
<p><a name="51190">
 <hr>
<center><img src="Analysis.doc.anc.gif"></center><hr>

</a>
<a name="51191">
<center><font size=-1><b><i>Figure 9-1	</i><img src="shared/sm-blank.gif" border=0> Example Histograms</b></font></center>
</a><p>
The primary tasks needed to perform a histogram operation are as follows:
<p><ul>

1.	 Create a <code>Histogram</code> object, which specifies the type of histogram to be generated.<p>

2.	 Create a <code>Histogram</code> operation with the required parameters or create a <code>ParameterBlock</code> with the parameters and pass it to the <code>Histogram</code> operation.<p>

3.	 Read the histogram data stored in the object. The data consists of:<p>
<ul>
<ul>
<li>Number of bands in the histogram</ul><ul>
<li>Number of bins for each band of the image</ul><ul>
<li>Lowest value checked for each band</ul><ul>
<li>Highest value checked for each band</ul></ul></ul>
<a name="55111">
<h3>9.4.1	<img src="shared/space.gif">Specifying the Histogram</h3>
</a>The <code>Histogram</code> object accumulates the histogram information. A histogram counts the number of image samples whose values lie within a given range of values, or "bins." The source image may be of any data type.
<p>The <code>Histogram</code> contains a set of bins for each band of the image. These bins hold the information about gray or color levels. For example, to take the histogram of an eight-bit grayscale image, the <code>Histogram</code> might contain 256 bins. When reading the <code>Histogram</code>, bin 0 will contain the number of 0's in the image, bin 1 will contain the number of 1's, and so on.
<p>The <code>Histogram</code> need not contain a bin for every possible value in the image. It is possible to specify the lowest and highest values that will result in a bin count being incremented. It is also possible to specify fewer bins than the number of levels being checked. In this case, each bin will hold the count for a range of values. For example, for a <code>Histogram</code> with only four bins used with an 8-bit grayscale image, the number of occurrences of values 0 through 63 will be stored in bin 0, occurrences of values 64 through 127 will be stored in bin 1, and so on.
<p>The <code>Histogram</code> object takes three parameters:<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="55182">
Parameter
</a><th><a name="55184">
Description
</a>
<tr valign=top><td><a name="55186">
numBins</a><br><td><a name="55188">
An array of ints, each element of which specifies the number of bins to be used for one band of the image. The number of elements in the array must match the number of bands in the image.</a><br>
<tr valign=top><td><a name="55190">
lowValue</a><br><td><a name="55192">
An array of floats, each element of which specifies the lowest gray or color level that will be checked for in one band of the image. The number of elements in the array must match the number of bands in the image.</a><br>
<tr valign=top><td><a name="55194">
highValue</a><br><td><a name="55196">
An array of floats, each element of which specifies the highest gray or color level that will be checked for in one band of the image. The number of elements in the array must match the number of bands in the image.</a><br>

</Table>

<p>For an example histogram, see <a href="Analysis.doc.html#56595">Listing &#32;9-3 on page 315</a>.
<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.Histogram
</code>
<hr>
</td>
</table><pre><ul>
<li>Histogram(int[] numBins, float[] lowValue, float[] highValue)
<p></ul></pre><dl>
<a name="55117">
<dt><dd> constructs a <code>Histogram</code> that may be used to accumulate data within a given range for each band of an image. The legal pixel range and the number of bins may be controlled separately.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=3><em>Parameters</em>:
<p><td><code>numBins</code>
<p><td>The number of bins for each band of the image; <code>numBins.length</code> must be equal to the number of bands of the image which the histogram is taken.
<p>
<tr valign=top><td><code>lowValue</code>
<p><td>The lowest pixel value checked for each band.
<p>
<tr valign=top><td><code>highValue</code>
<p><td>The highest pixel value checked for each band. Note when counting the pixel values, this <code>highValue</code> is not included based on the formula below.
<p>

</Table>

</a><P><a name="55137">
<dt><dd> If <code>binWidth</code> is defined as (<code>highValue</code> - <code>lowValue</code>)/<code>numBins</code>, bin i will count pixel values in the range from
</a><P><a name="55141">
<dt><dd>     <img src="Analysis.doc.anc3.gif">
</a><P></dl>
<a name="52616">
<h3>9.4.2	<img src="shared/space.gif">Performing the Histogram Operation</h3>
</a>Once you have created the <code>Histogram</code> object to accumulate the histogram information, you generate the histogram for an image with the <code>histogram</code> operation. The <code>histogram</code> operation scans a specified region of an image and generates a histogram based on the pixel values within that region of the image. The region of interest does not have to be a rectangle. If no region is specified (null), the entire image is scanned to generate the histogram. The image data passes through the operation unchanged.
<p>The <code>histogram</code> operation takes one rendered source image and four parameters:<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="52625">
Parameter
</a><th><a name="52627">
Type
</a><th><a name="52629">
Description
</a>
<tr valign=top><td><a name="52631">
specification</a><br><td><a name="52633">
Histogram</a><br><td><a name="52635">
The specification for the type of histogram to be generated. See <a href="Analysis.doc.html#55111">Section &#32;9.4.1, "Specifying the Histogram</a>."</a><br>
<tr valign=top><td><a name="52637">
roi</a><br><td><a name="52639">
ROI</a><br><td><a name="52641">
The region of the image to scan. See <a href="Image-manipulation.doc.html#51458">Section &#32;6.2, "Region of Interest Control</a>."</a><br>
<tr valign=top><td><a name="52643">
xPeriod</a><br><td><a name="52645">
Integer</a><br><td><a name="52647">
The horizontal sampling rate. May not be less than 1.</a><br>
<tr valign=top><td><a name="52649">
yPeriod</a><br><td><a name="52651">
Integer</a><br><td><a name="52653">
The vertical sampling rate. May not be less than 1.</a><br>

</Table>

<p>The set of pixels scanned may be further reduced by specifying the <code>xPeriod</code> and <code>yPeriod</code> parameters that represent the sampling rate along each axis. These variables may not be less than 1. However, they may be null, in which case the sampling rate is set to 1; that is, every pixel in the ROI is processed.
<p><a name="51842">
<h3>9.4.3	<img src="shared/space.gif">Reading the Histogram Data</h3>
</a>The histogram data is stored in the user supplied <code>Histogram</code> object, and may be retrieved by calling the <code>getProperty</code> method on this operation with <code>"histogram"</code> as the property name. The return value will be of type <code>Histogram</code>.
<p>Several get methods allow you to check on the four histogram parameters:
<p><ul>
<li>The bin data for all bands (<code>getBins</code>)<code></code><p></ul><ul>
<li>The bin data for a specified band (<code>getBins</code>)<p></ul><ul>
<li>The number of pixel values found in a given bin for a given band (<code>getBinSize</code>)<p></ul><ul>
<li>The lowest pixel value found in a given bin for a given band (<code>getBinLowValue</code>)<p></ul>The set of pixels counted in the histogram may be limited by the use of a region of interest (ROI), and by horizontal and vertical subsampling factors. These factors allow the accuracy of the histogram to be traded for speed of computation.
<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.Histogram
</code>
<hr>
</td>
</table><pre><ul>
<li>int[][] getBins()
<p></ul></pre><dl>
<a name="51866">
<dt><dd> returns the bins of the histogram for all bands.
</a><P></dl>
<pre><ul>
<li>int[] getBins(int band)
<p></ul></pre><dl>
<a name="51875">
<dt><dd> returns the bins of the histogram for a specified band.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td><em>Parameters</em>:
<p><td><code>band</code>
<p><td>The band to be checked
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>int getBinSize(int band, int bin)
<p></ul></pre><dl>
<a name="51890">
<dt><dd> returns the number of pixel values found in a given bin for a given band.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=2><em>Parameters</em>:
<p><td><code>band</code>
<p><td>The band to be checked
<p>
<tr valign=top><td><code>bin</code>
<p><td>The bin to be checked
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>float getBinLowValue(int band, int bin)
<p></ul></pre><dl>
<a name="51905">
<dt><dd> returns the lowest pixel value found in a given bin for a given band.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=2><em>Parameters</em>:
<p><td><code>band</code>
<p><td>The band to be checked
<p>
<tr valign=top><td><code>bin</code>
<p><td>The bin to be checked
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>void clearHistogram()
<p></ul></pre><dl>
<a name="51907">
<dt><dd> resets the counts of all bins to zero.
</a><P></dl>
<pre><ul>
<li>void countPixels(java.awt.image.Raster pixels, ROI roi,
       int xStart, int yStart, int xPeriod, int yPeriod)
<p></ul></pre><dl>
<a name="51909">
<dt><dd> adds the pixels of a <code>Raster</code> that lie within a given region of interest (ROI) to the histogram. The set of pixels is further reduced by subsampling factors in the horizontal and vertical directions. The set of pixels to be accumulated may be obtained by intersecting the grid
</a><P><a name="51913">
<dt><dd>     <img src="Analysis.doc.anc4.gif">
</a><P><a name="51951">
<dt><dd> with the region of interest and the bounding rectangle of the <code>Raster</code>.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=6><em>Parameters</em>:
<p><td><code>pixels</code>
<p><td>A Raster containing pixels to be histogrammed.
<p>
<tr valign=top><td><code>roi</code>
<p><td>The region of interest, as a ROI.
<p>
<tr valign=top><td><code>xStart</code>
<p><td>The initial <em>x</em> sample coordinate.
<p>
<tr valign=top><td><code>yStart</code>
<p><td>The initial <em>y</em> sample coordinate.
<p>
<tr valign=top><td><code>xPeriod</code>
<p><td>The <em>x</em> sampling rate.
<p>
<tr valign=top><td><code>yPeriod</code>
<p><td>The <em>y</em> sampling rate.
<p>

</Table>

</a><P></dl>
<a name="55476">
<h3>9.4.4	<img src="shared/space.gif">Histogram Operation Example</h3>
</a><a href="Analysis.doc.html#56595">Listing &#32;9-3</a> shows a sample listing for a histogram operation on a three-banded source image.<p>
<caption><font size=-1><b>
<a name="56595">
<center><font size=-1><b><i>Listing 9-3	</i><img src="shared/sm-blank.gif" border=0> Example Histogram Operation &#32;</b></font></center>
</a><p>
</b></font></caption>
<hr>
<tr valign=top><td><pre>     // Set up the parameters for the Histogram object.
     int[] bins = {256, 256, 256};             // The number of bins.
     double[] low = {0.0D, 0.0D, 0.0D};        // The low value.
     double[] high = {256.0D, 256.0D, 256.0D}; // The high value.
</pre>
<tr valign=top><td><pre>     // Construct the Histogram object.
     Histogram hist = new Histogram(bins, low, high);
</pre>
<tr valign=top><td><pre>     // Create the parameter block.
     ParameterBlock pb = new ParameterBlock();
     pb.addSource(image);               // Specify the source image
     pb.add(hist);                      // Specify the histogram
     pb.add(null);                      // No ROI
     pb.add(1);                         // Sampling
     pb.add(1);                         // periods
</pre>
<tr valign=top><td><pre>     // Perform the histogram operation.
     dst = (PlanarImage)JAI.create("histogram", pb, null);
</pre>
<tr valign=top><td><pre>     // Retrieve the histogram data.
     hist = (Histogram) dst.getProperty("histogram");
</pre>
<tr valign=top><td><pre>     // Print 3-band histogram.
     for (int i=0; i&lt; histogram.getNumBins(); i++) {
        System.out.println(hist.getBinSize(0, i) + " " +
                           hist.getBinSize(1, i) + " " +
                           hist.getBinSize(2, i) + " " +
     }
</pre>

<hr>

<p><a name="51214">
<h2>9.5	<img src="shared/space.gif">Edge Detection</h2>
</a>Edge detection is useful for locating the boundaries of objects within an image. Any abrupt change in image frequency over a relatively small area within an image is defined as an edge. Image edges usually occur at the boundaries of objects within an image, where the amplitude of the object abruptly changes to the amplitude of the background or another object.
<p>The <code>GradientMagnitude</code> operation is an edge detector that computes the magnitude of the image gradient vector in two orthogonal directions. This operation is used to improve an image by showing the directional information only for those pixels that have a strong magnitude for the brightness gradient.
<p><ul>
<li>It performs two convolution operations on the source image. One convolution detects edges in one direction, the other convolution detects edges the orthogonal direction. These two convolutions yield two intermediate images.<p></ul><ul>
<li>It squares all the pixel values in the two intermediate images, yielding two more intermediate images.<p></ul><ul>
<li>It takes the square root of the last two images forming the final image.<p></ul>The result of the <code>GradientMagnitude</code> operation may be defined as:
<p><dl>
<a name="56426">
<dt><dd> <img src="Analysis.doc.ancA3.gif">
</a><P><a name="56061">
<dt><dd> where <code>SH(x,y,b)</code> and <code>SV(x,y,b)</code> are the horizontal and vertical gradient images generated from band <em>b</em> of the source image by correlating it with the supplied orthogonal (horizontal and vertical) gradient masks.
</a><P></dl>
The <code>GradientMagnitude</code> operation uses two gradient masks; one for passing over the image in each direction. The <code>GradientMagnitude</code> operation takes one rendered source image and two parameters.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="56095">
Parameter
</a><th><a name="56097">
Type
</a><th><a name="56099">
Description
</a>
<tr valign=top><td><a name="56101">
mask1</a><br><td><a name="56103">
KernelJAI</a><br><td><a name="56105">
A gradient mask.</a><br>
<tr valign=top><td><a name="56107">
mask2</a><br><td><a name="56109">
KernelJAI</a><br><td><a name="56111">
A gradient mask orthogonal to the first one.</a><br>

</Table>

<p>The default masks for the <code>GradientMagnitude</code> operation are:
<p><ul>
<li><code>KernelJAI.GRADIENT_MASK_SOBEL_HORIZONTAL</code><p></ul><ul>
<li><code>KernelJAI.GRADIENT_MASK_SOBEL_VERTICAL</code><p></ul>These masks, shown in <a href="Analysis.doc.html#51239">Figure &#32;9-2</a> perform the Sobel edge enhancement operation. The Sobel operation extracts all of the edges in an image, regardless of the direction. The resulting image appears as an omnidirectional outline of the objects in the original image. Constant brightness regions are highlighted.
<p><a name="56375">
 <hr>
<center><img src="Analysis.doc.anc1.gif"></center><hr>

</a>
<a name="51239">
<center><font size=-1><b><i>Figure 9-2	</i><img src="shared/sm-blank.gif" border=0> Sobel Edge Enhancement Masks</b></font></center>
</a><p>
The Roberts' cross edge enhancement operation uses the two masks shown in <a href="Analysis.doc.html#57055">Figure &#32;9-3</a>. This operation extracts edges in an image by taking the combined differences of directions at right angles to each other to determine the gradient. The resulting image appears as a fairly-coarse directional outline of the objects within the image. Constant brightness regions become black and changing brightness regions become highlighted. The following is a listing of how the two masks are constructed.<p>
<caption><font size=-1><b></b></font></caption>
<hr>
<tr valign=top><td colspan=1 rowspan=8><pre>     float[] roberts_h_data        = { 0.0F,  0.0F, -1.0F,
                                       0.0F,  1.0F,  0.0F,
                                       0.0F,  0.0F,  0.0F
     };
     float[] roberts_v_data        = {-1.0F,  0.0F,  0.0F,
                                       0.0F,  1.0F,  0.0F,
                                       0.0F,  0.0F,  0.0F
     };
</pre>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top><td><pre>     KernelJAI kern_h = new KernelJAI(3,3,roberts_h_data);
     KernelJAI kern_v = new KernelJAI(3,3,roberts_v_data);
</pre>

<hr>

<p><a name="57054">
 <hr>
<center><img src="Analysis.doc.ancA5.gif"></center><hr>

</a>
<a name="57055">
<center><font size=-1><b><i>Figure 9-3	</i><img src="shared/sm-blank.gif" border=0> Roberts' Cross Edge Enhancement Masks</b></font></center>
</a><p>
The Prewitt gradient edge enhancement operation uses the two masks shown in <a href="Analysis.doc.html#57129">Figure &#32;9-4</a>. This operation extracts the north, northeast, east, southeast, south, southwest, west, or northwest edges in an image. The resulting image appears as a directional outline of the objects within the image. Constant brightness regions become black and changing brightness regions become highlighted. The following is a listing of how the two masks are constructed.<p>
<caption><font size=-1><b></b></font></caption>
<hr>
<tr valign=top><td colspan=1 rowspan=8><pre>     float[] prewitt_h_data        = { 1.0F,  0.0F, -1.0F,
                                       1.0F,  0.0F, -1.0F,
                                       1.0F,  0.0F, -1.0F
     };
     float[] prewitt_v_data        = {-1.0F, -1.0F, -1.0F,
                                       0.0F,  0.0F,  0.0F,
                                       1.0F,  1.0F,  1.0F
     };
</pre>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top><td><pre>     KernelJAI kern_h = new KernelJAI(3,3,prewitt_h_data);
     KernelJAI kern_v = new KernelJAI(3,3,prewitt_v_data);
</pre>

<hr>

<p><a name="57128">
 <hr>
<center><img src="Analysis.doc.anc8.gif"></center><hr>

</a>
<a name="57129">
<center><font size=-1><b><i>Figure 9-4	</i><img src="shared/sm-blank.gif" border=0> Prewitt Edge Enhancement Masks</b></font></center>
</a><p>
The Frei and Chen edge enhancement operation uses the two masks shown in <a href="Analysis.doc.html#57203">Figure &#32;9-5</a>. This operation, when compared to the other edge enhancement, operations, is more sensitive to a configuration of relative pixel values independent of the brightness magnitude. The following is a listing of how the two masks are constructed.<p>
<caption><font size=-1><b></b></font></caption>
<hr>
<tr valign=top><td colspan=1 rowspan=8><pre>     float[] freichen_h_data        = { 1.0F,   0.0F,   -1.0F,
                                        1.414F, 0.0F,   -1.414F,
                                        1.0F,   0.0F,   -1.0F
     };
     float[] freichen_v_data        = {-1.0F,  -1.414F, -1.0F,
                                        0.0F,   0.0F,    0.0F,
                                        1.0F,   1.414F,  1.0F
     };
</pre>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top><td><pre>     KernelJAI kern_h = new KernelJAI(3,3,freichen_h_data);
     KernelJAI kern_v = new KernelJAI(3,3,freichen_v_data);
</pre>

<hr>

<p><a name="57202">
 <hr>
<center><img src="Analysis.doc.anc9.gif"></center><hr>

</a>
<a name="57203">
<center><font size=-1><b><i>Figure 9-5	</i><img src="shared/sm-blank.gif" border=0> Frei and Chen Edge Enhancement Masks</b></font></center>
</a><p>
To use a different mask, see <a href="Image-manipulation.doc.html#70882">Section &#32;6.9, "Constructing a Kernel</a>."
<p><a href="Analysis.doc.html#56654">Listing &#32;9-4</a> shows a sample listing for a <code>GradientMagnitude</code> operation, using the Frei and Chen edge detection kernel.<p>
<caption><font size=-1><b>
<a name="56654">
<center><font size=-1><b><i>Listing 9-4	</i><img src="shared/sm-blank.gif" border=0> Example GradientMagnitude Operation &#32;</b></font></center>
</a><p>
</b></font></caption>
<hr>
<tr valign=top><td><pre>     // Load the image.
     PlanarImage im0 = (PlanarImage)JAI.create("fileload",
                                               filename);
</pre>
<tr valign=top><td><pre>     // Create the two kernels.
     float data_h[] = new float[] { 1.0F,   0.0F,   -1.0F,
                                    1.414F, 0.0F,   -1.414F,
                                    1.0F,   0.0F,   -1.0F};
     float data_v[] = new float[] {-1.0F,  -1.414F, -1.0F,
                                    0.0F,   0.0F,    0.0F,
                                    1.0F,   1.414F,  1.0F};
</pre>
<tr valign=top><td><pre>     KernelJAI kern_h = new KernelJAI(3,3,data_h);
     KernelJAI kern_v = new KernelJAI(3,3,data_v);
</pre>
<tr valign=top><td><pre>     // Create the Gradient operation.
     PlanarImage im1 =
             (PlanarImage)JAI.create("gradientmagnitude", im0,
                                      kern_h, kern_v);
</pre>
<tr valign=top><td><pre>     // Display the image.
     imagePanel = new ScrollingImagePanel(im1, 512, 512);
             add(imagePanel);
             pack();
             show();
</pre>

<hr>

<p><a name="52769">
<h2>9.6	<img src="shared/space.gif">Statistical Operations</h2>
</a>The <code>StatisticsOpImage</code> class is an abstract class for image operators that compute statistics on a given region of an image and with a given sampling rate. A subclass of <code>StatisticsOpImage</code> simply passes pixels through unchanged from its parent image. However, the desired statistics are available as a property or set of properties on the image (see <a href="Properties.doc.html#47285">Chapter &#32;11, "Image Properties</a>").
<p>All instances of <code>StatisticsOpImage</code> make use of a region of interest, specified as an <code>ROI</code> object. Additionally, they may perform spatial subsampling of the region of interest according to <code>xPeriod</code> and <code>yPeriod</code> parameters that may vary from 1 (sample every pixel of the <code>ROI</code>) upwards. This allows the speed and quality of statistics gathering to be traded off against one another.
<p>The <code>accumulateStatistics</code> method is used to accumulate statistics on a specified region into the previously-created statistics object.<code></code>
<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.StatisticsOpImage
</code>
<hr>
</td>
</table><pre><ul>
<li>StatisticsOpImage()
<p></ul></pre><dl>
<a name="53844">
<dt><dd> constructs a default <code>StatisticsOpImage</code>.
</a><P></dl>
<pre><ul>
<li>StatisticsOpImage(RenderedImage source, ROI roi, int xStart, 
       int yStart, int xPeriod, int yPeriod, int maxWidth, <br>
       int maxHeight)
<p></ul></pre><dl>
<a name="53877">
<dt><dd> constructs a <code>StatisticsOpImage</code>. The image layout is copied from the source image.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=8><em>Parameters</em>:<em></em>
<p><td><code>source</code>
<p><td>A <code>RenderedImage</code>.
<p>
<tr valign=top><td><code>roi</code>
<p><td>The region of interest, as an <code>ROI</code>.
<p>
<tr valign=top><td><code>xStart</code>
<p><td>The initial <em>x</em> sample coordinate.
<p>
<tr valign=top><td><code>ystart</code>
<p><td>The initial <em>y</em> sample coordinate.
<p>
<tr valign=top><td><code>xPeriod</code>
<p><td>The <em>x</em> sampling rate.
<p>
<tr valign=top><td><code>yPeriod</code>
<p><td>The <em>y</em> sampling rate.
<p>
<tr valign=top><td><code>maxWidth</code>
<p><td>The largest allowed width for processing.
<p>
<tr valign=top><td><code>maxHeight</code>
<p><td>The largest allowed height for processing.
<p>

</Table>

</a><P></dl>

<p>
<hr><br>
 
<center>
<a href="JAITOC.fm.html"><img src="shared/contents.gif" alt="Contents"></a> <a href="Geom-image-manip.doc.html"><img src="shared/previous.gif" alt="Previous"></a> <a href="Graphics.doc.html"><img src="shared/next.gif" alt="Next"></a> <p><font size=5><i>Programming in Java Advanced Imaging</i></font>
</center>
<br>
 


<h5><a href="copyright.html">Copyright</a> &#169; 1999, Sun Microsystems, Inc.   All rights
reserved.</h5>


<!-- Last updated: Tue Nov 02 18:01:25 1999 -->
</blockquote>
</body>
</html>
