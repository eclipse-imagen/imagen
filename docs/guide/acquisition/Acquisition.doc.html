<html><head><title>Image Acquisition and Display</title></head>
<body bgcolor=#ffffff>
 
<center>
<a href="JAITOC.fm.html"><img src="shared/contents.gif" alt="Contents"></a> <a href="Programming-environ.doc.html"><img src="shared/previous.gif" alt="Previous"></a> <a href="Color.doc.html"><img src="shared/next.gif" alt="Next"></a> <p><font size=5><i>Programming in Java Advanced Imaging</i></font>
</center>
<br>
 
<center>
<a name="81548">
<table width=90% border=0><tr>
<td align=right><font size=3>C H A P T E R</font><font size=7><img src="shared/sm-space.gif">4</td></table>
</a></center><center>
<a name="81550">
<table width=90% border=0><tr><td align=right>
<hr size=7 noshade>
<font size=6>Image Acquisition and Display</font></td></table>
</a></center><blockquote>
<p><br><br><br><P><font size=7><b>T</b></font>HIS chapter describes the Java Advanced Imaging (JAI) API image data types and the API constructors and methods for image acquisition and display.
<p><a name="50856">
<h2>4.1	<img src="shared/space.gif">Introduction</h2>
</a>All imaging applications must perform the basic tasks of acquiring, displaying, and creating (recording) images. Images may be acquired from many sources, including a disk file, the network, a CD, and so on. Images may be acquired, processed, and immediately displayed, or written to a disk file for display at a later time.
<p>As described in <a href="Programming-environ.doc.html#47227">Chapter &#32;3</a>, JAI offers the programmer the flexibility to render and display an image immediately or to defer the display of the rendered image until there is a specific request for it.
<p>Image acquisition and display are relatively easy in JAI, in spite of all the high-level information presented in the next several sections. Take for example, the sample code in <a href="Acquisition.doc.html#82325">Listing &#32;4-1</a>. This is a complete code example for a simple application called <code>FileTest</code>, which takes a single argument; the path and name of the file to read. <code>FileTest</code> reads the named file and displays it in a <code>ScrollingImagePanel</code>. The operator that reads the image file, <code>FileLoad</code>, is described in <a href="Acquisition.doc.html#69930">Section &#32;4.4.1.2, "The FileLoad Operation</a>." The <code>ScrollingImagePanel</code> is described in <a href="Acquisition.doc.html#73265">Section &#32;4.8, "Image Display</a>."<p>
<caption><font size=-1><b>
<a name="82325">
<center><font size=-1><b><i>Listing 4-1	</i><img src="shared/sm-blank.gif" border=0> Example Program to Read and Display an Image File &#32;</b></font></center>
</a><p>
</b></font></caption>
<hr>
<tr valign=top><td colspan=1 rowspan=7><pre>     // Specify the classes to import.
     import java.awt.image.renderable.ParameterBlock;
     import java.io.File;
     import javax.media.jai.JAI;
     import javax.media.jai.PlanarImage;
     import javax.media.jai.RenderedOp;
     import javax.media.jai.widget.ScrollingImagePanel;
</pre>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top><td><pre>     public class FileTest extends WindowContainer {
</pre>
<tr valign=top><td><pre>     // Specify a default image in case the user fails to specify
     // one at run time.
     public static final String DEFAULT_FILE = 
                                    "./images/earth.jpg";
</pre>
<tr valign=top><td colspan=1 rowspan=3><pre>         public static void main(String args[]) {
             String fileName = null;
</pre>
<tr valign=top>
<tr valign=top>
<tr valign=top><td colspan=1 rowspan=11><pre>     // Check for a filename in the argument.
             if(args.length == 0) {
                 fileName = DEFAULT_FILE;
             } else if(args.length == 1) {
                 fileName = args[0];
             } else {
                 System.out.println("\nUsage: java " +
                                    (new FileTest()).getClass().getName() +
                                    " [file]\n");
                 System.exit(0);
             }
</pre>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top><td colspan=1 rowspan=3><pre>             new FileTest(fileName);
         }
</pre>
<tr valign=top>
<tr valign=top>
<tr valign=top><td colspan=1 rowspan=2><pre>         public FileTest() {}
         public FileTest(String fileName) {
</pre>
<tr valign=top>
<tr valign=top><td colspan=1 rowspan=6><pre>        // Read the image from the designated path.
        System.out.println("Creating operation to load image from '" +
                            fileName+"'");
        RenderedOp img =  JAI.create("fileload", fileName);
</pre>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top><td colspan=1 rowspan=3><pre>        // Set display name and layout.
        setTitle(getClass().getName()+": "+fileName);
</pre>
<tr valign=top>
<tr valign=top>
<tr valign=top><td colspan=1 rowspan=8><pre>             // Display the image.
             System.out.println("Displaying image");
             add(new ScrollingImagePanel(img, img.getWidth(),
                                         img.getHeight()));
             pack();
             show();
         }
     }
</pre>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>

<hr>

<p><a name="51157">
<h3>4.1.1	<img src="shared/space.gif">Image Data</h3>
</a>Image data is, conceptually, a three-dimensional array of pixels, as shown in <a href="Acquisition.doc.html#51833">Figure &#32;4-1</a>. Each of the three arrays in the example is called a <em>band</em>. The number of rows specifies the image height of a band, and the number of columns specifies the image width of a band.
<p>Monochrome images, such as a grayscale image, have only one band. Color images have three or more bands, although a band does not necessarily have to represent color. For example, satellite images of the earth may be acquired in several different spectral bands, such as red, green, blue, and infrared.
<p>In a color image, each band stores the red, green, and blue (RGB) components of an additive image, or the cyan, magenta, and yellow (CMY) components of a three-color subtractive image, or the cyan, magenta, yellow, and black (CMYK) components of a four-color subtractive image. Each pixel of an image is composed of a set of <em>samples</em>. For an RGB pixel, there are three samples; one each for red, green, and blue.
<p>An image is sampled into a rectangular array of pixels. Each pixel has an (<em>x</em>,<em>y</em>) coordinate that corresponds to its location within the image. The <em>x</em> coordinate is the pixel's horizontal location; the <em>y</em> coordinate is the pixel's vertical location. Within JAI, the pixel at location (0,0) is in the upper left corner of the image, with the <em>x</em> coordinates increasing in value to the right and <em>y</em> coordinates increasing in value downward. Sometimes the <em>x</em> coordinate is referred to as the pixel number and the <em>y</em> coordinate as the line number.
<p><a name="51832">
 <hr>
<center><img src="Acquisition.doc.anc3.gif"></center><hr>

</a>
<a name="51833">
<center><font size=-1><b><i>Figure 4-1	</i><img src="shared/sm-blank.gif" border=0> Multi-band Image Structure</b></font></center>
</a><p>
<a name="52258">
<h3>4.1.2	<img src="shared/space.gif">Basic Storage Types</h3>
</a>In the JAI API, the basic unit of data storage is the <code>DataBuffer</code> object. The <code>DataBuffer</code> object is a kind of raw storage that holds all the samples that make up the image, but does not contain any information on how those samples are put together as pixels. How the samples are put together is contained in a <code>SampleModel</code> object. The <code>SampleModel</code> class contains methods for deriving pixel data from a <code>DataBuffer</code>.
<p>JAI supports several image data types, so the <code>DataBuffer</code> class has the following subclasses, each representing a different data type:
<p><ul>
<li><code>DataBufferByte</code> - stores data internally as bytes (8-bit values)<p></ul><ul>
<li><code>DataBufferShort</code> - stores data internally as shorts (16-bit values)<p></ul><ul>
<li><code>DataBufferUShort</code> - stores data internally as unsigned shorts (16-bit values)<code></code><p></ul><ul>
<li><code>DataBufferInt</code> - stores data internally as integers (32-bit values)<p></ul><ul>
<li><code>DataBufferFloat</code> - stores data internally as single-precision floating-point values.<p></ul><ul>
<li><code>DataBufferDouble</code> - stores data internally as double-precision floating-point values.<p></ul><a href="Acquisition.doc.html#78780">Table &#32;4-1</a> lists the <code>DataBuffer</code> type elements.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b><a name="78780">
<i>Table 4-1	 </i><img src="shared/sm-blank.gif" border=0> Data Buffer Type Elements
</a></b></font></caption>
<tr valign=top><th><a name="78784">
Name
</a><th><a name="78786">
Description
</a>
<tr valign=top><td><a name="78859">
TYPE_INT</a><br><td><a name="78861">
Tag for int data.</a><br>
<tr valign=top><td><a name="78788">
TYPE_BYTE</a><br><td><a name="78790">
Tag for unsigned byte data.</a><br>
<tr valign=top><td><a name="78867">
TYPE_SHORT</a><br><td><a name="78869">
Tag for signed short data.</a><br>
<tr valign=top><td><a name="78871">
TYPE_USHORT</a><br><td><a name="78873">
Tag for unsigned short data.</a><br>
<tr valign=top><td><a name="78792">
TYPE_DOUBLE</a><br><td><a name="78794">
Tag for double data.</a><br>
<tr valign=top><td><a name="78796">
TYPE_FLOAT</a><br><td><a name="78798">
Tag for float data.</a><br>
<tr valign=top><td><a name="78851">
TYPE_UNDEFINED</a><br><td><a name="78853">
Tag for undefined data.</a><br>

</Table>

<p>JAI also supports a large number of image data formats, so the <code>SampleModel</code> class provides the following types of sample models:
<p><ul>
<li><code>ComponentSampleModel</code> - used to extract pixels from images that store sample data in separate data array elements in one bank of a <code>DataBuffer</code> object.<p></ul><ul>
<li><code>ComponentSampleModelJAI</code> - used to extract pixels from images that store sample data such that each sample of a pixel occupies one data element of the <code>DataBuffer</code>.<p></ul><ul>
<li><code>BandedSampleModel</code> - used to extract pixels from images that store each sample in a separate data element with bands stored in a sequence of data elements.<p></ul><ul>
<li><code>PixelInterleavedSampleModel</code> - used to extract pixels from images that store each sample in a separate data element with pixels stored in a sequence of data elements.<p></ul><ul>
<li><code>MultiPixelPackedSampleModel</code> - used to extract pixels from single-banded images that store multiple one-sample pixels in one data element.<p></ul><ul>
<li><code>SinglePixelPackedSampleModel</code> - used to extract samples from images that store sample data for a single pixel in one data array element in the first bank of a <code>DataBuffer</code> object.<p></ul><ul>
<li><code>FloatComponentSampleModel</code> - stores <em>n</em> samples that make up a pixel in <em>n</em> separate data array elements, all of which are in the same bank in a <code>DataBuffer</code> object. This class supports different kinds of interleaving.<p></ul>The combination of a <code>DataBuffer</code> object, a <code>SampleModel</code> object, and an origin constitute a meaningful multi-pixel image storage unit called a <code>Raster</code>. The <code>Raster</code> class has methods that directly return pixel data for the image data it contains.
<p>There are two basic <code>Raster</code> types:
<p><ul>
<li><code>Raster</code> - represents a rectangular array of pixels. This is a "read-only" class that only has get methods.<p></ul><ul>
<li><code>WritableRaster</code> - extends <code>Raster</code> to provide pixel writing capabilities.<p></ul>There are separate interfaces for dealing with each raster type:
<p><ul>
<li>The <code>RenderedImage</code> interface assumes the data is read-only and, therefore, does not contain methods for writing a <code>Raster</code>.<p></ul><ul>
<li>The <code>WriteableRenderedImage</code> interfaces assumes that the image data can be modified.<p></ul>A <code>ColorModel</code> class provides a color interpretation of pixel data provided by the image's sample model. The abstract <code>ColorModel</code> class defines methods for turning an image's pixel data into a color value in its associated <code>ColorSpace</code>. See <a href="Color.doc.html#51226">Section &#32;5.2.1, "Color Models</a>."
<p><a name="52212">
 <hr>
<center><img src="Acquisition.doc.anc4.gif"></center><hr>

</a>
<a name="52213">
<center><font size=-1><b><i>Figure 4-2	</i><img src="shared/sm-blank.gif" border=0> BufferedImage</b></font></center>
</a><p>
As shown in <a href="Acquisition.doc.html#52213">Figure &#32;4-2</a>, the combination of a <code>Raster</code> and a <code>ColorModel</code> define a <code>BufferedImage</code>. The <code>BufferedImage</code> class provides general image management for immediate mode imaging.
<p>The <code>BufferedImage</code> class supports the following predefined image types:<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b><a name="78521">
<i>Table 4-2	 </i><img src="shared/sm-blank.gif" border=0> Supported Image Types
</a></b></font></caption>
<tr valign=top><th><a name="78525">
Name
</a><th><a name="78527">
Description
</a>
<tr valign=top><td><a name="78529">
TYPE_3BYTE_BGR</a><br><td><a name="78588">
Represents an image with 8-bit RGB color components, corresponding to a Windows-style BGR color model, with the colors blue, green, and red stored in three bytes.</a><br>
<tr valign=top><td><a name="78533">
TYPE_4BYTE_ABGR</a><br><td><a name="78606">
Represents an image with 8-bit RGBA color components with the colors blue, green, and red stored in three bytes and one byte of alpha.</a><br>
<tr valign=top><td><a name="78537">
TYPE_4BYTE_ABGR_PRE</a><br><td><a name="78619">
Represents an image with 8-bit RGBA color components with the colors blue, green, and red stored in three bytes and one byte of alpha.</a><br>
<tr valign=top><td><a name="78541">
TYPE_BYTE_BINARY</a><br><td><a name="78543">
Represents an opaque byte-packed binary image.</a><br>
<tr valign=top><td><a name="78545">
TYPE_BYTE_GRAY</a><br><td><a name="78547">
Represents a unsigned byte grayscale image, non-indexed.</a><br>
<tr valign=top><td><a name="78549">
TYPE_BYTE_INDEXED</a><br><td><a name="78551">
Represents an indexed byte image.</a><br>
<tr valign=top><td><a name="78553">
TYPE_CUSTOM</a><br><td><a name="78555">
Image type is not recognized so it must be a customized image.</a><br>
<tr valign=top><td><a name="78557">
TYPE_INT_ARGB</a><br><td><a name="78669">
Represents an image with 8-bit RGBA color components packed into integer pixels.</a><br>
<tr valign=top><td><a name="78561">
TYPE_INT_ARGB_PRE</a><br><td><a name="78708">
Represents an image with 8-bit RGB color components, corresponding to a Windows- or Solaris- style BGR color model, with the colors blue, green, and red packed into integer pixels.</a><br>
<tr valign=top><td><a name="78565">
TYPE_INT_BGR</a><br><td><a name="78718">
Represents an image with 8-bit RGB color components, corresponding to a Windows- or Solaris- style BGR color model, with the colors blue, green, and red packed into integer pixels.</a><br>
<tr valign=top><td><a name="78569">
TYPE_INT_RGB</a><br><td><a name="78732">
Represents an image with 8-bit RGB color components packed into integer pixels.</a><br>
<tr valign=top><td><a name="78573">
TYPE_USHORT_555_RGB</a><br><td><a name="78743">
Represents an image with 5-5-5 RGB color components (5-bits red, 5-bits green, 5-bits blue) with no alpha.</a><br>
<tr valign=top><td><a name="78577">
TYPE_USHORT_565_RGB</a><br><td><a name="78750">
Represents an image with 5-6-5 RGB color components (5-bits red, 6-bits green, 5-bits blue) with no alpha.</a><br>
<tr valign=top><td><a name="78581">
TYPE_USHORT_GRAY</a><br><td><a name="78583">
Represents an unsigned short grayscale image, non-indexed).</a><br>

</Table>

<p><a name="52336">
<h2>4.2	<img src="shared/space.gif">JAI Image Types</h2>
</a>The JAI API provides a set of classes for describing image data of various kinds. These classes are organized into a class hierarchy, as shown in <a href="Acquisition.doc.html#53019">Figure &#32;4-3</a>.
<p><a name="53017">
 <hr>
<center><img src="Acquisition.doc.anc5.gif"></center><hr>

</a>
<a name="53019">
<center><font size=-1><b><i>Figure 4-3	</i><img src="shared/sm-blank.gif" border=0> JAI Image Type Hierarchy</b></font></center>
</a><p>
<a name="77718">
<h3>4.2.1	<img src="shared/space.gif">Planar Image</h3>
</a>The <code>PlanarImage</code> class is the main class for defining two-dimensional images. The <code>PlanarImage</code> implements the <code>java.awt.image.RenderedImage</code> interface, which describes a tiled, read-only image with a pixel layout described by a <code>SampleModel</code> and a <code>DataBuffer</code>. The <code>TiledImage</code> and <code>OpImage</code> subclasses manipulate the instance variables they inherit from <code>PlanarImage</code>, such as the image size, origin, tile dimensions, and tile grid offsets, as well as the Vectors containing the sources and sinks of the image.
<p>All non-JAI <code>RenderedImages</code> that are to be used in JAI must be converted into <code>PlanarImages</code> by means of the <code>RenderedImageAdapter</code> class and the <code>WriteableRenderedImageAdapter</code> class. The <code>wrapRenderedImage()</code> method provides a convenient interface to both add a wrapper and take a snapshot if the image is writable. The standard <code>PlanarImage</code> constructor used by <code>OpImages</code> performs this wrapping automatically. Images that already extend <code>PlanarImage</code> will be returned unchanged by <code>wrapRenderedImage()</code>.
<p>Going in the other direction, existing code that makes use of the <code>RenderedImage</code> interface will be able to use <code>PlanarImage</code>s directly, without any changes or recompilation. Therefore within JAI, images are returned from methods as <code>PlanarImages</code>, even though incoming <code>RenderedImage</code>s are accepted as arguments directly.
<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.PlanarImage
</code>
<hr>
</td>
</table><pre><ul>
<li>PlanarImage()
<p></ul></pre><dl>
<a name="77725">
<dt><dd> creates a <code>PlanarImage</code>.
</a><P></dl>
<pre><ul>
<li>static PlanarImage wrapRenderedImage(RenderedImage im)
<p></ul></pre><dl>
<a name="77727">
<dt><dd> wraps an arbitrary <code>RenderedImage</code> to produce a <code>PlanarImage</code>. <code>PlanarImage</code> adds various properties to an image, such as source and sink vectors and the ability to produce snapshots, that are necessary for JAI. If the image is not a <code>PlanarImage</code>, it is wrapped in a <code>RenderedImageAdapter</code>. If the image implements <code>WritableRenderedImage</code>, a snapshot is taken.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td><em>Parameters</em>:
<p><td><code>a</code>
<p><td><code>RenderedImage</code> to be used as a synchronous source.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>PlanarImage createSnapshot()
<p></ul></pre><dl>
<a name="77736">
<dt><dd> creates a snapshot, that is, a virtual copy of the image's current contents.
</a><P></dl>
<pre><ul>
<li>Raster getData(Rectangle region)
<p></ul></pre><dl>
<a name="78986">
<dt><dd> returns a specified region of this image in a <code>Raster</code>.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td><em>Parameter</em>:<em></em>
<p><td><code>region</code>
<p><td>The rectangular region of this image to be returned.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>int getWidth()
<p></ul></pre><dl>
<a name="77738">
<dt><dd> returns the width of the image.
</a><P></dl>
<pre><ul>
<li>int getHeight()
<p></ul></pre><dl>
<a name="77740">
<dt><dd> returns the height of the image.
</a><P></dl>
<pre><ul>
<li>int getMinXCoord()
<p></ul></pre><dl>
<a name="77742">
<dt><dd> returns the X coordinate of the leftmost column of the image.
</a><P></dl>
<pre><ul>
<li>int getMaxXCoord()
<p></ul></pre><dl>
<a name="77744">
<dt><dd> returns the X coordinate of the rightmost column of the image.
</a><P></dl>
<pre><ul>
<li>int getMinYCoord()
<p></ul></pre><dl>
<a name="77746">
<dt><dd> returns the X coordinate of the uppermost row of the image.
</a><P></dl>
<pre><ul>
<li>int getMaxYCoord()
<p></ul></pre><dl>
<a name="77748">
<dt><dd> returns the X coordinate of the bottom row of the image.
</a><P></dl>
<pre><ul>
<li>Rectangle getBounds()
<p></ul></pre><dl>
<a name="77750">
<dt><dd> returns a Rectangle indicating the image bounds.
</a><P></dl>
<pre><ul>
<li>int getTileWidth()
<p></ul></pre><dl>
<a name="77752">
<dt><dd> returns the width of a tile.
</a><P></dl>
<pre><ul>
<li>int getTileHeight()
<p></ul></pre><dl>
<a name="77754">
<dt><dd> returns the height of a tile.
</a><P></dl>
<pre><ul>
<li>int tilesAcross()
<p></ul></pre><dl>
<a name="77756">
<dt><dd> returns the number of tiles along the tile grid in the horizontal direction. Equivalent to <code>getMaxTileX() - getMinTileX() + 1</code>. 
</a><P></dl>
<pre><ul>
<li>int tilesDown()
<p></ul></pre><dl>
<a name="77758">
<dt><dd> returns the number of tiles along the tile grid in the vertical direction. Equivalent to <code>getMaxTileY() - getMinTileY() + 1</code>. 
</a><P></dl>
There are lots more methods.
<p><a name="52363">
<h3>4.2.2	<img src="shared/space.gif">Tiled Image</h3>
</a>The JAI API expands on the tile data concept introduced in the Java 2D API. In Java 2D, a tile is one of a set of rectangular regions that span an image on a regular grid. The JAI API expands on the tile image with the <code>TiledImage</code> class, which is the main class for writable images in JAI.
<p>A tile represents all of the storage for its spatial region of the image. If an image contains three bands, every tile represents all three bands of storage. The use of tiled images improves application performance by allowing the application to process an image region within a single tile without bringing the entire image into memory.
<p><code>TiledImage</code> provides a straightforward implementation of the <code>WritableRenderedImage</code> interface, taking advantage of that interface's ability to describe images with multiple tiles. The tiles of a <code>WritableRenderedImage</code> must share a <code>SampleModel</code>, which determines their width, height, and pixel format.
<p>The tiles form a regular grid that may occupy any rectangular region of the plane. Tile pixels that exceed the image's stated bounds have undefined values. 
<p>The contents of a <code>TiledImage</code> are defined by a single <code>PlanarImage</code> source, provided either at construction time or by means of the <code>set()</code> method. The <code>set()</code> method provides a way to selectively overwrite a portion of a <code>TiledImage</code>, possibly using a soft-edged mask. 
<p><code>TiledImage</code> also supports direct manipulation of pixels by means of the <code>getWritableTile</code> method. This method returns a <code>WritableRaster</code> that can be modified directly. Such changes become visible to readers according to the regular thread synchronization rules of the Java virtual machine; JAI makes no additional guarantees. When a writer is finished modifying a tile, it should call the <code>releaseWritableTile</code> method. A shortcut is to call the <code>setData()</code> method, which copies a rectangular region from a supplied <code>Raster</code> directly into the <code>TiledImage</code>.
<p>A final way to modify the contents of a <code>TiledImage</code> is through calls to the <code>createGraphics()</code> method. This method returns a <code>GraphicsJAI</code> object that can be used to draw line art, text, and images in the usual AWT manner. 
<p>A <code>TiledImage</code> does not attempt to maintain synchronous state on its own. That task is left to <code>SnapshotImage</code>. If a synchronous (unchangeable) view of a <code>TiledImage</code> is desired, its <code>createSnapshot()</code> method must be used. Otherwise, changes due to calls to <code>set()</code> or direct writing of tiles by objects that call <code>getWritableTile()</code> will be visible.
<p><code>TiledImage</code> does not actually cause its tiles to be computed until their contents are demanded. Once a tile has been computed, its contents may be discarded if it can be determined that it can be recomputed identically from the source. The <code>lockTile()</code> method forces a tile to be computed and maintained for the lifetime of the <code>TiledImage</code>.
<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.TiledImage
</code>
<hr>
</td>
</table><pre><ul>
<li>TiledImage(Point origin, SampleModel sampleModel, 
       int &#32;tileWidth, int tileHeight)
<p></ul></pre><dl>
<a name="52409">
<dt><dd> constructs a <code>TiledImage</code> with a <code>SampleModel</code> that is compatible with a given <code>SampleModel</code>, and given tile dimensions. The width and height are taken from the <code>SampleModel</code>, and the image begins at a specified point.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=4><em>Parameters</em>:
<p><td><code>origin</code>
<p><td>A Point indicating the image's upper left corner.
<p>
<tr valign=top><td><code>sampleModel</code>
<p><td>A SampleModel with which to be compatible.
<p>
<tr valign=top><td><code>tileWidth</code>
<p><td>The desired tile width.
<p>
<tr valign=top><td><code>tileHeight</code>
<p><td>The desired tile height.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>TiledImage(SampleModel sampleModel, int tileWidth, 
       int &#32;tileHeight)
<p></ul></pre><dl>
<a name="52524">
<dt><dd> constructs a <code>TiledImage</code> starting at the global coordinate origin.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=3><em>Parameters</em>:
<p><td><code>sampleModel</code>
<p><td>A <code>SampleModel</code> with which to be compatible.
<p>
<tr valign=top><td><code>tileWidth</code>
<p><td>The desired tile width.
<p>
<tr valign=top><td><code>tileHeight</code>
<p><td>The desired tile height.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>TiledImage(int minX, int minY, int width, int height, 
       int &#32;tileGridXOffset, int tileGridYOffset, 
       SampleModel &#32;sampleModel, ColorModel colorModel)
<p></ul></pre><dl>
<a name="54010">
<dt><dd> constructs a <code>TiledImage</code> of a specified width and height.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=8><em>Parameters</em>:
<p><td><code>minX</code>
<p><td>The index of the leftmost column of tiles.
<p>
<tr valign=top><td><code>minY</code>
<p><td>The index of the uppermost row of tiles.
<p>
<tr valign=top><td><code>width</code>
<p><td>The width of the <code>TiledImage</code>.
<p>
<tr valign=top><td><code>height</code>
<p><td>The height of the <code>TiledImage</code>.
<p>
<tr valign=top><td><code>tileGridX-Offset</code>
<p><td>The <em>x</em> coordinate of the upper-left pixel of tile (0, 0).
<p>
<tr valign=top><td><code>tileGridY-Offset</code>
<p><td>The <em>y</em> coordinate of the upper-left pixel of tile (0, 0).
<p>
<tr valign=top><td><code>sampleModel</code>
<p><td>a <code>SampleModel</code> with which to be compatible.
<p>
<tr valign=top><td><code>colorModel</code>
<p><td>A <code>ColorModel</code> to associate with the image.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>void setData(Raster r)
<p></ul></pre><dl>
<a name="77626">
<dt><dd> sets a region of a <code>TiledImage</code> to be a copy of a supplied <code>Raster</code>. The <code>Raster</code>'s coordinate system is used to position it within the image. The computation of all overlapping tiles will be forced prior to modification of the data of the affected area.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td><em>Parameter</em>:<em></em>
<p><td><code>r</code>
<p><td>A <code>Raster</code> containing pixels to be copied into the <code>TiledImage</code>.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>void setData(Raster r, ROI roi)
<p></ul></pre><dl>
<a name="77688">
<dt><dd> sets a region of a <code>TiledImage</code> to be a copy of a supplied <code>Raster</code>. The <code>Raster</code>'s coordinate system is used to position it within the image. The computation of all overlapping tiles will be forced prior to modification of the data of the affected area.
</a><P></dl>
<pre><ul>
<li>WritableRaster getWritableTile(int tileX, int tileY)
<p></ul></pre><dl>
<a name="52639">
<dt><dd> retrieves a particular tile from the image for reading and writing. The tile will be computed if it hasn't been previously. Writes to the tile will become visible to readers of this image in the normal Java manner.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=2><em>Parameters</em>:
<p><td><code>tileX</code>
<p><td>The <em>x</em> index of the tile.
<p>
<tr valign=top><td><code>tileY</code>
<p><td>The <em>y</em> index of the tile.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>Raster getTile(int tileX, int tileY)
<p></ul></pre><dl>
<a name="52691">
<dt><dd> retrieves a particular tile from the image for reading only. The tile will be computed if it hasn't been previously. Any attempt to write to the tile will produce undefined results. <p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=2><em>Parameters</em>:
<p><td><code>tileX</code>
<p><td>The <em>x</em> index of the tile.
<p>
<tr valign=top><td><code>tileY</code>
<p><td>The <em>y</em> index of the tile.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>boolean isTileWritable(int tileX, int tileY)
<p></ul></pre><dl>
<a name="52792">
<dt><dd> returns true if a tile has writers. <p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=2><em>Parameters</em>:
<p><td><code>tileX</code>
<p><td>The <em>x</em> index of the tile.
<p>
<tr valign=top><td><code>tileY</code>
<p><td>The <em>y</em> index of the tile.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>boolean hasTileWriters()
<p></ul></pre><dl>
<a name="52825">
<dt><dd> returns true if any tile is being held by a writer, false otherwise. This provides a quick way to check whether it is necessary to make copies of tiles - if there are no writers, it is safe to use the tiles directly, while registering to learn of future writers. 
</a><P></dl>
<pre><ul>
<li>void releaseWritableTile(int tileX, int tileY)
<p></ul></pre><dl>
<a name="52849">
<dt><dd> indicates that a writer is done updating a tile. The effects of attempting to release a tile that has not been grabbed, or releasing a tile more than once are undefined.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=2><em>Parameters</em>:
<p><td><code>tileX</code>
<p><td>The <em>x</em> index of the tile.
<p>
<tr valign=top><td><code>tileY</code>
<p><td>The <em>y</em> index of the tile.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>void set(RenderedImage im)
<p></ul></pre><dl>
<a name="59584">
<dt><dd> overlays a given <code>RenderedImage</code> on top of the current contents of the <code>TiledImage</code>. The source image must have a <code>SampleModel</code> compatible with that of this image.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td><em>Parameters</em>:
<p><td><code>im</code>
<p><td>A <code>RenderedImage</code> source to replace the current source.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>void set(RenderedImage im, ROI roi)
<p></ul></pre><dl>
<a name="59604">
<dt><dd> overlays a given <code>RenderedImage</code> on top of the current contents of the <code>TiledImage</code>. The source image must have a <code>SampleModel</code> compatible with that of this image.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=2><em>Parameters</em>:
<p><td><code>im</code>
<p><td>A <code>RenderedImage</code> source to replace the current source.
<p>
<tr valign=top><td><code>roi</code>
<p><td>The region of interest.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>Graphics2D createGraphics()
<p></ul></pre><dl>
<a name="52999">
<dt><dd> creates a <code>Graphics2D</code> object that can be used to paint text and graphics onto the <code>TiledImage</code>.
</a><P></dl>
<a name="81240">
<h4>4.2.2.1	<img src="shared/space.gif">Tile Cache</h4>
</a>The <code>TileCache</code> interface provides a central place for <code>OpImage</code>s to cache tiles they have computed. The tile cache is created with a given capacity (measured in tiles). By default, the tile capacity for a new tile cache is 300 tiles. The default memory capacity reserved for tile cache is 20M bytes.
<p>The <code>TileCache</code> to be used by a particular operation may be set during construction, or by calling the <code>JAI.setTileCache</code> method. This results in the provided tile cache being added to the set of common rendering hints.
<p>The <code>TileScheduler</code> interface allows tiles to be scheduled for computation. In various implementations, tile computation may make use of multithreading and multiple simultaneous network connections for improved performance.
<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai
</code>
<hr>
</td>
</table><pre><ul>
<li>static TileCache createTileCache(int tileCapacity, 
       long &#32;memCapacity)
<p></ul></pre><dl>
<a name="81433">
<dt><dd> constructs a <code>TileCache</code> with the given tile capacity in tiles and memory capacity in bytes. Users may supply an instance of <code>TileCache</code> to an operation by supplying a <code>RenderingHint</code> with a <code>JAI.KEY_TILE_CACHE</code> key and the desired <code>TileCache</code> instance as its value. Note that the absence of a tile cache hint will result in the use of the <code>TileCache</code> belonging to the default <code>JAI</code> instance. To force an operation not to perform caching, a <code>TileCache</code> instance with a tile capacity of 0 may be used.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=2><em>Parameters</em>
<p><td><code>tileCapacity</code>
<p><td>The tile capacity, in tiles.
<p>
<tr valign=top><td><code>memCapacity</code>
<p><td>The memory capacity, in bytes.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>static TileCache createTileCache()
<p></ul></pre><dl>
<a name="81455">
<dt><dd> constructs a <code>TileCache</code> with the default tile capacity in tiles and memory capacity in bytes.
</a><P></dl>
<pre><ul>
<li>void setTileCache(TileCache tileCache)
<p></ul></pre><dl>
<a name="81504">
<dt><dd> sets the <code>TileCache</code> to be used by this <code>JAI</code> instance. The <code>tileCache</code> parameter will be added to the <code>RenderingHints</code> of this JAI instance.
</a><P></dl>
<pre><ul>
<li>TileCache getTileCache()
<p></ul></pre><dl>
<a name="81506">
<dt><dd> returns the <code>TileCache</code> being used by this <code>JAI</code> instance.
</a><P></dl>
<a name="81379">
<h4>4.2.2.2	<img src="shared/space.gif">Pattern Tiles</h4>
</a>A pattern tile consists of a repeated pattern. The <code>pattern</code> operation defines a pattern tile by specifying the width and height; all other layout parameters are optional, and when not specified are set to default values. Each tile of the destination image will be defined by a reference to a shared instance of the pattern.
<p>The <code>pattern</code> operation takes three parameters:<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="60563">
Parameter
</a><th><a name="60565">
Type
</a><th><a name="60567">
Description
</a>
<tr valign=top><td><a name="60581">
width</a><br><td><a name="60583">
Integer</a><br><td><a name="60585">
The width of the image in pixels.</a><br>
<tr valign=top><td><a name="60587">
height</a><br><td><a name="60589">
Integer</a><br><td><a name="60591">
The height of the image in pixels.</a><br>
<tr valign=top><td><a name="60599">
pattern</a><br><td><a name="60601">
Raster</a><br><td><a name="60603">
The Pattern pixel band values.</a><br>

</Table>

<p><a href="Acquisition.doc.html#79244">Listing &#32;4-2</a> shows a code sample for a <code>pattern</code> operation.<p>
<caption><font size=-1><b>
<a name="79244">
<center><font size=-1><b><i>Listing 4-2	</i><img src="shared/sm-blank.gif" border=0> Example Pattern Operation &#32;</b></font></center>
</a><p>
</b></font></caption>
<hr>
<tr valign=top><td><pre>     // Create the raster.
     WritableRaster raster;
     int[] bandOffsets = new int[3];
     bandOffsets[0] = 2;
     bandOffsets[1] = 1;
     bandOffsets[2] = 0;
</pre>
<tr valign=top><td><pre>     // width, height=64.
     PixelInterleavedSampleModel sm;
     sm = new PixelInterleavedSampleModel(DataBuffer.TYPE_BYTE, 100,
                                        100, 3, 3*100, bandOffsets);
</pre>
<tr valign=top><td><pre>     // Origin is 0,0.
     WritableRaster pattern = Raster.createWritableRaster(sm,
                                  new Point(0, 0));
     int[] bandValues = new int[3];
     bandValues[0] = 90;
     bandValues[1] = 45;
     bandValues[2] = 45
</pre>
<tr valign=top><td><pre>     // Set values for the pattern raster.
     for (int y = 0; y &lt; pattern.getHeight(); y++) {
     for (int x = 0; x &lt; pattern.getWidth(); x++) {
         pattern.setPixel(x, y, bandValues);
         bandValues[1] = (bandValues[1]+1)%255;
         bandValues[2] = (bandValues[2]+1)%255;
         }
     }
</pre>
<tr valign=top><td><pre>     // Create a 100x100 image with the given raster.
     PlanarImage im0 = (PlanarImage)JAI.create("pattern",
                                                100, 100,
                                                pattern);
</pre>

<hr>

<p><a name="53341">
<h3>4.2.3	<img src="shared/space.gif">Snapshot Image</h3>
</a>The <code>SnapshotImage</code> class represents the main component of the deferred execution engine. A <code>SnapshotImage</code> provides an arbitrary number of synchronous views of a possibly changing <code>WritableRenderedImage</code>. <code>SnapshotImage</code> is responsible for stabilizing changing sources to allow deferred execution of operations dependent on such sources.
<p>Any <code>RenderedImage</code> may be used as the source of a <code>SnapshotImage</code>. If the source is a <code>WritableRenderedImage</code>, the <code>SnapshotImage</code> will register itself as a <code>TileObserver</code> and make copies of tiles that are about to change.
<p>Multiple versions of each tile are maintained internally, as long as they are in demand. <code>SnapshotImage</code> is able to track demand and should be able to simply forward requests for tiles to the source most of the time, without the need to make a copy. 
<p>When used as a source, calls to <code>getTile</code> will simply be passed along to the source. In other words, <code>SnapshotImage</code> is completely transparent. However, by calling <code>createSnapshot()</code> an instance of a non-public <code>PlanarImage</code> subclass (called <code>Snapshot</code> in this implementation) will be created and returned. This image will always return tile data with contents as of the time of its construction. 
<p><a name="54671">
<h4>4.2.3.1	<img src="shared/space.gif">Creating a SnapshotImage</h4>
</a>This implementation of <code>SnapshotImage</code> makes use of a doubly-linked list of <code>Snapshot</code> objects. A new <code>Snapshot</code> is added to the tail of the list whenever <code>createSnapshot()</code> is called. Each <code>Snapshot</code> has a cache containing copies of any tiles that were writable at the time of its construction, as well as any tiles that become writable between the time of its construction and the construction of the next <code>Snapshot</code>.
<p><a name="54672">
<h4>4.2.3.2	<img src="shared/space.gif">Using SnapshotImage with a Tile</h4>
</a>When asked for a tile, a <code>Snapshot</code> checks its local cache and returns its version of the tile if one is found. Otherwise, it forwards the request onto its successor. This process continues until the latest Snapshot is reached; if it does not contain a copy of the tile, the tile is requested from the real source image. 
<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.SnapShotImage
</code>
<hr>
</td>
</table><pre><ul>
<li>SnapshotImage(PlanarImage source)
<p></ul></pre><dl>
<a name="57441">
<dt><dd> constructs a <code>SnapshotImage</code> from a <code>PlanarImage</code> source.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td><em>Parameters</em>:
<p><td><code>source</code>
<p><td>a <code>PlanarImage</code> source.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>Raster getTile(int tileX, int tileY)
<p></ul></pre><dl>
<a name="53425">
<dt><dd> returns a non-snapshotted tile from the source.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=2><em>Parameters</em>:
<p><td><code>tileX</code>
<p><td>the X index of the tile.
<p>
<tr valign=top><td><code>tileY</code>
<p><td>the Y index of the tile.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>void tileUpdate(java.awt.image.WritableRenderedImage source, 
       int tileX, int tileY, boolean willBeWritable)
<p></ul></pre><dl>
<a name="54156">
<dt><dd> receives the information that a tile is either about to become writable, or is about to become no longer writable.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=4><em>Parameters</em>:
<p><td><code>source</code>
<p><td>the <code>WritableRenderedImage</code> for which we are an observer.
<p>
<tr valign=top><td><code>tileX</code>
<p><td>the <em>x</em> index of the tile.
<p>
<tr valign=top><td><code>tileY</code>
<p><td>the <em>y</em> index of the tile.
<p>
<tr valign=top><td><code>willBeWrit-able</code>
<p><td>true if the tile is becoming writable.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>PlanarImage createSnapshot()
<p></ul></pre><dl>
<a name="57427">
<dt><dd> creates a snapshot of this image. This snapshot may be used indefinitely, and will always appear to have the pixel data that this image has currently. The snapshot is semantically a copy of this image but may be implemented in a more efficient manner. Multiple snapshots taken at different times may share tiles that have not changed, and tiles that are currently static in this image's source do not need to be copied at all.
</a><P></dl>
<a name="54570">
<h4>4.2.3.3	<img src="shared/space.gif">Disposing of a Snapshot Image</h4>
</a>When a <code>Snapshot</code> is no longer needed, its <code>dispose()</code> method may be called. The <code>dispose()</code> method will be called automatically when the <code>Snapshot</code> is finalized by the garbage collector. The <code>dispose()</code> method attempts to push the contents of its tile cache back to the previous <code>Snapshot</code> in the linked list. If that image possesses a version of the same tile, the tile is not pushed back and may be discarded.
<p>Disposing of the <code>Snapshot</code> allows tile data held by the Snapshot that is not needed by any other <code>Snapshot</code> to be disposed of as well.
<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.PlanarImage
</code>
<hr>
</td>
</table><pre><ul>
<li>void dispose()
<p></ul></pre><dl>
<a name="55115">
<dt><dd> provides a hint that an image will no longer be accessed from a reference in user space. The results are equivalent to those that occur when the program loses its last reference to this image, the garbage collector discovers this, and finalize is called. This can be used as a hint in situations where waiting for garbage collection would be overly conservative.
</a><P></dl>
<a name="77770">
<h3>4.2.4	<img src="shared/space.gif">Remote Image</h3>
</a>A <code>RemoteImage</code> is a sub-class of <code>PlanarImage</code> which represents an image on a remote server. A <code>RemoteImage</code> may be constructed from a <code>RenderedImage</code> or from an imaging chain in either the rendered or renderable modes. For more information, see <a href="Client-server.doc.html#47285">Chapter &#32;12, "Client-Server Imaging</a>."
<p><a name="53305">
<h3>4.2.5	<img src="shared/space.gif">Collection Image</h3>
</a>The <code>CollectionImage</code> class is an abstract superclass for classes representing groups of images. Examples of groups of images include pyramids (<code>ImagePyramid</code>), time sequences (<code>ImageSequence</code>), and planar slices stacked to form a volume (<code>ImageStack</code>).
<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.CollectionImage
</code>
<hr>
</td>
</table><pre><ul>
<li>CollectionImage()
<p></ul></pre><dl>
<a name="54682">
<dt><dd> the default constructor.
</a><P></dl>
<pre><ul>
<li>CollectionImage(java.util.Collection images)
<p></ul></pre><dl>
<a name="54248">
<dt><dd> constructs a <code>CollectionImage</code> object from a Vector of <code>ImageJAI</code> objects.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td><em>Parameters</em>:
<p><td><code>images</code>
<p><td>A Vector of <code>ImageJAI</code> objects.
<p>

</Table>

</a><P></dl>
<a name="77784">
<h3>4.2.6	<img src="shared/space.gif">Image Sequence</h3>
</a>The <code>ImageSequence</code> class represents a sequence of images with associated timestamps and a camera position. It can be used to represent video or time-lapse photography.
<p>The images are of the type <code>ImageJAI</code>. The timestamps are of the type <code>long</code>. The camera positions are of the type <code>Point</code>. The tuple (image, time stamp, camera position) is represented by class <code>SequentialImage</code>.
<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.ImageSequence
</code>
<hr>
</td>
</table><pre><ul>
<li>ImageSequence(Collection images)
<p></ul></pre><dl>
<a name="77790">
<dt><dd> constructs a class that represents a sequence of images from a collection of <code>SequentialImage</code>.
</a><P></dl>
<a name="77800">
<h3>4.2.7	<img src="shared/space.gif">Image Stack</h3>
</a>The <code>ImageStack</code> class represents a stack of images, each with a defined spatial orientation in a common coordinate system. This class can be used to represent CT scans or seismic volumes.
<p>The images are of the type <code>javax.media.jai.PlanarImage</code>; the coordinates are of the type <code>javax.media.jai.Coordinate</code>. The tuple (image, coordinate) is represented by class <code>javax.media.jai.CoordinateImage</code>.
<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.ImageStack
</code>
<hr>
</td>
</table><pre><ul>
<li>ImageStack(Collection images)
<p></ul></pre><dl>
<a name="77806">
<dt><dd> constructs an <code>ImageStack</code> object from a collection of <code>CoordinateImage</code>.
</a><P></dl>
<pre><ul>
<li>ImageJAI getImage(Coordinate coordinate)
<p></ul></pre><dl>
<a name="77808">
<dt><dd> returns the image associated with the specified coordinate.
</a><P></dl>
<pre><ul>
<li>Coordinate getCoordinate(ImageJAI image)
<p></ul></pre><dl>
<a name="77810">
<dt><dd> returns the coordinate associated with the specified image.
</a><P></dl>
<a name="55720">
<h3>4.2.8	<img src="shared/space.gif">Image MIP Map</h3>
</a>An image MIP map is a stack of images with a fixed operational relationship between adjacent slices. Given the highest-resolution slice, the others may be derived in turn by performing a particular operation. Data may be extracted slice by slice or by special iterators.
<p>A MIP map image (<em>MIP</em> stands for the Latin <em>multim im parvo</em>, meaning "many things in a small space") is usually associated with texture mapping. In texture mapping, the MIP map image contains different-sized versions of the same image in one location. To use mipmapping for texture mapping, you provide all sizes of the image in powers of 2 from the largest image to a 1 x 1 map.
<p>The <code>ImageMIPMap</code> class takes the original source image at the highest resolution level, considered to be level 0, and a RenderedOp chain that defines how the image at the next lower resolution level is derived from the current resolution level.
<p>The RenderedOp chain may have multiple operations, but the first operation in the chain must take only one source image, which is the image at the current resolution level.
<p>There are three <code>ImageMIPMap</code> constructors:
<p><pre><ul>
<li>ImageMIPMap(RenderedImage image, AffineTransform transform, 
       Interpolation interpolation)
<p></ul></pre><dl>
<a name="82542">
<dt><dd> This constructor assumes that the operation used to derive the next lower resolution is a standard <em>affine</em> operation.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=3><em>Parameters</em>:
<p><td><code>image</code>
<p><td>The image at the highest resolution level.
<p>
<tr valign=top><td><code>transform</code>
<p><td>The affine transform matrix used by "affine" operation.
<p>
<tr valign=top><td><code>interpolation</code>
<p><td>The interpolation method used by "affine" operation.
<p>

</Table>

</a><P><a name="82627">
<dt><dd> Any number of versions of the original image may be derived by an affine transform representing the geometric relationship between levels of the MIP map. The affine transform may include translation, scaling, and rotation (see <a href="Geom-image-manip.doc.html#51275">"Affine Transformation" on page 272</a>).
</a><P></dl>
<pre><ul>
<li>ImageMIPMap(RenderedImage image, RenderedOp downSampler)
<p></ul></pre><dl>
<a name="82582">
<dt><dd> This constructor specifies the <code>downSampler</code>, which points to the RenderedOp chain used to derive the next lower resolution level.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=2><em>Parameters</em>:
<p><td><code>image</code>
<p><td>The image at the highest resolution level.
<p>
<tr valign=top><td><code>downsampler</code>
<p><td>The RenderedOp chain used to derive the next lower resolution level. The first operation of this chain must take one source, but must not have a source specified.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>ImageMIPMap(RenderedOp downSampler)
<p></ul></pre><dl>
<a name="82622">
<dt><dd> This constructor specifies only the <code>downSampler</code>.<code></code>
</a><P></dl>
The <code>downSampler</code> is a chain of operations used to derive the image at the next lower resolution level from the image at the current resolution level. That is, given an image at resolution level <em>i</em>, the <code>downSampler</code> is used to obtain the image at resolution level <em>i</em> + 1. The chain may contain one or more operation nodes; however, each node must be a <code>RenderedOp</code>.
<p>The <code>downsampler</code> parameter points to the last node in the chain. The very first node in the chain must be a <code>RenderedOp</code> that takes one <code>RenderedImage</code> as its source. All other nodes may have multiple sources. When traversing back up the chain, if a node has more than one source, the first source, <code>source0</code>, is used to move up the chain. This parameter is saved by reference.
<p><a href="Acquisition.doc.html#82858">Listing &#32;4-3</a> shows a complete code example of the use of <code>ImageMIPMap</code>.<p>
<caption><font size=-1><b>
<a name="82858">
<center><font size=-1><b><i>Listing 4-3	</i><img src="shared/sm-blank.gif" border=0> Example use of ImageMIPMap</b></font></center>
</a><p>
</b></font></caption>
<hr>
<tr valign=top><td colspan=1 rowspan=11><pre>     import java.awt.geom.AffineTransform;
     import java.awt.image.RenderedImage;
     import java.awt.image.renderable.ParameterBlock;
     import javax.media.jai.JAI;
     import javax.media.jai.Interpolation;
     import javax.media.jai.InterpolationNearest;
     import javax.media.jai.ImageMIPMap;
     import javax.media.jai.PlanarImage;
     import javax.media.jai.RenderedOp;
     import com.sun.media.jai.codec.FileSeekableStream;
</pre>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top><td colspan=1 rowspan=2><pre>     public class ImageMIPMapTest extends Test {
</pre>
<tr valign=top>
<tr valign=top><td colspan=1 rowspan=2><pre>     protected static String
        file = "/import/jai/JAI_RP/src/share/sample/images/pond.jpg";
</pre>
<tr valign=top>
<tr valign=top><td colspan=1 rowspan=2><pre>     protected Interpolation interp = new InterpolationNearest();
</pre>
<tr valign=top>
<tr valign=top><td colspan=1 rowspan=2><pre>     protected ImageMIPMap MIPMap;
</pre>
<tr valign=top>
<tr valign=top><td colspan=1 rowspan=3><pre>     protected RenderedOp image;
     protected RenderedOp downSampler;
</pre>
<tr valign=top>
<tr valign=top>
<tr valign=top><td colspan=1 rowspan=4><pre>     private void test1() {
     AffineTransform at = new AffineTransform(0.8, 0.0, 0.0, 0.8,
                                              0.0, 0.0);
     InterpolationNearest interp = new InterpolationNearest();
</pre>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top><td colspan=1 rowspan=2><pre>     MIPMap = new ImageMIPMap(image, at, interp);
</pre>
<tr valign=top>
<tr valign=top><td colspan=1 rowspan=5><pre>        display(MIPMap.getDownImage());
        display(MIPMap.getImage(4));
        display(MIPMap.getImage(1));
         }
</pre>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top><td colspan=1 rowspan=5><pre>     public void test2() {
     downSampler = createScaleOp(image, 0.9F);
     downSampler.removeSources();
     downSampler = createScaleOp(downSampler, 0.9F);
</pre>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top><td colspan=1 rowspan=2><pre>     MIPMap = new ImageMIPMap(image, downSampler);
</pre>
<tr valign=top>
<tr valign=top><td colspan=1 rowspan=5><pre>     display(MIPMap.getImage(0));
     display(MIPMap.getImage(5));
     display(MIPMap.getImage(2));
     }
</pre>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top><td colspan=1 rowspan=4><pre>     public void test3() {
         downSampler = createScaleOp(image, 0.9F);
         downSampler = createScaleOp(downSampler, 0.9F);
</pre>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top><td colspan=1 rowspan=2><pre>     MIPMap = new ImageMIPMap(downSampler);
</pre>
<tr valign=top>
<tr valign=top><td colspan=1 rowspan=8><pre>         display(MIPMap.getImage(5));
         System.out.println(MIPMap.getCurrentLevel());
         display(MIPMap.getCurrentImage());
         System.out.println(MIPMap.getCurrentLevel());
         display(MIPMap.getImage(1));
         System.out.println(MIPMap.getCurrentLevel());
     }
</pre>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top><td colspan=1 rowspan=11><pre>     protected RenderedOp createScaleOp(RenderedImage src,
                                        float factor) {
        ParameterBlock pb = new ParameterBlock();
        pb.addSource(src);
        pb.add(factor);
        pb.add(factor);
        pb.add(1.0F);
        pb.add(1.0F);
        pb.add(interp);
        return JAI.create("scale", pb);
     }
</pre>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top><td colspan=1 rowspan=3><pre>     public ImageMIPMapTest(String name) {
            super(name);
</pre>
<tr valign=top>
<tr valign=top>
<tr valign=top><td colspan=1 rowspan=8><pre>        try {
            FileSeekableStream stream = new FileSeekableStream(file);
            image = JAI.create("stream", stream);
        } catch (Exception e) {
            System.exit(0);
        }
     }
</pre>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top><td colspan=1 rowspan=7><pre>     public static void main(String args[]) {
         ImageMIPMapTest test = new ImageMIPMapTest("ImageMIPMap");
         // test.test1();
         // test.test2();
         test.test3();
       }
     }
</pre>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>

<hr>

<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.ImageMIPMap
</code>
<hr>
</td>
</table><pre><ul>
<li>int getCurrentLevel()
<p></ul></pre><dl>
<a name="73960">
<dt><dd> returns the current resolution level. The highest resolution level is defined as level 0.
</a><P></dl>
<pre><ul>
<li>RenderedImage getCurrentImage()
<p></ul></pre><dl>
<a name="73975">
<dt><dd> returns the image at the current resolution level.
</a><P></dl>
<pre><ul>
<li>RenderedImage getImage(int level)
<p></ul></pre><dl>
<a name="73995">
<dt><dd> returns the image at the specified resolution level. The requested level must be greater than or equal to the current resolution level or <code>null</code> will be returned.
</a><P></dl>
<pre><ul>
<li>RenderedImage getDownImage()
<p></ul></pre><dl>
<a name="74020">
<dt><dd> returns the image at the next lower resolution level, obtained by applying the <code>downSampler</code> on the image at the current resolution level.
</a><P></dl>
<a name="54266">
<h3>4.2.9	<img src="shared/space.gif">Image Pyramid</h3>
</a>The <code>ImagePyramid</code> class implements a pyramid operation on a <code>RenderedImage</code>. Supposing that we have a <code>RenderedImage</code> of 1024 x 1024, we could generate ten additional images by successively averaging 2 x 2 pixel blocks, each time discarding every other row and column of pixels. We would be left with images of 512 x 512, 256 x 256, and so on down to 1 x 1.
<p>In practice, the lower-resolution images may be derived by performing any chain of operations to repeatedly down sample the highest-resolution image slice. Similarly, once a lower resolution image slice is obtained, the higher resolution image slices may be derived by performing another chain of operations to repeatedly up sample the lower resolution image slice. Also, a third operation chain may be used to find the difference between the original slice of image and the resulting slice obtained by first down sampling then up sampling the original slice.
<p>This brings us to the discussion of the parameters required of this class:<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="82663">
Parameter
</a><th><a name="82665">
Description
</a>
<tr valign=top><td><a name="82734">
downSampler</a><br><td><a name="82736">
A RenderedOp chain used to derive the lower resolution images. The first operation in the chain must take only one source. See <a href="Acquisition.doc.html#73387">Section &#32;4.2.9.1, "The Down Sampler</a>."</a><br>
<tr valign=top><td><a name="82667">
upSampler</a><br><td><a name="82669">
A RenderedOp chain that derives the image at a resolution level higher than the current level. The first operation in the chain must take only one source. See <a href="Acquisition.doc.html#73446">Section &#32;4.2.9.2, "The Up Sampler</a>."</a><br>
<tr valign=top><td><a name="82671">
differencer</a><br><td><a name="82673">
A RenderedOp chain that finds the difference of two images. The first operation in the chain must take exactly two sources. See <a href="Acquisition.doc.html#73492">Section &#32;4.2.9.3, "The Differencer</a>."</a><br>
<tr valign=top><td><a name="82675">
combiner</a><br><td><a name="82677">
A RenderedOp chain that combines two images. The first operation in the chain must take exactly two sources. See <a href="Acquisition.doc.html#73554">Section &#32;4.2.9.4, "The Combiner</a>."</a><br>

</Table>

<p>Starting with the image at the highest resolution level, to find an image at a lower resolution level we use the <code>downSampler</code>. But, at the same time we also use the <code>upSampler</code> to retrieve the image at the higher resolution level, then use the <code>differencer</code> to find the difference image between the original image and the derived image from the <code>upSampler</code>. We save this difference image for later use.<code></code>
<p>To find an image at a higher resolution, we use the <code>upSampler</code>, then combine the earlier saved difference image with the resulting image using the <code>combiner</code> to get the final higher resolution level.
<p>For example:
<p><dl>
<a name="82691">
<dt><dd> We have an image at level <em>n<br>n</em> + 1 = downSampler(<em>n</em>)<br>diff <em>n</em> = upSampler(<em>n</em> + 1)<br><em>diff n</em> = differencer(<em>n</em>, <em>n</em>') - This diff <em>n</em> is saved for each level<br>Later we want to get <em>n</em> from <em>n</em> + 1<br><em>n</em>' = upSampler(<em>n</em> + 1)<br><em>n</em> = combiner(<em>n</em>', diff <em>n</em>)
</a><P></dl>
<a name="73387">
<h4>4.2.9.1	<img src="shared/space.gif">The Down Sampler</h4>
</a>The <code>downSampler</code> is a chain of operations used to derive the image at the next lower resolution level from the image at the current resolution level. That is, given an image at resolution level <em>i</em>, the <code>downSampler</code> is used to obtain the image at resolution level <em>i</em> + 1. The chain may contain one or more operation nodes; however, each node must be a <code>RenderedOp</code>. The parameter points to the last node in the chain. The very first node in the chain must be a <code>RenderedOp</code> that takes one <code>RenderedImage</code> as its source. All other nodes may have multiple sources. When traversing back up the chain, if a node has more than one source, the first source, <code>source0</code>, is used to move up the chain. This parameter is saved by reference.
<p>The <code>getDownImage</code> method returns the image at the next lower resolution level, obtained by applying the <code>downSampler</code> on the image at the current resolution level.
<p><a name="73446">
<h4>4.2.9.2	<img src="shared/space.gif">The Up Sampler</h4>
</a>The <code>upSampler</code> is a chain of operations used to derive the image at the next higher resolution level from the image at the current resolution level. That is, given an image at resolution level <em>i</em>, the <code>upSampler</code> is used to obtain the image at resolution level <em>i</em> - 1. The requirement for this parameter is similar to the requirement for the <code>downSampler</code> parameter.
<p>The <code>getUpImage</code> method returns the image at the previous higher resolution level. If the current image is already at level 0, the current image is returned without further up sampling. The down-sampled image is obtained by first up sampling the current image, then combining the resulting image with the previously-saved different image using the <code>combiner</code> op chain (see <a href="Acquisition.doc.html#73554">Section &#32;4.2.9.4, "The Combiner</a>").
<p><a name="73492">
<h4>4.2.9.3	<img src="shared/space.gif">The Differencer</h4>
</a>The <code>differencer</code> is a chain of operations used to find the difference between an image at a particular resolution level and the image obtained by first down sampling that image then up sampling the result image of the down sampling operations. The chain may contain one or more operation nodes; however, each node must be a <code>RenderedOp</code>. The parameter points to the last node in the chain. The very first node in the chain must be a <code>RenderedOp</code> that takes two <code>RenderedImage</code>s as its sources. When traversing back up the chain, if a node has more than one source, the first source, <code>source0</code>, is used to move up the chain. This parameter is saved by reference.
<p>The <code>getDiffImage</code> method returns the difference image between the current image and the image obtained by first down sampling the current image then up sampling the resulting image of down sampling. This is done using the <code>differencer</code> op chain. The current level and current image are not changed.
<p><a name="73554">
<h4>4.2.9.4	<img src="shared/space.gif">The Combiner</h4>
</a>The <code>combiner</code> is a chain of operations used to combine the resulting image of the up sampling operations and the different image saved to retrieve an image at a higher resolution level. The requirement for this parameter is similar to the requirement for the <code>differencer</code> parameter.
<p><a name="83181">
<h4>4.2.9.5	<img src="shared/space.gif">Example</h4>
</a><a href="Acquisition.doc.html#83311">Listing &#32;4-4</a> shows a complete code example of the use of <code>ImagePyramid</code>.<p>
<caption><font size=-1><b>
<a name="83311">
<center><font size=-1><b><i>Listing 4-4	</i><img src="shared/sm-blank.gif" border=0> Example use of ImagePyramid</b></font></center>
</a><p>
</b></font></caption>
<hr>
<tr valign=top><td colspan=1 rowspan=10><pre>     import java.awt.image.RenderedImage;
     import java.awt.image.renderable.ParameterBlock;
     import javax.media.jai.JAI;
     import javax.media.jai.Interpolation;
     import javax.media.jai.ImageMIPMap;
     import javax.media.jai.ImagePyramid;
     import javax.media.jai.PlanarImage;
     import javax.media.jai.RenderedOp;
     import com.sun.media.jai.codec.FileSeekableStream;
</pre>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top><td colspan=1 rowspan=2><pre>     public class ImagePyramidTest extends ImageMIPMapTest {
</pre>
<tr valign=top>
<tr valign=top><td colspan=1 rowspan=4><pre>         protected RenderedOp upSampler;
         protected RenderedOp differencer;
         protected RenderedOp combiner;
</pre>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top><td colspan=1 rowspan=2><pre>         protected ImagePyramid pyramid;
</pre>
<tr valign=top>
<tr valign=top><td colspan=1 rowspan=3><pre>         private void test1() {
         }
</pre>
<tr valign=top>
<tr valign=top>
<tr valign=top><td colspan=1 rowspan=5><pre>         public void test2() {
             downSampler = createScaleOp(image, 0.9F);
             downSampler.removeSources();
             downSampler = createScaleOp(downSampler, 0.9F);
</pre>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top><td colspan=1 rowspan=4><pre>             upSampler = createScaleOp(image, 1.2F);
             upSampler.removeSources();
             upSampler = createScaleOp(upSampler, 1.2F);
</pre>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top><td colspan=1 rowspan=3><pre>             differencer = createSubtractOp(image, image);
             differencer.removeSources();
</pre>
<tr valign=top>
<tr valign=top>
<tr valign=top><td colspan=1 rowspan=3><pre>             combiner = createAddOp(image, image);
             combiner.removeSources();
</pre>
<tr valign=top>
<tr valign=top>
<tr valign=top><td colspan=1 rowspan=8><pre>             pyramid = new ImagePyramid(image, downSampler, upSampler,
                                        differencer, combiner);
             display(pyramid.getImage(0));
             display(pyramid.getImage(4));
             display(pyramid.getImage(1));
             display(pyramid.getImage(6));
         }
</pre>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top><td colspan=1 rowspan=4><pre>         public void test3() {
             downSampler = createScaleOp(image, 0.9F);
             downSampler = createScaleOp(downSampler, 0.9F);
</pre>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top><td colspan=1 rowspan=3><pre>             upSampler = createScaleOp(image, 1.2F);
             upSampler.removeSources();
</pre>
<tr valign=top>
<tr valign=top>
<tr valign=top><td colspan=1 rowspan=3><pre>             differencer = createSubtractOp(image, image);
             differencer.removeSources();
</pre>
<tr valign=top>
<tr valign=top>
<tr valign=top><td colspan=1 rowspan=3><pre>             combiner = createAddOp(image, image);
             combiner.removeSources();
</pre>
<tr valign=top>
<tr valign=top>
<tr valign=top><td colspan=1 rowspan=8><pre>             pyramid = new ImagePyramid(downSampler, upSampler,
                                        differencer, combiner);
             // display(pyramid.getCurrentImage());
             display(pyramid.getDownImage());
             // display(pyramid.getDownImage());
             display(pyramid.getUpImage());
         }
</pre>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top><td colspan=1 rowspan=3><pre>         public void test4() {
             downSampler = createScaleOp(image, 0.5F);
</pre>
<tr valign=top>
<tr valign=top>
<tr valign=top><td colspan=1 rowspan=3><pre>             upSampler = createScaleOp(image, 2.0F);
             upSampler.removeSources();
</pre>
<tr valign=top>
<tr valign=top>
<tr valign=top><td colspan=1 rowspan=3><pre>             differencer = createSubtractOp(image, image);
             differencer.removeSources();
</pre>
<tr valign=top>
<tr valign=top>
<tr valign=top><td colspan=1 rowspan=3><pre>             combiner = createAddOp(image, image);
             combiner.removeSources();
</pre>
<tr valign=top>
<tr valign=top>
<tr valign=top><td colspan=1 rowspan=4><pre>             pyramid = new ImagePyramid(downSampler, upSampler,
                                        differencer, combiner);
             pyramid.getDownImage();
</pre>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top><td colspan=1 rowspan=5><pre>             display(pyramid.getCurrentImage());
             display(pyramid.getDiffImage());
             display(pyramid.getCurrentImage());
         }
</pre>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top><td colspan=1 rowspan=8><pre>         protected RenderedOp createSubtractOp(RenderedImage src1,
                                               RenderedImage src2) {
             ParameterBlock pb = new ParameterBlock();
             pb.addSource(src1);
             pb.addSource(src2);
             return JAI.create("subtract", pb);
         }
</pre>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top><td colspan=1 rowspan=8><pre>         protected RenderedOp createAddOp(RenderedImage src1,
                                          RenderedImage src2) {
             ParameterBlock pb = new ParameterBlock();
             pb.addSource(src1);
             pb.addSource(src2);
             return JAI.create("add", pb);
         }
</pre>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top><td colspan=1 rowspan=4><pre>         public ImagePyramidTest(String name) {
             super(name);
         }
</pre>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top><td colspan=1 rowspan=7><pre>         public static void main(String args[]) {
             ImagePyramidTest test = new 
ImagePyramidTest("ImagePyramid");
             // test.test2();
             test.test3();
             // test.test4();
         }
     }
</pre>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>

<hr>

<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.ImagePyramid
</code>
<hr>
</td>
</table><pre><ul>
<li>ImagePyramid(RenderedImage image, RenderedOp downsampler, 
       RenderedOp upSampler, RenderedOp differencer, 
       RenderedOp &#32;combiner)
<p></ul></pre><dl>
<a name="54312">
<dt><dd> constructs an <code>ImagePyramid</code> object. The parameters point to the last operation in each chain. The first operation in each chain must not have any source images specified; that is, its number of sources must be 0.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=5><em>Parameters</em>:
<p><td><code>image</code>
<p><td>The image with the highest resolution.
<p>
<tr valign=top><td><code>downsampler</code>
<p><td>The operation chain used to derive the lower-resolution images.
<p>
<tr valign=top><td><code>upsampler</code>
<p><td>The operation chain used to derive the higher-resolution images.
<p>
<tr valign=top><td><code>differencer</code>
<p><td>The operation chain used to differ two images.
<p>
<tr valign=top><td><code>combiner</code>
<p><td>The operation chain used to combine two images.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>ImagePyramid(RenderedOp downSampler, RenderedOp upSampler, 
       RenderedOp differencer, RenderedOp combiner)
<p></ul></pre><dl>
<a name="73631">
<dt><dd> constructs an <code>ImagePyramid</code> object. The <code>RenderedOp</code> parameters point to the last operation node in each chain. The first operation in the <code>downSampler</code> chain must have the image with the highest resolution as its source. The first operation in all other chains must not have any source images specified; that is, its number of sources must be 0. All input parameters are saved by reference.
</a><P></dl>
<pre><ul>
<li>public RenderedImage getImage(int level)
<p></ul></pre><dl>
<a name="72499">
<dt><dd> returns the image at the specified resolution level. The requested level must be greater than or equal to 0 or null will be returned. The image is obtained by either down sampling or up sampling the current image.
</a><P></dl>
<pre><ul>
<li>public RenderedImage getDownImage()
<p></ul></pre><dl>
<a name="73681">
<dt><dd> returns the image at the next lower resolution level, obtained by applying the <code>downSampler</code> on the image at the current resolution level.
</a><P></dl>
<pre><ul>
<li>public RenderedImage getUpImage()
<p></ul></pre><dl>
<a name="73705">
<dt><dd> returns the image at the previous higher resolution level. If the current image is already at level 0, the current image is returned without further up sampling. The image is obtained by first up sampling the current image, then combining the result image with the previously saved different image using the <code>combiner</code> op chain.
</a><P></dl>
<pre><ul>
<li>public RenderedImage getDiffImage()
<p></ul></pre><dl>
<a name="72542">
<dt><dd> returns the difference image between the current image and the image obtained by first down sampling the current image then up sampling the result image of down sampling. This is done using the <code>differencer</code> op chain. The current level and current image will not be changed.
</a><P></dl>
<a name="80612">
<h3>4.2.10	<img src="shared/space.gif">Multi-resolution Renderable Images</h3>
</a>The <code>MultiResolutionRenderableImage</code> class produces renderings based on a set of supplied <code>RenderedImages</code> at various resolutions. The <code>MultiResolutionRenderableImage</code> is constructed from a specified dimension (height; the width is derived by the source image aspect ratio and is not specified) and a vector of renderedImages of progressively lower resolution. 
<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.MultiResolutionRenderableImage
</code>
<hr>
</td>
</table><pre><ul>
<li>public MultiResolutionRenderableImage(Vector renderedSources, 
       float minX, float minY, float height)
<p></ul></pre><dl>
<a name="80658">
<dt><dd> constructs a <code>MultiResolutionRenderableImage</code> with given dimensions from a <code>Vector</code> of progressively lower resolution versions of a RenderedImage.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=4><em>Parameters</em>:<em></em>
<p><td><code>rendered-Sources</code>
<p><td>A <code>Vector</code> of <code>RenderedImages</code>.
<p>
<tr valign=top><td><code>minX</code>
<p><td>The minimum <em>x</em> coordinate of the Renderable, as a float.
<p>
<tr valign=top><td><code>minY</code>
<p><td>The minimum <em>y</em> coordinate of the Renderable, as a float.
<p>
<tr valign=top><td><code>height</code>
<p><td>The height of the Renderable, as a float.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>RenderedImage createScaledRendering(int width, int height, 
       RenderingHints hints)
<p></ul></pre><dl>
<a name="80916">
<dt><dd> returns a rendering with a given width, height, and rendering hints. If a JAI rendering hint named <code>JAI.KEY_INTERPOLATION</code> is provided, its corresponding <code>Interpolation</code> object is used as an argument to the JAI operator used to scale the image. If no such hint is present, an instance of <code>InterpolationNearest</code> is used.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=3><em>Parameters</em>:
<p><td><code>width</code>
<p><td>The width of the rendering in pixels.
<p>
<tr valign=top><td><code>height</code>
<p><td>The height of the rendering in pixels.
<p>
<tr valign=top><td><code>hints</code>
<p><td>A <code>Hashtable</code> of rendering hints.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>RenderedImage createDefaultRendering()
<p></ul></pre><dl>
<a name="81002">
<dt><dd> returns a 100-pixel high rendering with no rendering hints.
</a><P></dl>
<pre><ul>
<li>RenderedImage createRendering(RenderContext renderContext)
<p></ul></pre><dl>
<a name="81016">
<dt><dd> returns a rendering based on a <code>RenderContext</code>. If a JAI rendering hint named <code>JAI.KEY_INTERPOLATION</code> is provided, its corresponding <code>Interpolation</code> object is used as an argument to the JAI operator used to scale the image. If no such hint is present, an instance of <code>InterpolationNearest</code> is used.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td><em>Parameters</em>:
<p><td><code>render-Context</code>
<p><td>A <code>RenderContext</code> describing the transform and rendering hints.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>Object getProperty(String name)
<p></ul></pre><dl>
<a name="80736">
<dt><dd> gets a property from the property set of this image. If the property name is not recognized, <code>java.awt.Image.UndefinedProperty</code> will be returned.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td><em>Parameters</em>:
<p><td><code>name</code>
<p><td>The name of the property to get, as a String.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>String[] getPropertyNames()
<p></ul></pre><dl>
<a name="80776">
<dt><dd> returns a list of the properties recognized by this image.
</a><P></dl>
<pre><ul>
<li>float getWidth()
<p></ul></pre><dl>
<a name="80790">
<dt><dd> returns the floating-point width of the <code>RenderableImage</code>.
</a><P></dl>
<pre><ul>
<li>float getHeight()
<p></ul></pre><dl>
<a name="80804">
<dt><dd> returns the floating-point height of the <code>RenderableImage</code>.
</a><P></dl>
<pre><ul>
<li>float getMinX()
<p></ul></pre><dl>
<a name="80820">
<dt><dd> returns the floating-point minimum <em>x</em> coordinate of the <code>RenderableImage</code>.
</a><P></dl>
<pre><ul>
<li>float getMaxX()
<p></ul></pre><dl>
<a name="80843">
<dt><dd> returns the floating-point maximum <em>x</em> coordinate of the <code>RenderableImage</code>.
</a><P></dl>
<pre><ul>
<li>float getMinY()
<p></ul></pre><dl>
<a name="80866">
<dt><dd> returns the floating-point minimum <em>y</em> coordinate of the <code>RenderableImage</code>.
</a><P></dl>
<pre><ul>
<li>float getMaxY()
<p></ul></pre><dl>
<a name="80885">
<dt><dd> returns the floating-point maximum <em>y</em> coordinate of the <code>RenderableImage</code>.
</a><P></dl>
<a name="80641">
<h2>4.3	<img src="shared/space.gif">Streams</h2>
</a>The Java Advanced Imaging API extends the Java family of stream types with the addition of seven "seekable" stream classes, as shown in <a href="Acquisition.doc.html#68036">Figure &#32;4-4</a>. <a href="Acquisition.doc.html#68242">Table &#32;4-3</a> briefly describes each of the new classes.
<p><a name="68035">
 <hr>
<center><img src="Acquisition.doc.anc1.gif"></center><hr>

</a>
<a name="68036">
<center><font size=-1><b><i>Figure 4-4	</i><img src="shared/sm-blank.gif" border=0> JAI Stream Classes</b></font></center>
</a><p>
The new seekable classes are used to cache the image data being read so that methods can be used to seek backwards and forwards through the data without having to re-read the data. This is especially important for image data types that are segmented or that cannot be easily re-read to locate important information.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b><a name="68242">
<i>Table 4-3	 </i><img src="shared/sm-blank.gif" border=0> JAI Stream Classes &#32;
</a></b></font></caption>
<tr valign=top><th><a name="68246">
Class
</a><th><a name="68248">
Description
</a>
<tr valign=top><td><a name="68250">
SeekableStream</a><br><td><a name="68252">
Extends: InputStream</a><br><a name="68289">
Implements: DataInput</a><br><a name="68288">
An abstract class that combines the functionality of InputStream and RandomAccessFile, along with the ability to read primitive data types in little-endian format.</a><br>
<tr valign=top><td><a name="68254">
FileSeekableStream</a><br><td><a name="70829">
Extends: SeekableStream</a><br><a name="70830">
Implements SeekableStream functionality on data stored in a File.</a><br>
<tr valign=top><td><a name="68258">
ByteArraySeekableStream</a><br><td><a name="68333">
Extends: SeekableStream</a><br><a name="70792">
Implements SeekableStream functionality on data stored in an array of bytes.</a><br>
<tr valign=top><td><a name="68262">
SegmentedSeekableStream</a><br><td><a name="68380">
Extends: SeekableStream</a><br><a name="68371">
Provides a view of a subset of another SeekableStream consisting of a series of segments with given starting positions in the source stream and lengths. The resulting stream behaves like an ordinary SeekableStream.</a><br>
<tr valign=top><td><a name="68266">
ForwardSeekableStream</a><br><td><a name="68388">
Extends: SeekableStream</a><br><a name="70836">
Provides SeekableStream functionality on data from an InputStream with minimal overhead, but does not allow seeking backwards. ForwardSeekableStream may be used with input formats that support streaming, avoiding the need to cache the input data.</a><br>
<tr valign=top><td><a name="68270">
FileCacheSeekableStream</a><br><td><a name="68410">
Extends: SeekableStream</a><br><a name="70856">
Provides SeekableStream functionality on data from an InputStream with minimal overhead, but does not allow seeking backwards. ForwardSeekableStream may be used with input formats that support streaming, avoiding the need to cache the input data. In circumstances that do not allow the creation of a temporary file (for example, due to security consideration or the absence of local disk), the MemoryCacheSeekableStream class may be used.</a><br>
<tr valign=top><td><a name="68274">
MemoryCacheSeekableStream</a><br><td><a name="68452">
Extends: SeekableStream</a><br><a name="70876">
Provides SeekableStream functionality on data from an InputStream, using an in-memory cache to allow seeking backwards. MemoryCacheSeekableStream should be used when security or lack of access to local disk precludes the use of FileCacheSeekableStream.</a><br>

</Table>

<p>To properly read some image data files requires the ability to seek forward and backward through the data so as to read information that describes the image. The best way of making the data seekable is through a <em>cache</em>, a temporary file stored on a local disk or in main memory. The preferred method of storage for the cached data is local disk, but that it not always possible. For security concerns or for diskless systems, the creation of a disk file cache may not always be permitted. When a file cache is not permissible, an in-memory cache may be used.
<p>The <code>SeekableStream</code> class allows seeking within the input, similarly to the <code>RandomAccessFile</code> class. Additionally, the <code>DataInput</code> interface is supported and extended to include support for little-endian representations of fundamental data types.
<p>The <code>SeekableStream</code> class adds several <code>read</code> methods to the already extensive java.io.<code>DataInput</code> class, including methods for reading data in little-endian (LE) order. In Java, all values are written in big-endian fashion. However, JAI needs methods for reading data that is not produced by Java; data that is produced on other platforms that produce data in the little-endian fashion. <a href="Acquisition.doc.html#68920">Table &#32;4-4</a> is a complete list of the methods to read data:<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b><a name="68920">
<i>Table 4-4	 </i><img src="shared/sm-blank.gif" border=0> Read Data Methods &#32;
</a></b></font></caption>
<tr valign=top><th><a name="68924">
Method
</a><th><a name="68926">
Description
</a>
<tr valign=top><td><a name="68638">
readInt</a><br><td><a name="68640">
Reads a signed 32-bit integer</a><br>
<tr valign=top><td><a name="68642">
readIntLE</a><br><td><a name="68644">
Reads a signed 32-bit integer in little-endian order</a><br>
<tr valign=top><td><a name="68646">
readShort</a><br><td><a name="68648">
Reads a signed 16-bit number</a><br>
<tr valign=top><td><a name="68650">
readShortLE</a><br><td><a name="68652">
Reads a 16-bit number in little-endian order</a><br>
<tr valign=top><td><a name="68654">
readLong</a><br><td><a name="68656">
Reads a signed 64-bit integer</a><br>
<tr valign=top><td><a name="68658">
readLongLE</a><br><td><a name="68660">
Reads a signed 64-bit integer in little-endian order</a><br>
<tr valign=top><td><a name="68662">
readFloat</a><br><td><a name="68664">
Reads a 32-bit float</a><br>
<tr valign=top><td><a name="68666">
readFloatLE</a><br><td><a name="68668">
Reads a 32-bit float in little-endian order</a><br>
<tr valign=top><td><a name="68670">
readDouble</a><br><td><a name="68672">
Reads a 64-bit double</a><br>
<tr valign=top><td><a name="68674">
readDoubleLE</a><br><td><a name="68676">
Reads a 64-bit double in little-endian order</a><br>
<tr valign=top><td><a name="68714">
readChar</a><br><td><a name="68712">
Reads a 16-bit Unicode character</a><br>
<tr valign=top><td><a name="68716">
readCharLE</a><br><td><a name="68708">
Reads a 16-bit Unicode character in little-endian order</a><br>
<tr valign=top><td><a name="68812">
readByte</a><br><td><a name="68814">
Reads an signed 8-bit byte</a><br>
<tr valign=top><td><a name="68718">
readBoolean</a><br><td><a name="68704">
Reads a Boolean value</a><br>
<tr valign=top><td><a name="68720">
readUTF</a><br><td><a name="68700">
Reads a string of characters in UTF (Unicode Text Format)</a><br>
<tr valign=top><td><a name="68722">
readUnsignedShort</a><br><td><a name="68696">
Reads an unsigned 16-bit short integer</a><br>
<tr valign=top><td><a name="68724">
readUnsignedShortLE</a><br><td><a name="68692">
Reads an unsigned 16-bit short integer in little-endian order</a><br>
<tr valign=top><td><a name="68726">
readUnsignedInt</a><br><td><a name="68688">
Reads an unsigned 32-bit integer</a><br>
<tr valign=top><td><a name="68728">
readUnsignedIntLE</a><br><td><a name="68684">
Reads an unsigned 32-bit integer in little-endian order</a><br>
<tr valign=top><td><a name="68730">
readUnsignedByte</a><br><td><a name="68680">
Reads an unsigned 8-bit byte</a><br>
<tr valign=top><td><a name="68830">
readLine</a><br><td><a name="68832">
Reads in a line that has been terminated by a line-termination character.</a><br>
<tr valign=top><td><a name="68838">
readFully</a><br><td><a name="68840">
Reads a specified number of bytes, starting at the current stream pointer</a><br>
<tr valign=top><td><a name="68842">
read()</a><br><td><a name="68844">
Reads the next byte of data from the input stream.</a><br>

</Table>

<p>In addition to the familiar methods from <code>InputStream</code>, the methods <code>getFilePointer</code>() and <code>seek()</code>, are defined as in the <code>RandomAccessFile</code> class. The <code>canSeekBackwards()</code> method returns <code>true</code> if it is permissible to seek to a position earlier in the stream than the current value of <code>getFilePointer()</code>. Some subclasses of <code>SeekableStream</code> guarantee the ability to seek backwards while others may not offer this feature in the interest of efficiency for those users who do not require backward seeking.
<p>Several concrete subclasses of <code>SeekableStream</code> are supplied in the <code>com.sun.media.jai.codec</code> package. Three classes are provided for the purpose of adapting a standard <code>InputStream</code> to the <code>SeekableStream</code> interface. The <code>ForwardSeekableStream</code> class does not allow seeking backwards, but is inexpensive to use. The <code>FileCacheSeekableStream</code> class maintains a copy of all of the data read from the input in a temporary file; this file will be discarded automatically when the <code>FileSeekableStream</code> is finalized, or when the JVM exits normally.
<p>The <code>FileCacheSeekableStream</code> class is intended to be reasonably efficient apart from the unavoidable use of disk space. In circumstances where the creation of a temporary file is not possible, the <code>MemoryCacheSeekableStream</code> class may be used. The <code>MemoryCacheSeekableStream</code> class creates a potentially large in-memory buffer to store the stream data and so should be avoided when possible. The <code>FileSeekableStream</code> class wraps a <code>File</code> or <code>RandomAccessFile</code>. It forwards requests to the real underlying file. <code>FileSeekableStream</code> performs a limited amount of caching to avoid excessive I/O costs.
<p>A convenience method, <code>wrapInputStream</code> is provided to construct a suitable <code>SeekableStream</code> instance whose data is supplied by a given <code>InputStream</code>. The caller, by means of the <code>canSeekBackwards</code> parameter, determines whether support for seeking backwards is required.
<p><a name="74172">
<h2>4.4	<img src="shared/space.gif">Reading Image Files</h2>
</a>The JAI codec architecture consists of encoders and decoders capable of writing and reading several different raster image file formats. This chapter describes reading image files. For information on writing image files, see <a href="Encode.doc.html#47285">Chapter &#32;13, "Writing Image Files</a>."
<p>There are many raster image file formats, most of which have been created to support both image storage and interchange. Some formats have become widely used and are considered de facto standards. Other formats, although very important to individual software vendors, are less widely used.
<p>JAI directly supports several of the most common image file formats, listed in <a href="Acquisition.doc.html#74215">Table &#32;4-5</a>. If your favorite file format is not listed in <a href="Acquisition.doc.html#74215">Table &#32;4-5</a>, you may either be able to create your own file codec (see <a href="Extension.doc.html#47285">Chapter &#32;14, "Extending the API</a>") or use one obtained from a third party developer.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b><a name="74215">
<i>Table 4-5	 </i><img src="shared/sm-blank.gif" border=0> Image File Formats &#32;
</a></b></font></caption>
<tr valign=top><th><a name="74219">
File Format Name
</a><th><a name="74221">
Description
</a>
<tr valign=top><td><a name="74223">
BMP</a><br><td><a name="74225">
Microsoft Windows bitmap image file</a><br>
<tr valign=top><td><a name="74227">
FPX</a><br><td><a name="74229">
FlashPix format</a><br>
<tr valign=top><td><a name="74231">
GIF</a><br><td><a name="74233">
Compuserve's Graphics Interchange Format</a><br>
<tr valign=top><td><a name="74239">
JPEG</a><br><td><a name="74241">
A file format developed by the Joint Photographic Experts Group</a><br>
<tr valign=top><td><a name="74243">
PNG</a><br><td><a name="74245">
Portable Network Graphics</a><br>
<tr valign=top><td><a name="74247">
PNM</a><br><td><a name="74249">
Portable aNy Map file format. Includes PBM, PGM, and PPM.</a><br>
<tr valign=top><td><a name="74251">
TIFF</a><br><td><a name="74253">
Tag Image File Format</a><br>

</Table>

<p>An image file usually has at least two parts: a file header and the image data. The header contains fields of pertinent information regarding the following image data. At the very least, the header must provide all the information necessary to reconstruct the original image from the stored image data. The image data itself may or may not be compressed.
<p>The main class for image decoders and encoders is the <code>ImageCodec</code> class. Subclasses of <code>ImageCodec</code> are able to perform recognition of a particular file format either by inspection of a fixed-length file header or by arbitrary access to the source data stream. Each <code>ImageCodec</code> subclass implements one of two image file recognition methods. The codec first calls the <code>getNumHeaderBytes()</code> method, which either returns 0 if arbitrary access to the stream is required, or returns the number of header bytes required to recognize the format. Depending on the outcome of the <code>getNumHeaderBytes()</code> method, the codec either reads the stream or the header.
<p>Once the codec has determined the image format, either by reading the stream or the header, it returns the name of the codec associated with the detected image format. If no codec is registered with the name, <code>null</code> is returned. The name of the codec defines the subclass that is called, which decodes the image.
<p>For most image types, JAI offers the option of reading an image data file as a <code>java.io.File</code> object or as one of the subclasses of <code>java.io.InputStream</code>.
<p>JAI offers several file operators for reading image data files, as listed in <a href="Acquisition.doc.html#66297">Table &#32;4-6</a>.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b><a name="66297">
<i>Table 4-6	 </i><img src="shared/sm-blank.gif" border=0> Image File Operators &#32;
</a></b></font></caption>
<tr valign=top><th><a name="66431">
Operator
</a><th><a name="66433">
Description
</a>
<tr valign=top><td><a name="66365">
AWTImage</a><br><td><a name="66367">
Imports a standard AWT image into JAI.</a><br>
<tr valign=top><td><a name="66369">
BMP</a><br><td><a name="66371">
Reads BMP data from an input stream.</a><br>
<tr valign=top><td><a name="69735">
FileLoad</a><br><td><a name="69739">
Reads an image from a file.</a><br>
<tr valign=top><td><a name="66381">
FPX</a><br><td><a name="66383">
Reads FlashPix data from an input stream.</a><br>
<tr valign=top><td><a name="66385">
FPXFile</a><br><td><a name="66387">
Reads a standard FlashPix file.</a><br>
<tr valign=top><td><a name="66389">
GIF</a><br><td><a name="66391">
Reads GIF data from an input stream.</a><br>
<tr valign=top><td><a name="66401">
JPEG</a><br><td><a name="66403">
Reads a standard JPEG (JFIF) file.</a><br>
<tr valign=top><td><a name="66405">
PNG</a><br><td><a name="66407">
Reads a PNG input stream.</a><br>
<tr valign=top><td><a name="66409">
PNM</a><br><td><a name="66411">
Reads a standard PNM file, including PBM, PGM, and PPM images of both ASCII and raw formats.</a><br>
<tr valign=top><td><a name="66413">
Stream</a><br><td><a name="66415">
Reads java.io.InputStream files.</a><br>
<tr valign=top><td><a name="66417">
TIFF</a><br><td><a name="66419">
Reads TIFF 6.0 data from an input stream.</a><br>
<tr valign=top><td><a name="71514">
URL</a><br><td><a name="71518">
Creates an image the source of which is specified by a Uniform Resource Locator (URL).</a><br>

</Table>

<p><a name="65553">
<h3>4.4.1	<img src="shared/space.gif">Standard File Readers for Most Data Types</h3>
</a>You can read a file type directly with one of the available operation descriptors (such as the <code>tiff</code> operation to read TIFF files), by the stream file reader to read <code>InputStream</code> files, or the <code>FileLoad</code> operator to read from a disk file. The <code>Stream</code> and <code>FileLoad</code> operations are generic file readers in the sense that the image file type does not have to be known ahead of time, assuming that the file type is one of those recognized by JAI. These file read operations automatically detect the file type when invoked and use the appropriate file reader. This means that the programmer can use the same graph to read any of the "recognized" file types.
<p>The <code>Stream</code> and <code>FileLoad</code> operations use a set of <code>FormatRecognizer</code> classes to query the file types when the image data is called for. A <code>FormatRecognizer</code> may be provided for any format that may be definitively recognized by examining the initial portion of the data stream. A new <code>FormatRecognizer</code> may be added to the <code>OperationRegistry</code> by means of the <code>registerFormatRecognizer</code> method (see <a href="Extension.doc.html#56033">Section &#32;14.5, "Writing New Image Decoders and Encoders</a>").
<p><a name="69929">
<h4>4.4.1.1	<img src="shared/space.gif">The Stream Operation</h4>
</a>The <code>Stream</code> operation reads an image from a <code>SeekableStream</code>. If the file is one of the recognized "types," the file will be read. The <code>file</code> operation will query the set of registered <code>FormatRecognizer</code>s. If a call to the <code>isFormatRecognized</code> method returns true, the associated operation name is retrieved by calling the <code>getOperationName</code> method and the named operation is instantiated.
<p>If the operation fails to read the file, no other operation will be invoked since the input will have been consumed.
<p>The <code>Stream</code> operation takes a single parameter:<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="65589">
Parameter
</a><th><a name="65591">
Type
</a><th><a name="65593">
Description
</a>
<tr valign=top><td><a name="65595">
stream</a><br><td><a name="65597">
SeekableStream</a><br><td><a name="65599">
The SeekableStream to read from.</a><br>

</Table>

<p><a href="Acquisition.doc.html#79311">Listing &#32;4-5</a> shows a code sample for a <code>Stream</code> operation.<p>
<caption><font size=-1><b>
<a name="79311">
<center><font size=-1><b><i>Listing 4-5	</i><img src="shared/sm-blank.gif" border=0> Example Stream Operation</b></font></center>
</a><p>
</b></font></caption>
<hr>
<tr valign=top><td><pre>     // Load the source image from a Stream.
     RenderedImage im = JAI.create("stream", stream);
</pre>

<hr>
<code></code>
<p><a name="69930">
<h4>4.4.1.2	<img src="shared/space.gif">The FileLoad Operation</h4>
</a>The FileLoad operation reads an image from a file. Like the <code>Stream</code> operation, if the file is one of the recognized "types," the file will be read. If the operation fails to read the file, no other operation will be invoked since the input will have been consumed.
<p>The <code>FileLoad</code> operation takes a single parameter:<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="69974">
Parameter
</a><th><a name="69976">
Type
</a><th><a name="69978">
Description
</a>
<tr valign=top><td><a name="69980">
filename</a><br><td><a name="69982">
String</a><br><td><a name="69984">
The path of the file to read from.</a><br>

</Table>

<p><a href="Acquisition.doc.html#79334">Listing &#32;4-6</a> shows a code sample for a <code>FileLoad</code> operation.<p>
<caption><font size=-1><b>
<a name="79334">
<center><font size=-1><b><i>Listing 4-6	</i><img src="shared/sm-blank.gif" border=0> Example FileLoad Operation</b></font></center>
</a><p>
</b></font></caption>
<hr>
<tr valign=top><td><pre>     // Load the source image from a file.
     RenderedImage src = (RenderedImage)JAI.create("fileload",
                          fileName);
</pre>

<hr>

<p><a name="61287">
<h3>4.4.2	<img src="shared/space.gif">Reading TIFF Images</h3>
</a>The Tag Image File Format (TIFF) is one of the most common digital image file formats. This file format was specifically designed for large arrays of raster image data originating from many sources, including scanners and video frame grabbers. TIFF was also designed to be portable across several different computer platforms, including UNIX, Windows, and Macintosh. The TIFF file format is highly flexible, which also makes it fairly complex.
<p>The <code>TIFF</code> operation reads TIFF data from a TIFF <code>SeekableStream</code>. The <code>TIFF</code> operation takes one parameter:<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="65154">
Parameter
</a><th><a name="65156">
Type
</a><th><a name="65158">
Description
</a>
<tr valign=top><td><a name="65160">
file</a><br><td><a name="65162">
SeekableStream</a><br><td><a name="65164">
The SeekableStream to read from.</a><br>

</Table>

<p>The <code>TIFF</code> operation reads the following TIFF image types:
<p><ul>
<li>Bilevel or grayscale, white is zero<p></ul><ul>
<li>Bilevel or grayscale, black is zero<p></ul><ul>
<li>Palette-color images<p></ul><ul>
<li>RGB full color (three samples per pixel)<p></ul><ul>
<li>RGB full color (four samples per pixel) (Opacity + RGB)<p></ul><ul>
<li>RGB full color with alpha data<p></ul><ul>
<li>RGB full color with alpha data (with pre-multiplied color)<p></ul><ul>
<li>RGB full color with extra components<p></ul><ul>
<li>Transparency mask<p></ul>The <code>TIFF</code> operation supports the following compression types:
<p><ul>
<li>None (no compression)<p></ul><ul>
<li>PackBits compression<p></ul><ul>
<li>Modified Huffman compression (CCITT Group3 1-dimensional facsimile)<p></ul>For an example of reading a TIFF file, see <a href="Examples.doc.html#73865">Listing &#32;A-1 on page 417</a>.
<p><a name="76748">
<h4>4.4.2.1	<img src="shared/space.gif">Palette Color Images</h4>
</a>For TIFF Palette color images, the <code>colorMap</code> always has entries of short data type, the color black being represented by 0,0,0 and white by 65536,65536,65536. To display these images, the default behavior is to dither the short values down to 8 bits. The dithering is done by calling the <code>decode16BitsTo8Bit</code> method for each short value that needs to be dithered. The method has the following implementation:
<p><pre>     byte b;
     short s;
     s = s &amp; 0xffff;
     b = (byte)((s &gt;&gt; 8) &amp; 0xff);
</pre>If a different algorithm is to be used for the dithering, the <code>TIFFDecodeParam</code> class should be subclassed and an appropriate implementation should be provided for the <code>decode16BitsTo8Bits</code> method in the subclass.
<p>If it is desired that the Palette be decoded such that the output image is of short data type and no dithering is performed, use the <code>setDecodePaletteAsShorts</code> method.
<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>com.sun.media.jai.codec.TIFFDecodeParam
</code>
<hr>
</td>
</table><pre><ul>
<li>void setDecodePaletteAsShorts(boolean decodePaletteAsShorts)
<p></ul></pre><dl>
<a name="76063">
<dt><dd> if set, the entries in the palette will be decoded as shorts and no short-to-byte lookup will be applied to them.
</a><P></dl>
<pre><ul>
<li>boolean getDecodePaletteAsShorts()
<p></ul></pre><dl>
<a name="76084">
<dt><dd> returns <code>true</code> if palette entries will be decoded as shorts, resulting in a output image with short datatype.
</a><P></dl>
<pre><ul>
<li>byte decode16BitsTo8Bits(int s)
<p></ul></pre><dl>
<a name="76101">
<dt><dd> returns an unsigned 8-bit value computed by dithering the unsigned 16-bit value. Note that the TIFF specified short datatype is an unsigned value, while Java's <code>short</code> datatype is a signed value. Therefore the Java <code>short</code> datatype cannot be used to store the TIFF specified short value. A Java <code>int</code> is used as input instead to this method. The method deals correctly only with 16-bit unsigned values.
</a><P></dl>
<a name="76932">
<h4>4.4.2.2	<img src="shared/space.gif">Multiple Images per TIFF File</h4>
</a>A TIFF file may contain more than one Image File Directory (IFD). Each IFD defines a <em>subfile</em>, which may be used to describe related images. To determine the number of images in a TIFF file, use the <code>TIFFDirectory.getNumDirectories()</code> method.
<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>com.sun.media.jai.codec.TIFFDirectory
</code>
<hr>
</td>
</table><pre><ul>
<li>static int getNumDirectories(SeekableStream stream)
<p></ul></pre><dl>
<a name="76970">
<dt><dd> returns the number of image directories (subimages) stored in a given TIFF file, represented by a <code>SeekableStream</code>.
</a><P></dl>
<a name="76135">
<h4>4.4.2.3	<img src="shared/space.gif">Image File Directory (IFD)</h4>
</a>The <code>TIFFDirectory</code> class represents an Image File Directory (IFD) from a TIFF 6.0 stream. The IFD consists of a count of the number of directories (number of fields), followed by a sequence of field entries identified by a tag that identifies the field. A field is identified as a sequence of values of identical data type. The TIFF 6.0 specification defines 12 data types, which are mapped internally into the Java data types, as described in <a href="Acquisition.doc.html#76720">Table &#32;4-7</a>.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b><a name="76720">
<i>Table 4-7	 </i><img src="shared/sm-blank.gif" border=0> TIFF Data Types
</a></b></font></caption>
<tr valign=top><th><a name="76564">
TIFF Field Type
</a><th><a name="76566">
Java Data Type
</a><th><a name="76619">
Description
</a>
<tr valign=top><td><a name="76568">
TIFF_BYTE</a><br><td><a name="76570">
byte</a><br><td><a name="76621">
8-bit unsigned integer</a><br>
<tr valign=top><td><a name="76572">
TIFF_ASCII</a><br><td><a name="76574">
String</a><br><td><a name="76623">
Null-terminated ASCII strings.</a><br>
<tr valign=top><td><a name="76576">
TIFF_SHORT</a><br><td><a name="76578">
char</a><br><td><a name="76625">
16-bit unsigned integers.</a><br>
<tr valign=top><td><a name="76580">
TIFF_LONG</a><br><td><a name="76582">
long</a><br><td><a name="76627">
32-bit unsigned integers.</a><br>
<tr valign=top><td><a name="76584">
TIFF_RATIONAL</a><br><td><a name="76586">
long[2]</a><br><td><a name="76629">
Pairs of 32-bit unsigned integers.</a><br>
<tr valign=top><td><a name="76588">
TIFF_SBYTE</a><br><td><a name="76590">
byte</a><br><td><a name="76631">
8-bit signed integers.</a><br>
<tr valign=top><td><a name="76592">
TIFF_UNDEFINED</a><br><td><a name="76594">
byte</a><br><td><a name="76633">
16-bit signed integers.</a><br>
<tr valign=top><td><a name="76596">
TIFF_SSHORT</a><br><td><a name="76598">
short</a><br><td><a name="76635">
1-bit signed integers.</a><br>
<tr valign=top><td><a name="76600">
TIFF_SLONG</a><br><td><a name="76602">
int</a><br><td><a name="76637">
32-bit signed integers.</a><br>
<tr valign=top><td><a name="76604">
TIFF_SRATIONAL</a><br><td><a name="76606">
int[2]</a><br><td><a name="76639">
Pairs of 32-bit signed integers.</a><br>
<tr valign=top><td><a name="76608">
TIFF_FLOAT</a><br><td><a name="76610">
float</a><br><td><a name="76641">
32-bit IEEE floats.</a><br>
<tr valign=top><td><a name="76612">
TIFF_DOUBLE</a><br><td><a name="76614">
double</a><br><td><a name="76643">
64-bit IEEE doubles.</a><br>

</Table>

<p>The <code>TIFFField</code> class contains several methods to query the set of tags and to obtain the raw field array. In addition, convenience methods are provided for acquiring the values of tags that contain a single value that fits into a <code>byte</code>, <code>int</code>, <code>long</code>, <code>float</code>, or <code>double</code>.
<p>The <code>getTag</code> method returns the tag number. The tag number identifies the field. The tag number is an <code>int</code> value between 0 and 65,535. The <code>getType</code> method returns the type of data stored in the IFD. For a TIFF 6.0 file, the value will be one of those defined in <a href="Acquisition.doc.html#76720">Table &#32;4-7</a>. The <code>getCount</code> method returns the number of elements in the IFD. The count (also known as <em>length</em> in earlier TIFF specifications) is the number of values.
<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>com.sun.media.jai.codec.TIFFField
</code>
<hr>
</td>
</table><pre><ul>
<li>int getTag()
<p></ul></pre><dl>
<a name="76795">
<dt><dd> returns the tag number, between 0 and 65535.
</a><P></dl>
<pre><ul>
<li>int getType()
<p></ul></pre><dl>
<a name="76805">
<dt><dd> returns the type of the data stored in the IFD.
</a><P></dl>
<pre><ul>
<li>int getCount()
<p></ul></pre><dl>
<a name="76815">
<dt><dd> returns the number of elements in the IFD.
</a><P></dl>
<a name="76780">
<h4>4.4.2.4	<img src="shared/space.gif">Public and Private IFDs</h4>
</a>Every TIFF file is made up of one or more public IFDs that are joined in a linked list, rooted in the file header. A file may also contain so-called <em>private</em> IFDs that are referenced from tag data and do not appear in the main list.
<p>The <code>TIFFDecodeParam</code> class allows the index of the TIFF directory (IFD) to be set. In a multipage TIFF file, index 0 corresponds to the first image, index 1 to the second, and so on. The index defaults to 0.
<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>com.sun.media.jai.codec.TIFFDirectory
</code>
<hr>
</td>
</table><pre><ul>
<li>TIFFDirectory(SeekableStream stream, int directory)
<p></ul></pre><dl>
<a name="76218">
<dt><dd> constructs a <code>TIFFDirectory</code> from a <code>SeekableStream</code>. The directory parameter specifies which directory to read from the linked list present in the stream; directory 0 is normally read but it is possible to store multiple images in a single TIFF file by maintaining multiple directories.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=2><em>Parameters</em>:<em></em>
<p><td><code>stream</code>
<p><td>A <code>SeekableStream</code>.
<p>
<tr valign=top><td><code>directory</code>
<p><td>The index of the directory to read.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>TIFFDirectory(SeekableStream stream, long ifd_offset)
<p></ul></pre><dl>
<a name="76263">
<dt><dd> constructs a TIFFDirectory by reading a <code>SeekableStream</code>. The <code>ifd_offset</code> parameter specifies the stream offset from which to begin reading; this mechanism is sometimes used to store private IFDs within a TIFF file that are not part of the normal sequence of IFDs.
</a><P></dl>
<pre><ul>
<li>int getNumEntries()
<p></ul></pre><dl>
<a name="76287">
<dt><dd> returns the number of directory entries.
</a><P></dl>
<pre><ul>
<li>TIFFField getField(int tag)
<p></ul></pre><dl>
<a name="76299">
<dt><dd> returns the value of a given tag as a TIFFField, or null if the tag is not present.
</a><P></dl>
<pre><ul>
<li>boolean isTagPresent(int tag)
<p></ul></pre><dl>
<a name="76314">
<dt><dd> returns true if a tag appears in the directory.
</a><P></dl>
<pre><ul>
<li>int[] getTags()
<p></ul></pre><dl>
<a name="76326">
<dt><dd> returns an ordered array of ints indicating the tag values.
</a><P></dl>
<pre><ul>
<li>TIFFField[] getFields()
<p></ul></pre><dl>
<a name="76343">
<dt><dd> returns an array of TIFFFields containing all the fields in this directory.
</a><P></dl>
<pre><ul>
<li>byte getFieldAsByte(int tag, int index)
<p></ul></pre><dl>
<a name="76360">
<dt><dd> returns the value of a particular index of a given tag as a byte. The caller is responsible for ensuring that the tag is present and has type <code>TIFFField.TIFF_SBYTE</code>, <code>TIFF_BYTE</code>, or <code>TIFF_UNDEFINED</code>.
</a><P></dl>
<pre><ul>
<li>byte getFieldAsByte(int tag)
<p></ul></pre><dl>
<a name="76385">
<dt><dd> returns the value of index 0 of a given tag as a byte. 
</a><P></dl>
<pre><ul>
<li>long getFieldAsLong(int tag, int index)
<p></ul></pre><dl>
<a name="76410">
<dt><dd> returns the value of a particular index of a given tag as a long.
</a><P></dl>
<pre><ul>
<li>long getFieldAsLong(int tag)
<p></ul></pre><dl>
<a name="76429">
<dt><dd> returns the value of index 0 of a given tag as a long.
</a><P></dl>
<pre><ul>
<li>float getFieldAsFloat(int tag, int index)
<p></ul></pre><dl>
<a name="76446">
<dt><dd> returns the value of a particular index of a given tag as a float.
</a><P></dl>
<pre><ul>
<li>float getFieldAsFloat(int tag)
<p></ul></pre><dl>
<a name="76457">
<dt><dd> returns the value of a index 0 of a given tag as a float.
</a><P></dl>
<pre><ul>
<li>double getFieldAsDouble(int tag, int index)
<p></ul></pre><dl>
<a name="76469">
<dt><dd> returns the value of a particular index of a given tag as a double.
</a><P></dl>
<pre><ul>
<li>double getFieldAsDouble(int tag)
<p></ul></pre><dl>
<a name="76484">
<dt><dd> returns the value of index 0 of a given tag as a double.
</a><P></dl>
<a name="75837">
<h3>4.4.3	<img src="shared/space.gif">Reading FlashPix Images</h3>
</a>FlashPix is a multi-resolution, tiled file format that allows images to be stored at different resolutions for different purposes, such as editing or printing. Each resolution is divided into 64 x 64 blocks, or tiles. Within a tile, pixels can be either uncompressed, JPEG compressed, or single-color compressed.
<p>The <code>FPX</code> operation reads an image from a FlashPix stream. The <code>FPX</code> operation takes one parameter:<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="75869">
Parameter
</a><th><a name="75871">
Type
</a><th><a name="75873">
Description
</a>
<tr valign=top><td><a name="75875">
stream</a><br><td><a name="75877">
SeekableStream</a><br><td><a name="75879">
The SeekableStream to read from.</a><br>

</Table>

<p><a href="Acquisition.doc.html#79361">Listing &#32;4-7</a> shows a code sample for a <code>FPX</code> operation.<p>
<caption><font size=-1><b>
<a name="79361">
<center><font size=-1><b><i>Listing 4-7	</i><img src="shared/sm-blank.gif" border=0> Example of Reading a FlashPix Image &#32;</b></font></center>
</a><p>
</b></font></caption>
<hr>
<tr valign=top><td><pre>     // Specify the filename.
     File file = new File(filename);
</pre>
<tr valign=top><td><pre>     // Specify the resolution of the file.
     ImageDecodeParam param = new FPXDecodeParam(resolution);
</pre>
<tr valign=top><td><pre>     // Create the FPX operation to read the file.
     ImageDecoder decoder = ImageCodec.createImageDecoder("fpx",
                                                           file,
                                                           param);
</pre>
<tr valign=top><td><pre>     RenderedImage im = decoder.decodeAsRenderedImage();
     ScrollingImagePanel p =
         new ScrollingImagePanel(im,
                                 Math.min(im.getWidth(), 800) + 20,
                                 Math.min(im.getHeight(), 800) + 20);
</pre>

<hr>

<p><a name="61965">
<h3>4.4.4	<img src="shared/space.gif">Reading JPEG Images</h3>
</a>The JPEG standard was developed by a working group, known as the Joint Photographic Experts Group (JPEG). The JPEG image data compression standard handles grayscale and color images of varying resolution and size. 
<p>The <code>JPEG</code> operation takes a single parameter:<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="61971">
Parameter
</a><th><a name="61973">
Type
</a><th><a name="61975">
Description
</a>
<tr valign=top><td><a name="61977">
file</a><br><td><a name="61979">
SeekableStream</a><br><td><a name="61981">
The SeekableStream to read from.</a><br>

</Table>

<p><a name="61988">
<h3>4.4.5	<img src="shared/space.gif">Reading GIF Images</h3>
</a>Compuserve's Graphics Interchange Format (GIF) is limited to 256 colors, but supported by virtually every platform that supports graphics.
<p>The <code>GIF</code> operation reads an image from a GIF stream. The <code>GIF</code> operation takes a single parameter:<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="64943">
Parameter
</a><th><a name="64945">
Type
</a><th><a name="64947">
Description
</a>
<tr valign=top><td><a name="64949">
stream</a><br><td><a name="64951">
SeekableStream</a><br><td><a name="64953">
The SeekableStream to read from.</a><br>

</Table>

<p><a name="62011">
<h3>4.4.6	<img src="shared/space.gif">Reading BMP Images</h3>
</a>The BMP (Microsoft Windows bitmap image file) file format is a commonly-used file format on IBM PC-compatible computers. BMP files can also refer to the OS/2 bitmap format, which is a strict superset of the Windows format. The OS/2 2.0 format allows for multiple bitmaps in the same file, for the CCITT Group3 1bpp encoding, and also a RLE24 encoding.
<p>The <code>BMP</code> operation reads BMP data from an input stream. The <code>BMP</code> operation currently reads Version2, Version3, and some of the Version 4 images, as defined in the Microsoft Windows BMP file format.
<p>Version 4 of the BMP format allows for the specification of alpha values, gamma values, and CIE colorspaces. These are not currently handled, but the relevant properties are emitted, if they are available from the BMP image file.
<p>The <code>BMP</code> operation takes a single parameter:<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="64041">
Parameter
</a><th><a name="64043">
Type
</a><th><a name="64045">
Description
</a>
<tr valign=top><td><a name="64047">
stream</a><br><td><a name="64049">
SeekableStream</a><br><td><a name="64051">
The SeekableStream to read from.</a><br>

</Table>

<p><a href="Acquisition.doc.html#79427">Listing &#32;4-8</a> shows a code sample for a <code>GIF</code> operation.<p>
<caption><font size=-1><b>
<a name="79427">
<center><font size=-1><b><i>Listing 4-8	</i><img src="shared/sm-blank.gif" border=0> Example of Reading a BMP Image</b></font></center>
</a><p>
</b></font></caption>
<hr>
<tr valign=top><td><pre>     // Wrap the InputStream in a SeekableStream.
     InputStream is = new FileInputStream(filename);
     SeekableStream s = SeekableStream.wrapInputStream(is, false);
</pre>
<tr valign=top><td><pre>     // Create the ParameterBlock and add the SeekableStream to it.
     ParameterBlock pb = new ParameterBlock();
     pb.add(s);
</pre>
<tr valign=top><td><pre>     // Perform the BMP operation
     op = JAI.create("BMP", pb);
</pre>

<hr>

<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>com.sun.media.jai.codec.SeekableStream
</code>
<hr>
</td>
</table><pre><ul>
<li>static SeekableStream wrapInputStream(java.io.InputStream is, 
boolean canSeekBackwards)
<p></ul></pre><dl>
<a name="71133">
<dt><dd> returns a SeekableStream that will read from a given InputStream, optionally including support for seeking backwards.
</a><P></dl>
<a name="62013">
<h3>4.4.7	<img src="shared/space.gif">Reading PNG Images</h3>
</a>The PNG (Portable Network Graphics) is an extensible file format for the lossless, portable, compressed storage of raster images. PNG was developed as a patent-free alternative to GIF and can also replace many common uses of TIFF. Indexed-color, grayscale, and truecolor images are supported, plus an optional alpha channel. Sample depths range from 1 to 16 bits.
<p>For more information on PNG images, see the specification at the following URL:
<p><pre>     http://www.cdrom.com/pub/png/spec
</pre>The <code>PNG</code> operation reads a standard PNG input stream. The <code>PNG</code> operation implements the entire PNG specification, but only provides access to the final, high-resolution version of interlaced images. The output image will always include a <code>ComponentSampleModel</code> and either a byte or short <code>DataBuffer</code>.
<p>Pixels with a bit depth of less than eight are scaled up to fit into eight bits. One-bit pixel values are output as 0 and 255. Pixels with a bit depth of two or four are left shifted to fill eight bits. Palette color images are expanded into three-banded RGB. PNG images stored with a bit depth of 16 will be truncated to 8 bits of output unless the <code>KEY_PNG_EMIT_16BITS</code> hint is set to <code>Boolean.TRUE</code>. Similarly, the output image will not have an alpha channel unless the <code>KEY_PNG_EMIT_ALPHA</code> hint is set. See <a href="Acquisition.doc.html#75792">Section &#32;4.4.7.3, "Rendering Hints</a>."
<p>The <code>PNG</code> operation takes a single parameter:<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="62925">
Parameter
</a><th><a name="62927">
Type
</a><th><a name="62917">
Description
</a>
<tr valign=top><td><a name="62919">
stream</a><br><td><a name="62921">
SeekableStream</a><br><td><a name="62923">
The SeekableStream to read from.</a><br>

</Table>

<p><a href="Acquisition.doc.html#79461">Listing &#32;4-9</a> shows a code sample for a <code>PNG</code> operation.<p>
<caption><font size=-1><b>
<a name="79461">
<center><font size=-1><b><i>Listing 4-9	</i><img src="shared/sm-blank.gif" border=0> Example of Reading a PNG Image</b></font></center>
</a><p>
</b></font></caption>
<hr>
<tr valign=top><td><pre>     // Create the ParameterBlock.
     InputStream image = new FileInputStream(filename);
     ParameterBlock pb = new ParameterBlock();
     pb.add(image);
</pre>
<tr valign=top><td><pre>     // Create the PNG operation.
     op = JAI.create("PNG", pb);
</pre>

<hr>

<p>Several aspects of the PNG image decoding may be controlled. By default, decoding produces output images with the following properties:
<p><ul>
<li>Images with a bit depth of eight or less use a <code>DataBufferByte</code> to hold the pixel data. 16-bit images use a <code>DataBufferUShort</code>.<p></ul><ul>
<li>Palette color images and non-transparent grayscale images with bit depths of one, two, or four will have a <code>MultiPixelPackedSampleModel</code> and an <code>IndexColorModel</code>. For palette color images, the <code>ColorModel</code> palette contains the red, green, blue, and optionally alpha palette information. For grayscale images, the palette is used to expand the pixel data to cover the range 0 to 255. The pixels are stored packed eight, four, or two to the byte.<p></ul><ul>
<li>All other images are stored using a <code>PixelInterleavedSampleModel</code> with each band of a pixel occupying its own <code>byte</code> or <code>short</code> within the <code>DataBuffer</code>. A <code>ComponentColorModel</code> is used, which simply extracts the red, green, blue, gray, and/or alpha information from separate <code>DataBuffer</code> entries.<p></ul>Methods in the <code>PNGDecodeParam</code> class permit changes to five aspects of the decode process:
<p><ul>
<li>The <code>setSuppressAlpha()</code> method prevents an alpha channel from appearing in the output.<p></ul><ul>
<li>The <code>setExpandPalette()</code> method turns palette-color images into three- or four-banded full-color images.<p></ul><ul>
<li>The <code>setOutput8BitGray()</code> method causes one-, two-, or four-bit grayscale images to be output in eight-bit form, using a <code>ComponentSampleModel</code> and <code>ComponentColorModel</code>.<p></ul><ul>
<li>The <code>setOuputGamma()</code> method causes the output image to be gamma-corrected using a supplied output gamma value.<p></ul><ul>
<li>The <code>setExpandGrayAlpha()</code> method causes two-banded gray/alpha (GA) images to be output as full-color (GGGA) images, which may simplify further processing and display.<p></ul><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>com.sun.media.jai.codec.PNGDecodeParam
</code>
<hr>
</td>
</table><pre><ul>
<li>public void setSuppressAlpha(boolean suppressAlpha)
<p></ul></pre><dl>
<a name="72797">
<dt><dd> when set, suppresses the alpha (transparency) channel in the output image.
</a><P></dl>
<pre><ul>
<li>public void setExpandPalette(boolean expandPalette)
<p></ul></pre><dl>
<a name="72974">
<dt><dd> when set, causes palette color images (PNG color type 3) to be decoded into full-color (RGB) output images. The output image may have three or four bands, depending on the presence of transparency information. The default is to output palette images using a single band. The palette information is used to construct the output image's <code>ColorModel</code>.<code></code>
</a><P></dl>
<pre><ul>
<li>public void setOutput8BitGray(boolean output8BitGray)
<p></ul></pre><dl>
<a name="72994">
<dt><dd> when set, causes grayscale images with a bit depth of less than eight (one, two, or four) to be output in eight-bit form. The output values will occupy the full eight-bit range. For example, gray values zero, one, two, and three of a two-bit image will be output as 0, 85, 170, and 255. The decoding of non-grayscale images and grayscale images with a bit depth of 8 or 16 are unaffected by this setting. The default is not to perform expansion. Grayscale images with a depth of one, two, or four bits will be represented using a <code>MultiPixelPackedSampleModel</code> and an <code>IndexColorModel</code>.
</a><P></dl>
<pre><ul>
<li>public void setOutputGamma(float outputGamma)
<p></ul></pre><dl>
<a name="72881">
<dt><dd> sets the desired output gamma to a given value. In terms of the definitions in the PNG specification, the output gamma is equal to the viewing gamma divided by the display gamma. The output gamma must be positive. If the output gamma is set, the output image will be gamma-corrected using an overall exponent of output gamma/file gamma. Input files that do not contain gamma information are assumed to have a file gamma of 1.0. This parameter affects the decoding of all image types.
</a><P></dl>
<pre><ul>
<li>public void setExpandGrayAlpha(boolean expandGrayAlpha)
<p></ul></pre><dl>
<a name="73040">
<dt><dd> when set, causes images containing one band of gray and one band of alpha (GA) to be output in a four-banded format (GGGA). This produces output that may be simpler to process and display. This setting affects both images of color type 4 (explicit alpha) and images of color type 0 (grayscale) that contain transparency information.
</a><P></dl>
<a name="80178">
<h4>4.4.7.1	<img src="shared/space.gif">Gamma Correction and Exponents</h4>
</a>PNG images can contain a gamma correction value. The gamma value specifies the relationship between the image samples and the desired display output intensity as a power function:
<p><dl>
<a name="80183">
<dt><dd> sample = light_out<sup>gamma</sup>
</a><P></dl>
The <code>getPerformGammaCorrection</code> method returns <code>true</code> if gamma correction is to be performed on the image data. By default, gamma correction is <code>true</code>.
<p>If gamma correction is to be performed, the <code>getUserExponent</code> and <code>getDisplayExponent</code> methods are used in addition to the gamma value stored within the file (or the default value of 1/2.2 is used if no value is found) to produce a single exponent using the following equation:
<p><dl>
<a name="80214">
<dt><dd> <img src="Acquisition.doc.ancA5.gif">
</a><P></dl>
The <code>setUserExponent</code> method is used to set the <code>user_exponent</code> value. If the <code>user_exponent</code> value is set, the output image pixels are placed through the following transformation:
<p><dl>
<a name="80238">
<dt><dd> <img src="Acquisition.doc.anc6.gif">
</a><P><a name="80290">
<dt><dd> where <code>gamma_from_file</code> is the gamma of the file data, as determined by the gAMA, sRGB, and iCCP chunks. <code>display_exponent</code> is the exponent of the intrinsic transfer curve of the display, generally 2.2.
</a><P></dl>
Input files that do not specify any gamma value are assumed to have a gamma of 1/2.2. Such images may be displayed on a CRT with an exponent of 2.2 using the default user exponent of 1.0.
<p>The user exponent may be used to change the effective gamma of a file. If a file has a stored gamma of <em>X</em>, but the decoder believes that the true file gamma is <em>Y</em>, setting a user exponent of <em>Y</em>/<em>X</em> will produce the same result as changing the file gamma.
<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>com.sun.media.jai.codec.PNGDecodeParam
</code>
<hr>
</td>
</table><pre><ul>
<li>boolean getPerformGammaCorrection()
<p></ul></pre><dl>
<a name="80086">
<dt><dd> returns <code>true</code> if gamma correction is to be performed on the image data. The default is <code>true</code>.
</a><P></dl>
<pre><ul>
<li>void setPerformGammaCorrection(boolean performGammaCorrection)
<p></ul></pre><dl>
<a name="80138">
<dt><dd> turns gamma correction of the image data on or off.
</a><P></dl>
<pre><ul>
<li>float getUserExponent()
<p></ul></pre><dl>
<a name="80154">
<dt><dd> returns the current value of the user exponent parameter. By default, the user exponent is equal to 1.0F.
</a><P></dl>
<pre><ul>
<li>void setUserExponent(float userExponent)
<p></ul></pre><dl>
<a name="80165">
<dt><dd> sets the user exponent to a given value. The exponent must be positive.
</a><P></dl>
<pre><ul>
<li>float getDisplayExponent()
<p></ul></pre><dl>
<a name="80341">
<dt><dd> returns the current value of the display exponent parameter. By default, the display exponent is 2.2F.
</a><P></dl>
<pre><ul>
<li>void setDisplayExponent(float displayExponent)
<p></ul></pre><dl>
<a name="80358">
<dt><dd> Sets the display exponent to a given value. The exponent must be positive.
</a><P></dl>
<a name="80363">
<h4>4.4.7.2	<img src="shared/space.gif">Expanding Grayscale Images to GGGA Format</h4>
</a>Normally, the <code>PNG</code> operation does not expand images that contain one channel of gray and one channel of alpha into a four-channel (GGGA) format. If this type of expansion is desired, use the <code>setExpandGrayAlpha</code> method. This setting affects both images of color type 4 (explicit alpha) and images of color type 0 (grayscale) that contain transparency information.
<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>com.sun.media.jai.codec.PNGDecodeParam
</code>
<hr>
</td>
</table><pre><ul>
<li>void setExpandGrayAlpha(boolean expandGrayAlpha)
<p></ul></pre><dl>
<a name="80406">
<dt><dd> sets or unsets the expansion of two-channel (gray and alpha) PNG images to four-channel (GGGA) images.
</a><P></dl>
<a name="75792">
<h4>4.4.7.3	<img src="shared/space.gif">Rendering Hints</h4>
</a>The PNG rendering hints are:<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="75796">
Hints
</a><th><a name="75798">
Description
</a>
<tr valign=top><td><a name="75800">
KEY_PNG_EMIT_ALPHA</a><br><td><a name="75802">
The alpha channel is set. The alpha channel, representing transparency information on a per-pixel basis, can be included in grayscale and truecolor PNG images.</a><br>
<tr valign=top><td><a name="75804">
KEY_PNG_EMIT_16BITS</a><br><td><a name="75806">
Defines a bit depth of 16 bits.</a><br>

</Table>

<p>To read the hints, use the <code>OperationDescriptorImpl.getHint</code> method.
<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code><code>javax.media.jai.OperationDescriptorImpl
</code></code>
<hr>
</td>
</table><pre><ul>
<li>Object getHint(RenderingHints.Key key, 
       RenderingHints &#32;renderHints)
<p></ul></pre><dl>
<a name="75815">
<dt><dd> queries the rendering hints for a particular hint key and copies it into the hints observed Hashtable if found. If the hint is not found, null is returned and the hints observed are left unchanged.
</a><P></dl>
<a name="64990">
<h3>4.4.8	<img src="shared/space.gif">Reading PNM Images</h3>
</a>The <code>PNM</code> operation reads a standard PNM file, including PBM, PGM, and PPM images of both ASCII and raw formats. The PBM (portable bitmap) format is a monochrome file format (single-banded), originally designed as a simple file format to make it easy to mail bitmaps between different types of machines. The PGM (portable graymap) format is a grayscale file format (single-banded). The PPM (portable pixmap) format is a color image file format (three-banded).
<p>PNM image files are identified by a <em>magic number</em> in the file header that identifies the file type variant, as follows:<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="70741">
Magic Number
</a><th><a name="70743">
File Type
</a><th><a name="77433">
SampleModel Type
</a>
<tr valign=top><td><a name="70745">
P1</a><br><td><a name="70747">
PBM ASCII</a><br><td><a name="77435">
MultiPixelPackedSampleModel</a><br>
<tr valign=top><td><a name="70749">
P2</a><br><td><a name="70751">
PGM ASCII</a><br><td><a name="77437">
PixelInterleavedSampleModel</a><br>
<tr valign=top><td><a name="70753">
P3</a><br><td><a name="70755">
PPM ASCII</a><br><td><a name="77439">
PixelInterleavedSampleModel</a><br>
<tr valign=top><td><a name="70768">
P4</a><br><td><a name="70770">
PBM raw</a><br><td><a name="77441">
MultiPixelPackedSampleModel</a><br>
<tr valign=top><td><a name="70764">
P5</a><br><td><a name="70766">
PGM raw</a><br><td><a name="77443">
PixelInterleavedSampleModel</a><br>
<tr valign=top><td><a name="70760">
P6</a><br><td><a name="70762">
PPM raw</a><br><td><a name="77445">
PixelInterleavedSampleModel</a><br>

</Table>

<p>The <code>PNM</code> operation reads the file header to determine the file type, then stores the image data into an appropriate <code>SampleModel</code>. The <code>PNM</code> operation takes a single parameter:<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="65015">
Parameter
</a><th><a name="65017">
Type
</a><th><a name="65019">
Description
</a>
<tr valign=top><td><a name="65021">
stream</a><br><td><a name="65023">
SeekableStream</a><br><td><a name="65025">
The SeekableStream to read from.</a><br>

</Table>

<p><a href="Acquisition.doc.html#79487">Listing &#32;4-10</a> shows a code sample for a <code>PNM</code> operation.<p>
<caption><font size=-1><b>
<a name="79487">
<center><font size=-1><b><i>Listing 4-10	</i><img src="shared/sm-blank.gif" border=0> Example of Reading a PNM Image</b></font></center>
</a><p>
</b></font></caption>
<hr>
<tr valign=top><td><pre>     // Create the ParameterBlock.
     InputStream image = new FileInputStream(filename);
     ParameterBlock pb = new ParameterBlock();
     pb.add(image);
</pre>
<tr valign=top><td><pre>     // Create the PNM operation.
     op = JAI.create("PNM", pb);
</pre>

<hr>

<p><a name="62069">
<h3>4.4.9	<img src="shared/space.gif">Reading Standard AWT Images</h3>
</a>The <code>AWTImage</code> operation allows standard Java AWT images to be directly imported into JAI, as a rendered image. By default, the width and height of the image are the same as the original AWT image. The sample model and color model are set according to the AWT image data. The layout of the <code>PlanarImage</code> may be specified using the <code>ImageLayout</code> parameter at constructing time.
<p>The <code>AWTImage</code> operation takes one parameter.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="69105">
Parameter
</a><th><a name="69107">
Type
</a><th><a name="69109">
Description
</a>
<tr valign=top><td><a name="69111">
awtImage</a><br><td><a name="69113">
Image</a><br><td><a name="69115">
The standard Java AWT image to be converted.</a><br>

</Table>

<p><a href="Acquisition.doc.html#79513">Listing &#32;4-11</a> shows a code sample for an <code>AWTImage</code> operation.<p>
<caption><font size=-1><b>
<a name="79513">
<center><font size=-1><b><i>Listing 4-11	</i><img src="shared/sm-blank.gif" border=0> Example of Reading an AWT Image</b></font></center>
</a><p>
</b></font></caption>
<hr>
<tr valign=top><td><pre>     // Create the ParameterBlock.
     ParameterBlock pb = new ParameterBlock();
     pb.add(image);
</pre>
<tr valign=top><td><pre>     // Create the AWTImage operation.
     PlanarImage im = (PlanarImage)JAI.create("awtImage", pb);
</pre>

<hr>

<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.PlanarImage
</code>
<hr>
</td>
</table><pre><ul>
<li>void setImageParameters(ImageLayout layout, RenderedImage im)
<p></ul></pre><dl>
<a name="77515">
<dt><dd> sets the image bounds, tile grid layout, <code>SampleModel</code>, and <code>ColorModel</code> to match those of another image.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=2><em>Parameters</em>:<em></em>
<p><td><code>layout</code>
<p><td>An <code>ImageLayout</code> used to selectively override the image's layout, <code>SampleModel</code>, and <code>ColorModel</code>. If null, all parameters will be taken from the second argument.
<p>
<tr valign=top><td><code>im</code>
<p><td>A <code>RenderedImage</code> used as the basis for the layout.
<p>

</Table>

</a><P></dl>
<a name="71531">
<h3>4.4.10	<img src="shared/space.gif">Reading URL Images</h3>
</a>The <code>URL</code> operation creates an image whose source is specified by a Uniform Resource Locator (URL). The <code>URL</code> operation takes one parameter.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="71567">
Parameter
</a><th><a name="71569">
Type
</a><th><a name="71571">
Description
</a>
<tr valign=top><td><a name="71573">
URL</a><br><td><a name="71575">
java.net.URL.<br>class</a><br><td><a name="71577">
The path of the file to read from.</a><br>

</Table>

<p><a href="Acquisition.doc.html#79538">Listing &#32;4-12</a> shows a code sample for a <code>URL</code> operation.<p>
<caption><font size=-1><b>
<a name="79538">
<center><font size=-1><b><i>Listing 4-12	</i><img src="shared/sm-blank.gif" border=0> Example of Reading a URL Image &#32;</b></font></center>
</a><p>
</b></font></caption>
<hr>
<tr valign=top><td><pre>     // Define the URL to the image.
     url = new URL("http://webstuff/images/duke.gif");
</pre>
<tr valign=top><td><pre>     // Read the image from the designated URL.
     RenderedOp src = JAI.create("url", url);
</pre>

<hr>
<strong></strong>
<p><a name="79558">
<h2>4.5	<img src="shared/space.gif">Reformatting an Image</h2>
</a>The <code>Format</code> operation reformats an image by casting the pixel values of an image to a given data type, replacing the <code>SampleModel</code> and <code>ColorModel</code> of an image, and restructuring the image's tile grid layout.
<p>The pixel values of the destination image are defined by the following pseudocode:
<p><pre>     dst[x][y][b] = cast(src[x][y][b], dataType)
<dl>
<a name="64194">
<dt><dd> where <code>dataType</code> is one of the constants <code>DataBuffer.TYPE_BYTE</code>, <code>DataBuffer.TYPE_SHORT</code>, <code>DataBuffer.TYPE_USHORT</code>, <code>DataBuffer.TYPE_INT</code>, <code>DataBuffer.TYPE_FLOAT</code>, or <code>TDataBuffer.YPE_DOUBLE</code>.
</a><P></dl>
</pre>The output <code>SampleModel</code>, <code>ColorModel</code>, and tile grid layout are specified by passing an <code>ImageLayout</code> object as a <code>RenderingHint</code> named <code>ImageLayout</code>. The output image will have a <code>SampleModel</code> compatible with the one specified in the layout hint wherever possible; however, for output data types of float and double a <code>ComponentSampleModel</code> will be used regardless of the value of the <code>hint</code> parameter.
<p>The <code>ImageLayout</code> may also specify a tile grid origin and size which will be respected. 
<p>The typecasting performed by the <code>Format</code> operation is defined by the set of expressions listed in <a href="Acquisition.doc.html#64379">Table &#32;4-8</a>, depending on the data types of the source and destination. Casting an image to its current data type is a no-op. See <em>The Java Language Specification</em> for the definition of type conversions between primitive types.
<p>In most cases, it is not necessary to explicitly perform widening typecasts since they will be performed automatically by image operators when handed source images having different datatypes. <p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b><a name="64379">
<i>Table 4-8	 </i><img src="shared/sm-blank.gif" border=0> Format Actions &#32;
</a></b></font></caption>
<tr valign=top><th><a name="64385">
Source Type
</a><th><a name="64387">
Destination Type
</a><th><a name="64389">
Action
</a>
<tr valign=top><td colspan=1 rowspan=5><a name="64391">
BYTE</a><br><td><a name="64393">
SHORT</a><br><td><a name="64395">
(short)(x &amp; 0xff)</a><br>
<tr valign=top><td><a name="64399">
USHORT</a><br><td><a name="64401">
(short)(x &amp; 0xff)</a><br>
<tr valign=top><td><a name="64405">
INT</a><br><td><a name="64407">
(int)(x &amp; 0xff)</a><br>
<tr valign=top><td><a name="64411">
FLOAT</a><br><td><a name="64413">
(float)(x &amp; 0xff)</a><br>
<tr valign=top><td><a name="64417">
DOUBLE</a><br><td><a name="64419">
(double)(x &amp; 0xff)</a><br>
<tr valign=top><td colspan=1 rowspan=5><a name="64421">
SHORT</a><br><td><a name="64423">
BYTE</a><br><td><a name="64425">
(byte)clamp((int)x, 0, 255)</a><br>
<tr valign=top><td><a name="64596">
USHORT</a><br><td><a name="64431">
(short)clamp((int)x, 0, 32767)</a><br>
<tr valign=top><td><a name="64598">
INT</a><br><td><a name="64437">
(int)x</a><br>
<tr valign=top><td><a name="64600">
FLOAT</a><br><td><a name="64443">
(float)x</a><br>
<tr valign=top><td><a name="64602">
DOUBLE</a><br><td><a name="64449">
(double)x</a><br>
<tr valign=top><td colspan=1 rowspan=5><a name="64451">
USHORT</a><br><td><a name="64453">
BYTE</a><br><td><a name="64455">
(byte)clamp((int)x &amp; 0xffff, 0, 255)</a><br>
<tr valign=top><td><a name="64459">
SHORT</a><br><td><a name="64461">
(short)clamp((int)x &amp; 0xffff, 0, 32767)</a><br>
<tr valign=top><td><a name="64632">
INT</a><br><td><a name="64467">
(int)(x &amp; 0xffff)</a><br>
<tr valign=top><td><a name="64634">
FLOAT</a><br><td><a name="64473">
(float)(x &amp; 0xffff)</a><br>
<tr valign=top><td><a name="64636">
DOUBLE</a><br><td><a name="64479">
(double)(x &amp; 0xffff)</a><br>
<tr valign=top><td colspan=1 rowspan=5><a name="64481">
INT</a><br><td><a name="64483">
BYTE</a><br><td><a name="64485">
(byte)clamp(x, 0, 255)</a><br>
<tr valign=top><td><a name="64489">
SHORT</a><br><td><a name="64491">
(short)x</a><br>
<tr valign=top><td><a name="64495">
USHORT</a><br><td><a name="64497">
(short)clamp(x, 0, 65535)</a><br>
<tr valign=top><td><a name="64666">
FLOAT</a><br><td><a name="64503">
(float)x</a><br>
<tr valign=top><td><a name="64668">
DOUBLE</a><br><td><a name="64509">
(double)x</a><br>
<tr valign=top><td colspan=1 rowspan=5><a name="64511">
FLOAT</a><br><td><a name="64698">
BYTE</a><br><td><a name="64515">
(byte)clamp((int)x, 0, 255)</a><br>
<tr valign=top><td><a name="64700">
SHORT</a><br><td><a name="64521">
(short)x</a><br>
<tr valign=top><td><a name="64702">
USHORT</a><br><td><a name="64527">
(short)clamp((int)x, 0, 65535)</a><br>
<tr valign=top><td><a name="64531">
INT</a><br><td><a name="64533">
(int)x</a><br>
<tr valign=top><td><a name="64537">
DOUBLE</a><br><td><a name="64539">
(double)x</a><br>
<tr valign=top><td colspan=1 rowspan=5><a name="64541">
DOUBLE</a><br><td><a name="64728">
BYTE</a><br><td><a name="64545">
(byte)clamp((int)x, 0, 255)</a><br>
<tr valign=top><td><a name="64730">
SHORT</a><br><td><a name="64551">
(short)x</a><br>
<tr valign=top><td><a name="64732">
USHORT</a><br><td><a name="64557">
(short)clamp((int)x, 0, 65535)</a><br>
<tr valign=top><td><a name="64734">
INT</a><br><td><a name="64563">
(int)x</a><br>
<tr valign=top><td><a name="64567">
FLOAT</a><br><td><a name="64569">
(float)x</a><br>

</Table>

<p>The <code>clamp</code> function may be defined as:<p>
<caption><font size=-1><b></b></font></caption>
<hr>
<tr valign=top><td colspan=1 rowspan=3><pre>     int clamp(int x, int low, int high) {
         return (x &lt; low) ? low : ((x &gt; high) ? high : x);
     }
</pre>
<tr valign=top>
<tr valign=top>

<hr>

<p>The <code>Format</code> operation takes a single parameter:<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="64778">
Parameter
</a><th><a name="64780">
Type
</a><th><a name="64782">
Description
</a>
<tr valign=top><td><a name="64784">
dataType</a><br><td><a name="64786">
Integer</a><br><td><a name="64788">
The output data type (from java.awt.image.DataBuffer). One of TYPE_BYTE, TYPE_SHORT, TYPE_USHORT, TYPE_INT, TYPE_FLOAT, or TYPE_DOUBLE.</a><br>

</Table>

<p><a name="81553">
<h2>4.6	<img src="shared/space.gif">Converting a Rendered Image to Renderable</h2>
</a>To use a Renderable DAG with a non-renderable image type, the image must first be converted from a Rendered type to a Renderable type. For example, to use an image obtained from a remote server in a Renderable chain, you would want to treat the source image as a <code>RenderedImage</code>, then convert it to a <code>RenderableImage</code> for further processing.
<p>The <code>Renderable</code> operation produces a <code>RenderableImage</code> from a <code>RenderedImage</code> source. The <code>RenderableImage</code> thus produced consists of a "pyramid" of <code>RenderedImage</code>s at progressively lower resolutions. The lower resolution images are produced by invoking the chain of operations specified via the <code>downSampler</code> parameter on the image at the next higher resolution level of the pyramid. The <code>downSampler</code> operation chain must adhere to the specifications described for the constructors of the <code>ImageMIPMap</code> class, which accept this type of parameter (see <a href="Acquisition.doc.html#73387">Section &#32;4.2.9.1, "The Down Sampler</a>").
<p>The <code>downSampler</code> operation chain must reduce the image width and height at each level of the pyramid. The default operation chain for <code>downSampler</code> is a low pass filter implemented using a 5 x 5 separable Gaussian kernel derived from the one-dimensional kernel:
<p><pre>     [0.05 0.25 0.40 0.25 0.05]
</pre>followed by subsampling by 2. This filter is known as a Laplacian pyramid<a href="#82022"><sup>1</sup></a> and makes a perfectly good <code>downSampler</code> for most applications. If this downSampler doesn't work for your specific application, you can create your own and call it with the <code>downSampler</code> parameter.
<p>The number of levels in the pyramid will be such that the larger dimension (width or height) of the lowest-resolution pyramid level is less than or equal to the value of the <code>maxLowResDim</code> parameter, which must be positive. The default value for the <code>maxLowResDim</code> parameter is 64, meaning that the lowest-resolution pyramid level will be an image whose largest dimension is 64 pixels or less.
<p>The minimum <em>x</em> and <em>y</em> coordinates and height in rendering-independent coordinates are supplied by the parameters <code>minX</code>, <code>minY</code>, and <code>height</code>, respectively. The value of the <code>height</code> parameter must be positive. It is not necessary to supply a value for the rendering-independent width as this is derived by multiplying the supplied height by the aspect ratio (width divided by height) of the source <code>RenderedImage</code>.
<p>The <code>Renderable</code> operation takes five parameters, as follows:<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="81678">
Parameter
</a><th><a name="81680">
Type
</a><th><a name="81682">
Description
</a>
<tr valign=top><td><a name="81648">
downSamples</a><br><td><a name="81650">
RenderedOp</a><br><td><a name="81688">
The operation chain used to derive the lower resolution images.</a><br>
<tr valign=top><td><a name="81654">
maxLowResDim</a><br><td><a name="81656">
Integer</a><br><td><a name="81699">
The maximum dimension of the lowest resolution pyramid level.</a><br>
<tr valign=top><td><a name="81660">
minX</a><br><td><a name="81662">
Float</a><br><td><a name="81724">
The minimum rendering-independent <em>x</em> coordinate of the destination.</a><br>
<tr valign=top><td><a name="81666">
minY</a><br><td><a name="81668">
Float</a><br><td><a name="81733">
The minimum rendering-independent <em>y</em> coordinate of the destination.</a><br>
<tr valign=top><td><a name="81672">
height</a><br><td><a name="81674">
Float</a><br><td><a name="81676">
The rendering-independent height.</a><br>

</Table>

<p>The default values for these parameters are:
<p><ul>
<li><code>downSampler</code> - a low-pass filter (see <a href="Acquisition.doc.html#73387">Section &#32;4.2.9.1, "The Down Sampler</a>")<p></ul><ul>
<li><code>maxLowResDim</code> - 64<p></ul><ul>
<li><code>minX</code> - 0.0F<p></ul><ul>
<li><code>minY</code> - 0.0F<p></ul><ul>
<li><code>height</code> - 1.0F<code></code><p></ul><a href="Acquisition.doc.html#81812">Listing &#32;4-13</a> shows a code sample for a <code>Renderable</code> operation. The default parameters are used for all five parameters. The output of the <code>Renderable</code> operation (<code>ren</code>) can be passed to the next renderable operation in the graph.<p>
<caption><font size=-1><b>
<a name="81812">
<center><font size=-1><b><i>Listing 4-13	</i><img src="shared/sm-blank.gif" border=0> Example of Converting a Rendered Image to Renderable</b></font></center>
</a><p>
</b></font></caption>
<hr>
<tr valign=top><td colspan=1 rowspan=14><pre>     // Derive the RenderableImage from the source RenderedImage.
     ParameterBlock pb = new ParameterBlock();
     pb.addSource(src);
     pb.add(null).add(null).add(null).add(null).add(null);
</pre>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top><td colspan=1 rowspan=5><pre>     // Create the Renderable operation.
     RenderableImage ren = JAI.createRenderable("renderable", pb);
</pre>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>

<hr>

<p><a name="72170">
<h2>4.7	<img src="shared/space.gif">Creating a Constant Image</h2>
</a>The <code>constant</code> operation defines a multi-banded, tiled rendered image where all the pixels from the same band have a constant value. The width and height of the destination image must be specified and greater than 0. 
<p>The <code>constant</code> operation takes three parameters, as follows:<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="81110">
Parameter
</a><th><a name="81112">
Type
</a><th><a name="81114">
Description
</a>
<tr valign=top><td><a name="81116">
width</a><br><td><a name="81118">
Float</a><br><td><a name="81120">
The width of the image in pixels.</a><br>
<tr valign=top><td><a name="81122">
height</a><br><td><a name="81124">
Float</a><br><td><a name="81126">
The height of the image in pixels.</a><br>
<tr valign=top><td><a name="81128">
bandValues</a><br><td><a name="81130">
Number</a><br><td><a name="81132">
The constant pixel band values.</a><br>

</Table>

<p>At least one constant must be supplied. The number of bands of the image is determined by the number of constant pixel values supplied in the <code>bandValues</code> parameter. The data type is determined by the type of the constant from the first entry.
<p><a href="Acquisition.doc.html#81146">Listing &#32;4-14</a> shows a code sample for a <code>Constant</code> operation.<p>
<caption><font size=-1><b>
<a name="81146">
<center><font size=-1><b><i>Listing 4-14	</i><img src="shared/sm-blank.gif" border=0> Example Constant Operation &#32;</b></font></center>
</a><p>
</b></font></caption>
<hr>
<tr valign=top><td><pre>     // Create the ParameterBlock.
     Byte[] bandValues = new Byte[1];
     bandValues[0] = alpha1;
     pb = new ParameterBlock();
     pb.add(new Float(src1.getWidth()));   // The width
     pb.add(new Float(src1.getHeight()));  // The height
     pb.add(bandValues);                   // The band values
</pre>
<tr valign=top><td><pre>     // Create the constant operation.
     PlanarImage afa1 = (PlanarImage)JAI.create("constant", pb);
</pre>

<hr>

<p><a name="73265">
<h2>4.8	<img src="shared/space.gif">Image Display</h2>
</a>JAI uses the Java 2D <code>BufferedImage</code> model for displaying images. The <code>BufferedImage</code> manages an image in memory and provides ways to store pixel data, interpret pixel data, and to render the pixel data to a <code>Graphics2D</code> context.
<p>The display of images in JAI may be accomplished in several ways. First, the <code>drawRenderedImage()</code> call on <code>Graphics2D</code> may be used to produce an immediate rendering. Another method is to instantiate a display widget that responds to user requests such as scrolling and panning, as well as expose events, and requests image data from a <code>RenderedImage</code> source. This technique allows image data to be computed on demand.
<p>It is for this purpose that JAI provides a widget, available in the <code>javax.media.jai.widget</code> package, called a <code>ScrollingImagePanel</code>. The <code>ScrollingImagePanel</code> takes a <code>RenderedImage</code> and a specified width and height and creates a panel with scrolling bars on the right and bottom. The image is placed in the center of the panel.
<p>The scrolling image panel constructor takes three parameters. The first parameter is the image itself, which is usually the output of some previous operation in the rendering chain. The next two parameters are the image width and height, which can be retrieved with the <code>getWidth</code> and <code>getHeight</code> methods of the node in which the image was constructed (such as <code>RenderedOp</code>).
<p>The width and height parameters do not have to be the same as the image's width and height. The parameters can be either larger or smaller than the image.
<p>Once the <code>ScrollingImagePanel</code> is created, it can be placed anywhere in a <code>Frame</code>, just like any other AWT panel. <a href="Acquisition.doc.html#79578">Listing &#32;4-15</a> shows a code sample demonstrating the use of a scrolling image panel.<p>
<caption><font size=-1><b>
<a name="79578">
<center><font size=-1><b><i>Listing 4-15	</i><img src="shared/sm-blank.gif" border=0> Example Scrolling Image Panel &#32;</b></font></center>
</a><p>
</b></font></caption>
<hr>
<tr valign=top><td><pre>     // Get the image width and height.
     int width = image.getWidth();
     int height = image.getHeight();
</pre>
<tr valign=top><td><pre>     // Attach the image to a scrolling panel to be displayed.
     ScrollingImagePanel panel = new ScrollingImagePanel(
                                     image, width, height);
</pre>
<tr valign=top><td><pre>     // Create a Frame to contain the panel.
     Frame window = new Frame("Scrolling Image Panel Example");
     window.add(panel);
     window.pack();
     window.show();
</pre>

<hr>

<p>For a little more interesting example, consider the display of four images in a grid layout. The code sample in <a href="Acquisition.doc.html#79615">Listing &#32;4-16</a> arranges four images into a 2 x 2 grid. This example uses the <code>java.awt.Panel</code> and the <code>java.awt.GridLayout</code> objects. These objects are not described in this document. See the Java Platform documentation for more information.<p>
<caption><font size=-1><b>
<a name="79615">
<center><font size=-1><b><i>Listing 4-16	</i><img src="shared/sm-blank.gif" border=0> Example Grid Layout of Four Images &#32;</b></font></center>
</a><p>
</b></font></caption>
<hr>
<tr valign=top><td><pre>     // Display the four images in row order in a 2 x 2 grid.
     setLayout(new GridLayout(2, 2));
</pre>
<tr valign=top><td><pre>     // Add the components, starting with the first entry in the
     // first row, the second, etc.
     add(new ScrollingImagePanel(im1, width, height));
     add(new ScrollingImagePanel(im2, width, height));
     add(new ScrollingImagePanel(im3, width, height));
     add(new ScrollingImagePanel(im4, width, height));
</pre>
<tr valign=top><td><pre>     pack();
     show();
</pre>

<hr>

<p>The constructor for the <code>GridLayout</code> object specifies the number of rows and columns in the display (2 x 2 in this example). The four images (<code>im1</code>, <code>im2</code>, <code>im3</code>, and <code>im4</code>) are then added to the panel in separate <code>ScrollingImagePanel</code>s. The resulting image is arranged as shown in <a href="Acquisition.doc.html#79732">Figure &#32;4-5</a>.
<p><a name="79731">
 <hr>
<center><img src="Acquisition.doc.ancA4.gif"></center><hr>

</a>
<a name="79732">
<center><font size=-1><b><i>Figure 4-5	</i><img src="shared/sm-blank.gif" border=0> Grid Layout of Four Images</b></font></center>
</a><p>
<table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.RenderedOp
</code>
<hr>
</td>
</table><pre><ul>
<li>int getWidth()
<p></ul></pre><dl>
<a name="77248">
<dt><dd> returns the width of the rendered image.
</a><P></dl>
<pre><ul>
<li>int getHeight()
<p></ul></pre><dl>
<a name="77261">
<dt><dd> returns the height of the rendered image.
</a><P></dl>
<table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.widget.ScrollingImagePanel
</code>
<hr>
</td>
</table><pre><ul>
<li>ScrollingImagePanel(RenderedImage im, int width, int height)
<p></ul></pre><dl>
<a name="56679">
<dt><dd> constructs a <code>ScrollingImagePanel</code> of a given size for a given <code>RenderedImage</code>.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=3><em>Parameters</em>:
<p><td><code>im</code>
<p><td>The <code>RenderedImage</code> displayed by the <code>ImageCanvas</code>.
<p>
<tr valign=top><td><code>width</code>
<p><td>The panel width.
<p>
<tr valign=top><td><code>height</code>
<p><td>The panel height.
<p>

</Table>

</a><P></dl>
<a name="56896">
<h3>4.8.1	<img src="shared/space.gif">Positioning the Image in the Panel</h3>
</a>You can define the position of the image within the <code>ScrollingImagePanel</code> by specifying either the position of the image origin or the image center location. The <code>setOrigin</code> method sets the origin of the image to a given (<em>x</em>, <em>y</em>) position within the <code>ScrollingImagePanel</code>. The <code>setCenter</code> method sets the image center to a given (<em>x</em>, <em>y</em>) position within the <code>ScrollingImagePanel</code>.
<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.widget.ScrollingImagePanel
</code>
<hr>
</td>
</table><pre><ul>
<li>void setOrigin(int x, int y)
<p></ul></pre><dl>
<a name="56900">
<dt><dd> sets the image origin to a given (x, y) position. The scrollbars are updated appropriately.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=2><em>Parameters</em>:
<p><td><code>x</code>
<p><td>The image <em>x</em> origin.
<p>
<tr valign=top><td><code>y</code>
<p><td>The image <em>y</em> origin.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>void setCenter(int x, int y)
<p></ul></pre><dl>
<a name="56911">
<dt><dd> sets the image center to a given (x, y) position. The scrollbars are updated appropriately.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=2><em>Parameters</em>:
<p><td><code>x</code>
<p><td>The image <em>x</em> center.
<p>
<tr valign=top><td><code>y</code>
<p><td>The image <em>y</em> center.
<p>

</Table>

</a><P></dl>
<a name="55352">
<h3>4.8.2	<img src="shared/space.gif">The ImageCanvas Class</h3>
</a>A canvas in Java is a rectangular area in which you draw. JAI extends the <code>java.awt.Canvas</code> class with the <code>ImageCanvas</code> class, which allows you to "draw" an image in the canvas. Like <code>Canvas</code>, the <code>ImageCanvas</code> class inherits most of its methods from <code>java.awt.Component</code>, allowing you to use the same event handlers for keyboard and mouse input.
<p>The <code>ImageCanvas</code> class is a simple output widget for a <code>RenderedImage</code> and can be used in any context that calls for a <code>Canvas</code>. The <code>ImageCanvas</code> class monitors resize and update events and automatically requests tiles from its source on demand. Any displayed area outside the image is displayed in gray.
<p>Use the constructor or the <code>set</code> method to include a <code>RenderedImage</code> in the canvas, then use the <code>setOrigin</code> method to set the position of the image within the canvas.
<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.widget.ImageCanvas
</code>
<hr>
</td>
</table><pre><ul>
<li>ImageCanvas(RenderedImage im, boolean drawBorder)
<p></ul></pre><dl>
<a name="55652">
<dt><dd> constructs an <code>ImageCanvas</code> to display a <code>RenderedImage</code>.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=2><em>Parameters</em>:
<p><td><code>im</code>
<p><td>A <code>RenderedImage</code> to be displayed.
<p>
<tr valign=top><td><code>drawBorder</code>
<p><td>True if a raised border is desired.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>ImageCanvas(java.awt.image.RenderedImage im)
<p></ul></pre><dl>
<a name="55689">
<dt><dd> constructs an <code>ImageCanvas</code> to display a <code>RenderedImage</code>.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td><em>Parameters</em>:
<p><td><code>im</code>
<p><td>A <code>RenderedImage</code> to be displayed.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>void set(RenderedImage im)
<p></ul></pre><dl>
<a name="57291">
<dt><dd> changes the source image to a new RenderedImage.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td><em>Parameters</em>:
<p><td><code>im</code>
<p><td>The new <code>RenderedImage</code> to be displayed.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>void paint(java.awt.Graphics g)
<p></ul></pre><dl>
<a name="57373">
<dt><dd> paint the image onto a <code>Graphics</code> object. The painting is performed tile-by-tile, and includes a gray region covering the unused portion of image tiles as well as the general background.
</a><P></dl>
<a name="80045">
<h3>4.8.3	<img src="shared/space.gif">Image Origin</h3>
</a>The origin of an image is set with the <code>ImageCanvas.setOrigin</code> method. The origin of an image is obtained with the <code>getXOrigin</code> and <code>getYOrigin</code> methods.
<p>Geometric operators are treated differently with respect to image origin control. See <a href="Geom-image-manip.doc.html#51140">Chapter &#32;8, "Geometric Image Manipulation</a>."
<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.widget.ImageCanvas
</code>
<hr>
</td>
</table><pre><ul>
<li>void setOrigin(int x, int y)
<p></ul></pre><dl>
<a name="80055">
<dt><dd> sets the origin of the image at <code>x,y</code>.
</a><P></dl>
<pre><ul>
<li>int getXOrigin()
<p></ul></pre><dl>
<a name="80057">
<dt><dd> returns the <em>x</em> coordinate of the image origin.
</a><P></dl>
<pre><ul>
<li>int getYOrigin()
<p></ul></pre><dl>
<a name="80059">
<dt><dd> returns the <em>y</em> coordinate of the image origin.
</a><P></dl>

<hr><br>
 
<center>
<a href="JAITOC.fm.html"><img src="shared/contents.gif" alt="Contents"></a> <a href="Programming-environ.doc.html"><img src="shared/previous.gif" alt="Previous"></a> <a href="Color.doc.html"><img src="shared/next.gif" alt="Next"></a> <p><font size=5><i>Programming in Java Advanced Imaging</i></font>
</center>
<br>
 
<sup>1</sup><a name="82022">
 Burt, P.J. and Adelson, E.H., "The Laplacian pyramid as a compact image code," <em>IEEE Transactions on Communications</em>, pp. 532-540, 1983.
</a>

<h5><a href="copyright.html">Copyright</a> &#169; 1999, Sun Microsystems, Inc.   All rights
reserved.</h5>


<!-- Last updated: Tue Nov 02 17:10:24 1999 -->
</blockquote>
</body>
</html>
