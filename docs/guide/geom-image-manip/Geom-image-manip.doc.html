<html><head><title>Geometric Image Manipulation</title></head>
<body bgcolor=#ffffff>
 
<center>
<a href="JAITOC.fm.html"><img src="shared/contents.gif" alt="Contents"></a> <a href="Image-enhance.doc.html"><img src="shared/previous.gif" alt="Previous"></a> <a href="Analysis.doc.html"><img src="shared/next.gif" alt="Next"></a> <p><font size=5><i>Programming in Java Advanced Imaging</i></font>
</center>
<br>
 
<center>
<a name="47227">
<table width=90% border=0><tr>
<td align=right><font size=3>C H A P T E R</font><font size=7><img src="shared/sm-space.gif">8</td></table>
</a></center><center>
<a name="51140">
<table width=90% border=0><tr><td align=right>
<hr size=7 noshade>
<font size=6>Geometric Image Manipulation</font></td></table>
</a></center><blockquote>
<p><br><br><br><P><font size=7><b>T</b></font>HIS chapter describes the basics of JAI's geometric image manipulation functions. The geometric image manipulation operators are all part of the <code>javax.media.operator</code> package.
<p><a name="50856">
<h2>8.1	<img src="shared/space.gif">Introduction</h2>
</a>The JAI geometric image manipulation functions are:
<p><ul>
<li>Geometric transformation (<code>Translate</code>, <code>Scale</code>, <code>Rotate</code>, and <code>Affine</code>)<p></ul><ul>
<li>Perspective transformation (<code>PerspectiveTransform</code>)<p></ul><ul>
<li>Transposing (<code>Transpose</code>)<p></ul><ul>
<li>Shearing (<code>Shear</code>)<p></ul><ul>
<li>Warping (<code>Warp</code>, <code>WarpAffine</code>, <code>WarpPerspective</code>, <code>WarpPolynomial</code>, <code>WarpGeneralPolynomial</code>, <code>WarpQuadratic</code>, and <code>WarpOpImage</code>)<p></ul>Most of these geometric functions require an interpolation argument, so this chapter begins with a discussion of interpolation.
<p><a name="51290">
<h2>8.2	<img src="shared/space.gif">Interpolation</h2>
</a>Several geometric image operations, such as <code>Affine</code>, <code>Rotate</code>, <code>Scale</code>, <code>Shear</code>, <code>Translate</code>, and <code>Warp</code>, use a geometric transformation to compute the coordinate of a source image point for each destination image pixel. In most cases, the destination pixel does not lie at a source pixel location, but rather lands somewhere between neighboring pixels. The estimated value of each pixel is set in a process called interpolation or <em>image resampling</em>.
<p>Resampling is the action of computing a pixel value at a possibly non-integral position of an image. The image defines pixel values at integer lattice points, and it is up to the resampler to produce a reasonable value for positions not falling on the lattice. A number of techniques are used in practice, the most common being the following:
<p><ul>
<li>Nearest-neighbor, which simply takes the value of the closest lattice point<p></ul><ul>
<li>Bilinear, which interpolates linearly between the four closest lattice points<p></ul><ul>
<li>Bicubic, which applies a piecewise polynomial function to a 4 x 4 neighborhood of nearby points<p></ul>The area over which a resampling function needs to be computed is referred to as its <em>support</em>; thus the standard resampling functions have supports of 1, 4, and 16 pixels respectively. Mathematically, the ideal resampling function for a band-limited image (one containing no energy above a given frequency) is the sinc function, equal to sin(x)/x. This has practical limitations, in particular its infinite support, which lead to the use of the standard approximations described above.
<p>In interpolation, each pixel in a destination image is located with integer coordinates at a distinct point <em>D</em> in the image plane. The geometric transform <em>T</em> identifies each destination pixel with a corresponding point <em>S</em> in the source image. Thus, <em>D</em> is the point that <em>T</em> maps to <em>S</em>. In general, <em>S</em> doesn't correspond to a single source pixel; that is, it doesn't have integer coordinates. Therefore, the value assigned to the pixel <em>D</em> must be computed as an interpolated combination of the pixel values closest to <em>S</em> in the source image.
<p>For most geometric transformations, you must specify the interpolation method to be used in calculating destination pixel values. <a href="Geom-image-manip.doc.html#65017">Table &#32;8-1</a> lists the names used to call the interpolation methods.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b><a name="65017">
<i>Table 8-1	 </i><img src="shared/sm-blank.gif" border=0> Interpolation Types &#32;
</a></b></font></caption>
<tr valign=top><th><a name="65021">
Name
</a><th><a name="65023">
Description
</a>
<tr valign=top><td><a name="65025">
INTERP_NEAREST</a><br><td><a name="65027">
Nearest-neighbor interpolation. Assigns to point D in the destination image the value of the pixel nearest S in the source image. See <a href="Geom-image-manip.doc.html#70504">Section &#32;8.2.1, "Nearest-neighbor Interpolation</a>."</a><br>
<tr valign=top><td><a name="65029">
INTERP_BILINEAR</a><br><td><a name="65031">
Bilinear interpolation. Assigns to Point D in the destination a value that is a bilinear function of the four pixels nearest S in the source image. See <a href="Geom-image-manip.doc.html#55403">Section &#32;8.2.2, "Bilinear Interpolation</a>."</a><br>
<tr valign=top><td><a name="65033">
INTERP_BICUBIC</a><br><td><a name="65035">
Bicubic interpolation. Assigns to point D in the destination image a value that is a bicubic function of the 16 pixels nearest S in the source image.<a href="Geom-image-manip.doc.html#55431">Section &#32;8.2.3, "Bicubic Interpolation</a>."</a><br>
<tr valign=top><td><a name="65037">
INTERP_BICUBIC2</a><br><td><a name="65039">
Bicubic2 interpolation. Similar to Bicubic, but uses a different polynomial function. See <a href="Geom-image-manip.doc.html#55447">Section &#32;8.2.4, "Bicubic2 Interpolation</a>."</a><br>

</Table>

<p>Occasionally, these four options do not provide sufficient quality for a specific operation and a more general form of interpolation is called for. The more general form of interpolation, called <em>table interpolation</em> uses tables to store the interpolation kernels. See <a href="Geom-image-manip.doc.html#55492">Section &#32;8.2.5, "Table Interpolation</a>."
<p>Other interpolation functions may be required to solve problems other than the resampling of band-limited image data. When shrinking an image, it is common to use a function that combines area averaging with resampling to remove undesirable high frequencies as part of the interpolation process. Other application areas may use interpolation functions that operate under other assumptions about image data, such as taking the maximum value of a 2 x 2 neighborhood. The <code>Interpolation</code> class provides a framework in which a variety of interpolation schemes may be expressed.
<p>Many Interpolations are separable, that is, they may be equivalently rewritten as a horizontal interpolation followed by a vertical one (or vice versa). In practice, some precision may be lost by the rounding and truncation that takes place between the passes. The <code>Interpolation</code> class assumes separability and implements all vertical interpolation methods in terms of corresponding horizontal methods, and defines <code>isSeparable</code> to return true. A subclass may override these methods to provide distinct implementations of horizontal and vertical interpolation. Some subclasses may implement the two-dimensional interpolation methods directly, yielding more precise results, while others may implement these using a two-pass approach.
<p>When interpolations that require padding the source such as Bilinear or Bicubic interpolation are specified, the boundary of the source image needs to be extended such that it has the extra pixels needed to compute all the destination pixels. This extension is performed via the <code>BorderExtender</code> class. The type of border extension can be specified as a <code>RenderingHint</code> to the <code>JAI.create</code> method. If no border extension type is provided, a default extension of <code>BorderExtender.BORDER_COPY</code> will be used to perform the extension. See <a href="Programming-environ.doc.html#55991">Section &#32;3.7.3, "Rendering Hints</a>."
<p><a href="Geom-image-manip.doc.html#69404">Listing &#32;8-1</a> shows a code sample for a <code>rotate</code> operation. First, the type of interpolation is specified (<code>INTERP_NEAREST</code> in this example) using the <code>Interpolation.create</code> method. Next, a parameter block is created and the interpolation method is added to the parameter block, as are all the other parameters required by the operation. Finally, a <code>rotate</code> operation is created with the specified parameter block.<p>
<caption><font size=-1><b>
<a name="69404">
<center><font size=-1><b><i>Listing 8-1	</i><img src="shared/sm-blank.gif" border=0> Example Using Nearest-neighbor Interpolation</b></font></center>
</a><p>
</b></font></caption>
<hr>
<tr valign=top><td><pre>     // Specify the interpolation method to be used
     <strong><kbd>interp = Interpolation.create(Interpolation.INTERP_NEAREST);
</kbd></strong></pre>
<tr valign=top><td><pre>     // Create the parameter block and add the interpolation to it
     ParameterBlock pb = new ParameterBlock();
     pb.addSource(im);         // The source image
     pb.add(0.0F);             // The x origin to rotate about
     pb.add(0.0F);             // The y origin to rotate about
     pb.add(theta);            // The rotation angle in radians
     <strong><kbd>pb.add(interp);           // The interpolation method
</kbd></strong></pre>
<tr valign=top><td><pre>     // Create the rotation operation and include the parameter
     // block
     RenderedOp op JAI.create("rotate", pb, null);
</pre>

<hr>

<p>The <code>Interpolation</code> class provides methods for the most common cases of 2 x 1, 1 x 2, 4 x 1, 1 x 4, 2 x 2, and 4 x 4 input grids, some of which are shown in <a href="Geom-image-manip.doc.html#66155">Figure &#32;8-1</a>. These methods are defined in the superclass (<code>Interpolation</code>) to package their arguments into arrays and forward the call to the array versions, to simplify implementation. These methods should be called only on <code>Interpolation</code> objects with the correct width and height. In other words, an implementor of an <code>Interpolation</code> subclass may implement <code>interpolateH(int s0, int s1, int xfrac)</code>, assuming that the interpolation width is in fact equal to 2, and does not need to enforce this constraint.
<p><a name="66153">
 <hr>
<center><img src="Geom-image-manip.doc.anc2.gif"></center><hr>

</a>
<a name="66155">
<center><font size=-1><b><i>Figure 8-1	</i><img src="shared/sm-blank.gif" border=0> Interpolation Samples</b></font></center>
</a><p>
Another possible source of inefficiency is the specification of the subsample position. When interpolating integral image data, JAI uses a fixed-point subsample position specification, that is, a number between 0 and (2n - 1) for some small value of <em>n</em>. The value of <em>n</em> in the horizontal and vertical directions may be obtained by calling the <code>getSubsampleBitsH</code> and <code>getSubsampleBitsV</code> methods. In general, code that makes use of an externally-provided <code>Interpolation</code> object must query that object to determine its desired positional precision.
<p>For <code>float</code> and <code>double</code> images, JAI uses a <code>float</code> between 0.0F and 1.0F (not including 1.0F) as a positional specifier in the interest of greater accuracy.
<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.Interpolation
</code>
<hr>
</td>
</table><pre><ul>
<li>static Interpolation getInstance(int type)
<p></ul></pre><dl>
<a name="65047">
<dt><dd> creates an interpolation of one of the standard types, where <code>type</code> is one of <code>INTERP_NEAREST</code>, <code>INTERP_BILINEAR</code>, <code>INTERP_BICUBIC</code>, or <code>INTERP_BICUBIC_2</code>.
</a><P></dl>
<pre><ul>
<li>int interpolate(int[][] samples, int xfrac, int yfrac)
<p></ul></pre><dl>
<a name="65076">
<dt><dd> performs interpolation on a two-dimensional array of integral samples. By default, this is implemented using a two-pass approach.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=3><em>Parameters</em>:
<p><td><code>samples</code>
<p><td>A two-dimensional array of ints.
<p>
<tr valign=top><td><code>xfrac</code>
<p><td>The <em>x</em> subsample position, multiplied by 2<sup>subsampleBits</sup>.
<p>
<tr valign=top><td><code>yfrac</code>
<p><td>The <em>y</em> subsample position, multiplied by 2<sup>subsampleBits</sup>.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>float interpolate(float[][] samples, float xfrac, float yfrac)
<p></ul></pre><dl>
<a name="65370">
<dt><dd> performs interpolation on a two-dimensional array of floating-point samples. This is the same as the above method, only using float values instead of ints.
</a><P></dl>
<pre><ul>
<li>double interpolate(double[][] samples, float xfrac, 
       float &#32;yfrac)
<p></ul></pre><dl>
<a name="69291">
<dt><dd> Performs interpolation on a 2-dimensional array of double samples.
</a><P></dl>
<pre><ul>
<li>int interpolate(int s00, int s01, int s10, int s11, int xfrac, 
       int yfrac)
<p></ul></pre><dl>
<a name="65163">
<dt><dd> performs interpolation on a 2 x 2 grid of integral samples. It should only be called if width == height == 2 and leftPadding == topPadding == 0.
</a><P><a name="65243">
<dt><dd> The <code>s00</code>, <code>s01</code>, <code>s10</code>, and <code>s11</code> parameters are the sample values (see the 2 x 2 grid illustration in <a href="Geom-image-manip.doc.html#66155">Figure &#32;8-1</a>).
</a><P></dl>
<pre><ul>
<li>float interpolate(float s00, float s01, float s10, float s11, 
       float xfrac, float yfrac)
<p></ul></pre><dl>
<a name="65402">
<dt><dd> performs interpolation on a 2 x 2 grid of integral samples. This is the same as the above method, only using float values instead of ints.
</a><P></dl>
<pre><ul>
<li>double interpolate(double s00, double s01, double s10, double 
       s11, float xfrac, float yfrac)
<p></ul></pre><dl>
<a name="69315">
<dt><dd> performs interpolation on a 2 x 2 grid of double samples.
</a><P></dl>
<pre><ul>
<li>int interpolate(int s__, int s_0, int s_1, int s_2, int s0_, 
       int &#32;s00, int s01, int s02, int s1_, int s10, int s11, 
       int &#32;s12, int s2_, int s20, int s21, int s22, int xfrac, 
       int &#32;yfrac)
<p></ul></pre><dl>
<a name="65317">
<dt><dd> performs interpolation on a 4 x 4 grid of integral samples. It should only be called if width == height == 4 and leftPadding == topPadding == 1.
</a><P><a name="65331">
<dt><dd> The <code>s__</code>, <code>through</code> <code>s22</code> parameters are the sample values (see the 4 x 4 grid illustration in <a href="Geom-image-manip.doc.html#66155">Figure &#32;8-1</a>).
</a><P></dl>
<pre><ul>
<li>float interpolate(float s__, float s_0, float s_1, float s_2, 
       float s0_, float s00, float s01, float s02, float s1_, 
       float &#32;s10, float s11, float s12, float s2_, float s20, 
       float &#32;s21, float s22, float xfrac, float yfrac)
<p></ul></pre><dl>
<a name="65477">
<dt><dd> performs interpolation on a 4 x 4 grid of integral samples. This is the same as the above method, only using float values instead of ints.
</a><P></dl>
<pre><ul>
<li>abstract int getSubsampleBitsH()
<p></ul></pre><dl>
<a name="70501">
<dt><dd> returns the number of bits used to index subsample positions in the horizontal direction. All integral <code>xfrac</code> parameters should be in the range of 0 to 2<sup>(getSubsampleBitsH)</sup> - 1.
</a><P></dl>
<pre><ul>
<li>int getSubsampleBitsV()
<p></ul></pre><dl>
<a name="70518">
<dt><dd> returns the number of bits used to index subsample positions in the vertical direction. All integral <code>yfrac</code> parameters should be in the range of 0 to 2<sup>(getSubsampleBitsV)</sup> - 1.
</a><P></dl>
<a name="70504">
<h3>8.2.1	<img src="shared/space.gif">Nearest-neighbor Interpolation</h3>
</a>Nearest-neighbor interpolation, also known as zero-order interpolation, is the fastest interpolation method, though it can produce image artifacts called <em>jaggies</em> or <em>aliasing error</em>. Jaggies are image artifacts in which the straight edges of objects appear to be rough or jagged.
<p>Nearest-neighbor interpolation simply assigns to point <em>D</em> in the destination image the value of the pixel nearest <em>S</em> in the source image.
<p>Neighborhoods of sizes 2 x 1, 1 x 2, 2 x 2, 4 x 1, 1 x 4, 4 x 4, N x 1, and 1 x N, that is, all the <code>interpolate()</code> methods defined in the <code>Interpolation</code> class, are supported in the interest of simplifying code that handles a number of types of interpolation. In each case, the central sample is returned and the rest are ignored.
<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.InterpolationNearest
</code>
<hr>
</td>
</table><pre><ul>
<li>InterpolationNearest()
<p></ul></pre><dl>
<a name="73430">
<dt><dd> constructs an <code>InterpolationNearest</code>. The return value of <code>getSubsampleBitsH()</code> and <code>getSubsampleBitsV()</code> will be 0.
</a><P></dl>
<a name="55403">
<h3>8.2.2	<img src="shared/space.gif">Bilinear Interpolation</h3>
</a>Bilinear interpolation, also known as first-order interpolation, linearly interpolates pixels along each row of the source image, then interpolates along the columns. Bilinear interpolation assigns to Point <em>D</em> in the destination a value that is a bilinear function of the four pixels nearest <em>S</em> in the source image.
<p>Bilinear interpolation results in an improvement in image quality over nearest-neighbor interpolation, but may still result in less-than-desirable smoothing effects.
<p>Bilinear interpolation requires a neighborhood extending one pixel to the right and below the central sample. If the subsample position is given by (<em>u</em>, <em>v</em>), the resampled pixel value will be:
<p><dl>
<a name="55410">
<dt><dd> <img src="Geom-image-manip.doc.anc4.gif">
</a><P></dl>
<table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.InterpolationBilinear
</code>
<hr>
</td>
</table><pre><ul>
<li>InterpolationBilinear(int subsampleBits)
<p></ul></pre><dl>
<a name="55414">
<dt><dd> constructs an <code>InterpolationBilinear</code> object with a given subsample precision, in bits.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td><em>Parameters</em>:
<p><td><code>subsampleBits</code>
<p><td>The subsample precision.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>InterpolationBilinear()
<p></ul></pre><dl>
<a name="55423">
<dt><dd> constructs an <code>InterpolationBilinear</code> object with the default subsample precision.
</a><P></dl>
<a name="55431">
<h3>8.2.3	<img src="shared/space.gif">Bicubic Interpolation</h3>
</a>Bicubic interpolation reduces resampling artifacts even further by using the 16 nearest neighbors in the interpolation and by using bicubic waveforms rather than the linear waveforms used in bilinear interpolation. Bicubic interpolation preserves the fine detail present in the source image at the expense of the additional time it takes to perform the interpolation.
<p>The bicubic interpolation routine assigns to point <em>D</em> in the destination image a value that is a bicubic function of the 16 pixels nearest <em>S</em> in the source image.
<p>Bicubic interpolation performs interpolation using the following piecewise cubic polynomial:
<p><dl>
<a name="55445">
<dt><dd> <img src="Geom-image-manip.doc.anc1.gif">
</a><P></dl>
Bicubic interpolation requires a neighborhood extending one sample to the left of and above the central sample, and two samples to the right of and below the central sample.
<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.InterpolationBicubic
</code>
<hr>
</td>
</table><pre><ul>
<li>InterpolationBicubic(int subsampleBits)
<p></ul></pre><dl>
<a name="60066">
<dt><dd> constructs an <code>InterpolationBicubic</code> with a given subsample precision, in bits.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td><em>Parameters</em>:
<p><td><code>subsampleBits</code>
<p><td>The subsample precision.
<p>

</Table>

</a><P></dl>
<a name="55447">
<h3>8.2.4	<img src="shared/space.gif">Bicubic2 Interpolation</h3>
</a>Bicubic2 interpolation is basically the same as bicubic interpolation, but uses a different polynomial function. Bicubic2 interpolation uses the following piecewise cubic polynomial:
<p><dl>
<a name="55459">
<dt><dd> <img src="Geom-image-manip.doc.anc3.gif">
</a><P></dl>
Bicubic interpolation requires a neighborhood extending one sample to the left of and above the central sample, and two samples to the right of and below the central sample.
<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.InterpolationBicubic2
</code>
<hr>
</td>
</table><pre><ul>
<li>InterpolationBicubic2(int subsampleBits)
<p></ul></pre><dl>
<a name="55480">
<dt><dd> constructs an <code>InterpolationBicubic2</code> with a given subsample precision, in bits.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td><em>Parameters</em>:
<p><td><code>subsampleBits</code>
<p><td>The subsample precision.
<p>

</Table>

</a><P></dl>
<a name="55492">
<h3>8.2.5	<img src="shared/space.gif">Table Interpolation</h3>
</a>The previous-described types of interpolation, nearest-neighbor, bilinear, bicubic, and bicubic2, base the interpolation values on a relatively few pixels: one (nearest-neighbor), four (bilinear), or 16 (bicubic and bicubic2). Occasionally, these options don't provide sufficient quality for a specific operation and a general form of interpolation is called for. Table interpolation uses tables to store the interpolation kernels. The set of subpixel positions is broken up into a fixed number of "bins" and a distinct kernel is used for each bin. The number of bins must be a power of two.
<p>An <code>InterpolationTable</code> defines a separable interpolation, with a separate set of kernels for the horizontal and vertical dimensions. The number of bins within each kernel may vary between the two dimensions. The horizontal and vertical kernels may be unique or the same. That is, you can either construct two separate kernels or use the same kernel for both the horizontal and vertical interpolation.
<p>The kernels are stored in both floating- and fixed-point form. The fixed point representation has a user-specified fractional precision. You must specify an appropriate level of precision that will not cause overflow when accumulating the results of a convolution against a set of source pixels, using 32-bit integer arithmetic.
<p>To use table interpolation, create an <code>InterpolationTable</code> with either identical horizontal and vertical resampling kernels or with different horizontal and vertical resampling kernels. The table forms the kernels used for the interpolation.
<p>During a table interpolation operation, the key value of the resampling kernel, generally the center value, is laid over the source image pixel to be processed. The other kernel values lie over neighboring pixels much like a conventional M &#32;x &#32;N kernel operation. Each source image pixel that is covered by the kernel is then multiplied by the kernel value that lies over it. The multiplication products are then summed together and this sum becomes the pixel value in the destination.
<p>To save memory space and computation time, the table interpolation operation does not use a conventional M &#32;x &#32;N kernel. Instead, the operation uses separate horizontal and vertical vector arrays (essentially, M &#32;x &#32;1 and N &#32;x &#32;1) to calculate the same values that a M &#32;x &#32;N kernel would calculate. The vector arrays allow you to provide fewer data elements for the kernel values. This is particularly significant for large tables with many subsamples.
<p>The basic format for the <code>InterpolationTable</code> constructor is:
<p><pre>     InterpolationTable(int leftPadding, int topPadding, int width,
                        int height, int subsampleBitsH,
                        int subsampleBitsV, int precisionBits,
                        float[] dataH, float[] dataV)
</pre>The parameters to the constructor are described in the following paragraphs.
<p><a name="65628">
<h4>8.2.5.1	<img src="shared/space.gif">Padding</h4>
</a>The <code>leftPadding</code> and <code>topPadding</code> parameters define the location of the central sample or key value, relative to the left and top of the horizontal and vertical kernels, respectively. These parameters actually define the number of samples to the left of or above the central sample, as shown in <a href="Geom-image-manip.doc.html#65694">Figure &#32;8-2</a>.
<p><a name="65693">
 <hr>
<center><img src="Geom-image-manip.doc.anc20.gif"></center><hr>

</a>
<a name="65694">
<center><font size=-1><b><i>Figure 8-2	</i><img src="shared/sm-blank.gif" border=0> Table Interpolation Padding</b></font></center>
</a><p>
<a name="65762">
<h4>8.2.5.2	<img src="shared/space.gif">Width and Height</h4>
</a>The <code>width</code> and <code>height</code> parameters define the size of the horizontal and vertical kernels, respectively. These parameters specify the number of data elements in each subsample of the kernel. The horizontal and vertical tables can have different kernel sizes. For the two examples shown in <a href="Geom-image-manip.doc.html#65694">Figure &#32;8-2</a>, the <code>width</code> parameter would be 7, the <code>height</code> parameter would be 5.
<p>The <code>getWidth</code> and <code>getHeight</code> methods return the number of samples required for horizontal and vertical resampling, respectively.
<p><a name="65830">
<h4>8.2.5.3	<img src="shared/space.gif">Subsample Bits</h4>
</a>The <code>subsampleBitsH</code> and <code>subsampleBitsV</code> parameters define the number of bins used to describe the horizontal and vertical subpixel positions, respectively. The number of bins must be a power of two, so the values are integers expressed as the log<sub>2</sub> of the number of horizontal or vertical subsample positions, respectively. The value <code>subsampleBitsH</code> = 1 defines two subsamples per horizontal sample, <code>subsampleBitsH</code> = 2 defines four subsamples per sample, and so on.
<p>For each subsample, you must define separate kernel data. Typically, the kernel values for each subsample are weighted according to the subsample location's proximity to the pixels used in the calculation. The closer a pixel is to the subsample location, the more weight it carries in the kernel.
<p><a href="Geom-image-manip.doc.html#70742">Figure &#32;8-3</a> shows how the interpolation tables are used to determine which kernel applies to a particular subsample location. The figure shows a subsample of 4 in both the horizontal and vertical directions.
<p>Typically, the kernel values for each subsample are weighted according to the subsample location's proximity to the pixels used in the calculation. The closer a pixel is to the subsample location, the more weight it carries in the kernel.
<p><a name="70741">
 <hr>
<center><img src="Geom-image-manip.doc.anc37.gif"></center><hr>

</a>
<a name="70742">
<center><font size=-1><b><i>Figure 8-3	</i><img src="shared/sm-blank.gif" border=0> Table Interpolation Backwards Mapping</b></font></center>
</a><p>
<a name="73514">
<h4>8.2.5.4	<img src="shared/space.gif">Precision</h4>
</a>The <code>precisionBits</code> parameter defines the number of fractional bits to be used when resampling integral sample values. The same precision value is used for both horizontal and vertical resampling. It is important to choose an appropriate level of precision that will not cause overflow when accumulating the results of a convolution against a set of source pixels, using 32-bit integer arithmetic.
<p><a name="65837">
<h4>8.2.5.5	<img src="shared/space.gif">Kernel Data</h4>
</a>The kernel data for each table is an array of floating point numbers. The <code>dataH</code> and <code>dataV</code> parameters specify the floating-point data values for the horizontal and vertical kernels, respectively. The number of data elements in the kernel is:
<p><dl>
<a name="65891">
<dt><dd> <code>width</code> x 2<sup>subsampleBitsH</sup> for <code>dataH</code>
</a><P><a name="65892">
<dt><dd> <code>height</code> x 2<sup>subsampleBitsV</sup> for <code>dataV</code>
</a><P></dl>
For a two-element kernel size with eight subsample bins (<code>subsampleBits</code> = 4), you need to define an array of 16 floating point values. The first two values define the kernel for the first subsample, the second two values define the kernel for the second subsample, and so on. For example:<p>
<caption><font size=-1><b></b></font></caption>
<hr>
<tr valign=top><td><pre>     float[] kernelData = {1.0,    0.0,
                           0.875,  0.125,    // 7/8,  1/8
                           0.75,   0.25,     // 6/8,  2/8
                           0.625,  0.375,    // 5/8,  3/8
                           0.5,    0.5,      // 4/8,  4/8
                           0.375,  0.625,    // 3/8,  5/8
                           0.25,   0.75,     // 2/8,  6/8
                           0.125,  0.875 };  // 1/8,  7/8
</pre>

<hr>

<p>The above example creates a bilinear interpolation table with eight subsamples. The kernel values indicate how much influence the source image pixels will have on the destination value. A kernel value of 1 indicates that a source pixel completely determines the value of the destination pixel. A kernel value of 0 indicates that the source pixel has no influence on the destination value.
<p>To preserve the source image's intensity in the destination image, the sum of the data values in each interpolation kernel should equal one. If the kernel values sum to greater than one, the destination image's intensity will be increased. Conversely, if the kernel values sum to less than one, the destination image's intensity will be decreased.
<p>If a value of <code>null</code> is given for <code>dataV</code>, the <code>dataH</code> table data is used for vertical interpolation as well, and the <code>topPadding</code>, <code>height</code>, and <code>subsampleBitsV</code> parameters are ignored.
<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.InterpolationTable
</code>
<hr>
</td>
</table><pre><ul>
<li>InterpolationTable(int padding, int width, int subsampleBits, 
       int precisionBits, float[] data)
<p></ul></pre><dl>
<a name="70927">
<dt><dd> constructs an <code>InterpolationTable</code> with identical horizontal and vertical resampling kernels.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=5><em>Parameters</em>:
<p><td><code>padding</code>
<p><td>The number of samples to the left or above the central sample to be used during resampling.
<p>
<tr valign=top><td><code>width</code>
<p><td>The width or height of a resampling kernel.
<p>
<tr valign=top><td><code>subsample-Bits</code>
<p><td>The log<sub>2</sub> of the number of subsample bins.
<p>
<tr valign=top><td><code>precision-Bits</code>
<p><td>The number of bits of fractional precision to be used when resampling integral sample values.
<p>
<tr valign=top><td><code>data</code>
<p><td>The kernel entries, as a float array of <code>width</code>*2<sup>subsampleBitsH</sup> entries.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>InterpolationTable(int padding, int width, int subsampleBits, 
       int precisionBits, double[] data)
<p></ul></pre><dl>
<a name="71047">
<dt><dd> constructs an InterpolationTable with identical horizontal and vertical resampling kernels.
</a><P></dl>
<pre><ul>
<li>InterpolationTable(int padding, int width, int subsampleBits, 
       int precisionBits, int[] data)
<p></ul></pre><dl>
<a name="73456">
<dt><dd> Constructs an InterpolationTable with identical horizontal and vertical resampling kernels.
</a><P></dl>
<pre><ul>
<li>InterpolationTable(int leftPadding, int topPadding, int width, 
       int height, int subsampleBitsH, int subsampleBitsV, 
       int &#32;precisionBits, float[] dataH, float[] dataV)
<p></ul></pre><dl>
<a name="65594">
<dt><dd> constructs an <code>InterpolationTable</code> with specified horizontal and vertical extents (support), number of horizontal and vertical bins, fixed-point fractional precision, and kernel entries. The kernel data values are organized as 2<sup>subsampleBits</sup> entries each containing <code>width</code> floats.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td><em>Parameters</em>:
<p><td><code>leftPadding</code>
<p><td>The number of samples to the left of the central sample to be used during horizontal resampling.
<p>
<tr valign=top><td>
<p><td><code>topPadding</code>
<p><td>The number of samples above the central sample to be used during vertical resampling.
<p>
<tr valign=top><td>
<p><td><code>width</code>
<p><td>The width of a horizontal resampling kernel.
<p>
<tr valign=top><td>
<p><td><code>height</code>
<p><td>The height of a vertical resampling kernel. Ignored if <code>dataV</code> is null.
<p>
<tr valign=top><td>
<p><td><code>subsample-BitsH</code>
<p><td>The log<sub>2</sub> of the number of horizontal subsample bins.
<p>
<tr valign=top><td>
<p><td><code>subsample-BitsV</code>
<p><td>The log<sub>2</sub> of the number of vertical subsample bins. Ignored if <code>dataV</code> is null.
<p>
<tr valign=top><td>
<p><td><code>precision-Bits</code>
<p><td>The number of bits of fractional precision to be used when resampling integral sample values. The same value is used for both horizontal and vertical resampling.
<p>
<tr valign=top><td>
<p><td><code>dataH</code>
<p><td>The horizontal table entries, as a float array of 2<sup>subsampleBitsH</sup> entries each of length <code>width</code>.
<p>
<tr valign=top><td>
<p><td><code>dataV</code>
<p><td>The vertical table entries, as a float array of 2<sup>subsampleBitsV</sup> entries each of length <code>height</code>, or null. If null, the <code>dataH</code> table is used for vertical interpolation as well and the <code>topPadding</code>, <code>height</code>, and <code>subsampleBitsV</code> parameters are ignored.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>InterpolationTable(int leftPadding, int topPadding, int width, 
       int height, int subsampleBitsH, int subsampleBitsV, 
       int &#32;precisionBits, double[] dataH, double[] dataV)
<p></ul></pre><dl>
<a name="71012">
<dt><dd> constructs an <code>InterpolationTable</code> with specified horizontal and vertical extents (support), number of horizontal and vertical bins, fixed-point fractional precision, and kernel entries.
</a><P></dl>
<pre><ul>
<li>InterpolationTable(int leftPadding, int topPadding, int width, 
       int height, int subsampleBitsH, int subsampleBitsV, 
       int &#32;precisionBits, int[] dataH, int[] dataV)
<p></ul></pre><dl>
<a name="73497">
<dt><dd> constructs an InterpolationTable with specified horizontal and vertical extents (support), number of horizontal and vertical bins, fixed-point fractional precision, and int kernel entries.
</a><P></dl>
<a name="71057">
<h4>8.2.5.6	<img src="shared/space.gif">Additional Interpolation Table-related Methods</h4>
</a>The <code>InterpolationTable</code> class provides several methods for retrieving an interpolation table's kernel data values, subsample size, and precision.
<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.InterpolationTable
</code>
<hr>
</td>
</table><pre><ul>
<li>int getSubsampleBitsH()
<p></ul></pre><dl>
<a name="71075">
<dt><dd> returns the number of bits used to index subsample positions in the horizontal direction.
</a><P></dl>
<pre><ul>
<li>int getSubsampleBitsV()
<p></ul></pre><dl>
<a name="71105">
<dt><dd> returns the number of bits used to index subsample positions in the vertical direction.
</a><P></dl>
<pre><ul>
<li>int getPrecisionBits()
<p></ul></pre><dl>
<a name="71132">
<dt><dd> returns the number of bits of fractional precision used to store the fixed-point table entries.
</a><P></dl>
<pre><ul>
<li>int getLeftPadding()
<p></ul></pre><dl>
<a name="71148">
<dt><dd> returns the number of bits of fractional precision used to store the fixed-point table entries.
</a><P></dl>
<pre><ul>
<li>int getTopPadding()
<p></ul></pre><dl>
<a name="71163">
<dt><dd> returns the number of samples required above the center.
</a><P></dl>
<pre><ul>
<li>int getWidth()
<p></ul></pre><dl>
<a name="71173">
<dt><dd> returns the number of samples required for horizontal resampling.
</a><P></dl>
<pre><ul>
<li>int getHeight()
<p></ul></pre><dl>
<a name="71187">
<dt><dd> returns the number of samples required for vertical resampling.
</a><P></dl>
<pre><ul>
<li>int[] getHorizontalTableData()
<p></ul></pre><dl>
<a name="71199">
<dt><dd> returns the integer (fixed-point) horizontal table data.
</a><P></dl>
<pre><ul>
<li>int[] getVerticalTableData()
<p></ul></pre><dl>
<a name="71227">
<dt><dd> returns the integer (fixed-point) vertical table data.
</a><P></dl>
<pre><ul>
<li>float[] getHorizontalTableDataFloat()
<p></ul></pre><dl>
<a name="71243">
<dt><dd> returns the floating-point horizontal table data.
</a><P></dl>
<pre><ul>
<li>float[] getVerticalTableDataFloat()
<p></ul></pre><dl>
<a name="71257">
<dt><dd> returns the floating-point vertical table data.
</a><P></dl>
<pre><ul>
<li>double[] getHorizontalTableDataDouble()
<p></ul></pre><dl>
<a name="71271">
<dt><dd> returns the double horizontal table data.
</a><P></dl>
<pre><ul>
<li>double[] getVerticalTableDataDouble()
<p></ul></pre><dl>
<a name="71281">
<dt><dd> returns the double vertical table data.
</a><P></dl>
<a name="56707">
<h2>8.3	<img src="shared/space.gif">Geometric Transformation</h2>
</a>Geometric transformations provide the ability to reposition pixels within an image. Pixels may be relocated from their (<em>x</em>,<em>y</em>) spatial coordinates in the source image to new coordinates in the destination. Geometric transformations are used, for example, to move (translate), rotate, and scale the geometry of an image. A general type of geometric transformation, warp, is discussed later in this chapter (see <a href="Geom-image-manip.doc.html#53798">Section &#32;8.7, "Warping</a>").
<p>Geometric transformations are used to register multiple images, correct geometric distortions introduced in the image acquisition process, or to add visual effects. The geometric transformation operations discussed here include:
<p><ul>
<li>Translation (<code>Translate</code>) - moves an image up, down, left, or right<p></ul><ul>
<li>Scaling (<code>Scale</code>) - enlarges or shrinks an image<p></ul><ul>
<li>Rotation (<code>Rotate</code>) - rotates an image about a given point<p></ul><ul>
<li>Affine (<code>Affine</code>) - includes translation, scaling, and rotation in one operation<p></ul>All transformation operations are performed by moving pixel values from their original spatial coordinates to new coordinates in the destination image. Every pixel in the source image is passed through this transformation, creating a geometrically-transformed output pixel location. Each pixel of the source image is transformed, pixel by pixel, to its new location in the destination image.
<p>With a very few exceptions, all transformations result in some output pixel locations being missed because no input pixels were transformed there. The missed locations will be devoid of any pixel values and result in a black hole in the destination image. To overcome this problem, intermediate pixel values are estimated through interpolation (See <a href="Geom-image-manip.doc.html#51290">"Interpolation" on page 249</a>). One of four <code>interpolation</code> methods may be selected:<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="64125">
interpolation Methods
</a><th><a name="64127">
Description
</a>
<tr valign=top><td><a name="64129">
INTERP_NEAREST</a><br><td><a name="64131">
Use nearest-neighbor interpolation</a><br>
<tr valign=top><td><a name="64133">
INTERP_BILINEAR</a><br><td><a name="64135">
Use bilinear interpolation</a><br>
<tr valign=top><td><a name="64137">
INTERP_BICUBIC</a><br><td><a name="64139">
Use bicubic interpolation</a><br>
<tr valign=top><td><a name="64141">
INTERP_BICUBIC2</a><br><td><a name="64143">
Use bicubic2 interpolation (uses a different polynomial function)</a><br>

</Table>

<p><a name="60866">
<h3>8.3.1	<img src="shared/space.gif">Translation Transformation</h3>
</a>Image translation is the spatial shifting of an image up, down, left, or right. The relationships between the source and destination image coordinates are given by the following equation:
<p>
<p>
<a name="60873">
<ul><table>
<tr><td width=430><img src="Geom-image-manip.doc.anc.gif"> </td>
<td>(8.1)</td></tr>
</table></ul>
</a>
<dl>
<a name="60874">
<dt><dd> where:
</a><P><dl>
<a name="60875">
<dt><dd> <em>x</em><sub>D</sub> and <em>y</em><sub>D</sub> are the integer pixel coordinates of the destination image
</a><P><a name="60876">
<dt><dd> <em>t</em><sub>x</sub> and <em>t</em><sub>y</sub> are the translation values
</a><P><a name="60877">
<dt><dd> <em>x</em>'S and <em>y</em>'S denote the source image point from which the pixel estimate is computed.
</a><P></dl>
</dl>
Translation is often used to register multiple images geometrically. The translation is often carried out to align the images before performing a combination operation, such as image addition, subtraction, division, or compositing.
<p><a name="73212">
 <hr>
<center><img src="Geom-image-manip.doc.anc36.gif"></center><hr>

</a>
<a name="73213">
<center><font size=-1><b><i>Figure 8-4	</i><img src="shared/sm-blank.gif" border=0> Translate Operation</b></font></center>
</a><p>
The <code>translate</code> operation takes one rendered or renderable source image and three parameters:<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="60889">
Parameters
</a><th><a name="60891">
Type
</a><th><a name="60893">
Description
</a>
<tr valign=top><td><a name="60895">
xTrans</a><br><td><a name="60897">
Float</a><br><td><a name="60899">
The displacement in the <em>x</em> direction. The default value is 0.0F.</a><br>
<tr valign=top><td><a name="60901">
yTrans</a><br><td><a name="60903">
Float</a><br><td><a name="60905">
The displacement in the <em>y</em> direction. The default value is 0.0F.</a><br>
<tr valign=top><td><a name="60907">
interpolation</a><br><td><a name="60909">
Interpolation</a><br><td><a name="61259">
The interpolation method for resampling. One of INTERP_NEAREST, INTERP_BILINEAR, INTERP_BICUBIC, or INTERP_BICUBIC2. The default value is null.</a><br>

</Table>

<p>The <code>xTrans</code> parameter corresponds to <em>t</em><sub>x</sub> and the <code>yTrans</code> parameter corresponds to <em>t</em><sub>y</sub> in <a href="Geom-image-manip.doc.html#60873">equation 8.1</a>. If <code>xTrans</code> is positive, the translation is to the right; if negative, to the left. If <code>yTrans</code> is positive, the translation is down; if negative, upward. If both <code>xTrans</code> and <code>yTrans</code> are integral, the operation simply <em>wraps</em> its source image to change the image's position in the coordinate plane.
<p>When interpolations that require padding the source such as bilinear or bicubic interpolation are specified, the boundary of the source image needs to be extended such that it has the extra pixels needed to compute all the destination pixels. This extension is performed via the <code>BorderExtender</code> class. The type of border extension can be specified as a <code>RenderingHint</code> to the <code>JAI.create</code> method. If no border extension type is provided, a default extension of <code>BorderExtender.BORDER_COPY</code> will be used to perform the extension. See <a href="Programming-environ.doc.html#55991">Section &#32;3.7.3, "Rendering Hints</a>."
<p><a href="Geom-image-manip.doc.html#69434">Listing &#32;8-2</a> shows a code sample for a translate operation using nearest-neighbor interpolation.<p>
<caption><font size=-1><b>
<a name="69434">
<center><font size=-1><b><i>Listing 8-2	</i><img src="shared/sm-blank.gif" border=0> Example Translate Operation</b></font></center>
</a><p>
</b></font></caption>
<hr>
<tr valign=top><td><pre>     // Create a ParameterBlock and specify the source and
     // parameters.
     ParameterBlock pb = new ParameterBlock();
          pb.addSource(im);                   // The source image
          pb.add((float)Math.max(-mx, 0));    // The x translation
          pb.add((float)Math.max(-my, 0));    // The y translation
          pb.add(new InterpolationNearest()); // The interpolation
</pre>
<tr valign=top><td><pre>     // Create the translate operation
     im = JAI.create("translate", pb, null);
</pre>

<hr>

<p><a name="60938">
<h3>8.3.2	<img src="shared/space.gif">Scaling Transformation</h3>
</a>Scaling, also known as <em>minification</em> and <em>magnification</em>, enlarges or shrinks an image. An <em>x</em>-value defines the amount of scaling in the <em>x</em> direction, and a <em>y</em>-value defines the amount of scaling in the <em>y</em> direction. The <code>Scale</code> operation both translates and resizes.
<p>Scaling is often used to geometrically register multiple images prior to performing a combination operation, such as image addition, subtraction, division, or compositing. Scaling can also be used to correct geometric distortions introduced in the image acquisition process, although the <code>Affine</code> operation (<a href="Geom-image-manip.doc.html#51275">"Affine Transformation" on page 272</a>) would be more suitable for this.
<p>For each pixel (<em>x</em>, <em>y</em>) of the destination, the source value at the fractional subpixel position is constructed by means of an <code>Interpolation</code> object and written to the destination.
<p><dl>
<a name="60948">
<dt><dd> <img src="Geom-image-manip.doc.anc6.gif">
</a><P></dl>
The <code>scale</code> operation takes one rendered or renderable source image and five parameters:<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="60951">
Parameters
</a><th><a name="60953">
Type
</a><th><a name="60955">
Description
</a>
<tr valign=top><td><a name="60957">
xScale</a><br><td><a name="60959">
Float</a><br><td><a name="60961">
The <em>x</em> scale factor.</a><br>
<tr valign=top><td><a name="60963">
yScale</a><br><td><a name="60965">
Float</a><br><td><a name="60967">
The <em>y</em> scale factor.</a><br>
<tr valign=top><td><a name="60969">
xTrans</a><br><td><a name="60971">
Float</a><br><td><a name="60973">
The <em>x</em> translation.</a><br>
<tr valign=top><td><a name="60975">
xTrans</a><br><td><a name="60977">
Float</a><br><td><a name="60979">
The <em>y</em> translation.</a><br>
<tr valign=top><td><a name="60981">
interpolation</a><br><td><a name="60983">
Interpolation</a><br><td><a name="60985">
The interpolation method for resampling. One of INTERP_NEAREST, INTERP_BILINEAR, INTERP_BICUBIC, or INTERP_BICUBIC2.</a><br>

</Table>

<p>When applying scale factors (<code>xScale</code> and <code>yScale</code>) to a source image with width of <code>src_width</code> and height of <code>src_height</code>, the resulting image is defined to have the following dimensions:
<p><pre>     dst_width = src_width * xScale
     dst_height = src_height * yScale
</pre>Scale factors greater than 1.0 magnify the image; less than 1.0 minify the image. The <code>xTrans</code> parameter corresponds to <em>t</em><sub>x</sub> and the <code>yTrans</code> parameter corresponds to <em>t</em><sub>y</sub> in <a href="Geom-image-manip.doc.html#60873">equation 8.1</a>. If <code>xTrans</code> is positive, the translation is to the right; if negative, to the left. If <code>yTrans</code> is positive, the translation is down; if negative, upward.
<p><a name="73168">
 <hr>
<center><img src="Geom-image-manip.doc.anc25.gif"></center><hr>

</a>
<a name="73169">
<center><font size=-1><b><i>Figure 8-5	</i><img src="shared/sm-blank.gif" border=0> Scale Operation</b></font></center>
</a><p>
When interpolations that require padding the source such as Bilinear or Bicubic interpolation are specified, the boundary of the source image needs to be extended such that it has the extra pixels needed to compute all the destination pixels. This extension is performed via the <code>BorderExtender</code> class. The type of border extension can be specified as a <code>RenderingHint</code> to the <code>JAI.create</code> method. See <a href="Programming-environ.doc.html#55991">Section &#32;3.7.3, "Rendering Hints</a>."
<p>If no Border Extension is specified, the source will not be extended. The scaled image size is still calculated according to the equation specified above. However since there isn't enough source to compute all the destination pixels, only that subset of the destination image's pixels that can be computed will be written in the destination. The rest of the destination will not be written.
<p><a href="Geom-image-manip.doc.html#69465">Listing &#32;8-3</a> shows a code sample for a <code>Scale</code> operation using a scale factor of 1.2 and nearest-neighbor interpolation.<p>
<caption><font size=-1><b>
<a name="69465">
<center><font size=-1><b><i>Listing 8-3	</i><img src="shared/sm-blank.gif" border=0> Example Scale Operation</b></font></center>
</a><p>
</b></font></caption>
<hr>
<tr valign=top><td><pre>     // Create a ParameterBlock and specify the source and
     // parameters
     ParameterBlock pb = new ParameterBlock();
          pb.addSource(im);                   // The source image
          pb.add(1.2);                        // The xScale
          pb.add(1.2);                        // The yScale
          pb.add(0.0F);                       // The x translation
          pb.add(0.0F);                       // The y translation
          pb.add(new InterpolationNearest()); // The interpolation
</pre>
<tr valign=top><td><pre>     // Create the scale operation
     im = JAI.create("scale", pb, null);
</pre>

<hr>

<p><a name="61009">
<h3>8.3.3	<img src="shared/space.gif">Rotation Transformation</h3>
</a>The <code>rotate</code> operation rotates an image about a given point by a given angle. Specified <em>x</em> and <em>y</em> values define the coordinate of the source image about which to rotate the image and a rotation angle in <em>radians</em> defines the angle of rotation about the rotation point. If no rotation point is specified, a default of (0,0) is assumed.
<p>A negative rotation value rotates the image counter-clockwise, while a positive rotation value rotates the image clockwise.
<p><a name="73109">
 <hr>
<center><img src="Geom-image-manip.doc.ancA20.gif"></center><hr>

</a>
<a name="73110">
<center><font size=-1><b><i>Figure 8-6	</i><img src="shared/sm-blank.gif" border=0> Rotate Operation</b></font></center>
</a><p>
The <code>rotate</code> operation takes one rendered or renderable source image and four parameters:<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="68407">
Parameters
</a><th><a name="68409">
Type
</a><th><a name="68411">
Description
</a>
<tr valign=top><td><a name="68413">
xOrigin</a><br><td><a name="68415">
Float</a><br><td><a name="68417">
The <em>x</em> origin to rotate about.</a><br>
<tr valign=top><td><a name="68419">
yOrigin</a><br><td><a name="68421">
Float</a><br><td><a name="68423">
The <em>y</em> origin to rotate about.</a><br>
<tr valign=top><td><a name="68425">
angle</a><br><td><a name="68427">
Float</a><br><td><a name="68429">
The rotation angle in radians.</a><br>
<tr valign=top><td><a name="68431">
interpolation</a><br><td><a name="68433">
Interpolation</a><br><td><a name="68435">
The interpolation method for resampling. One of INTERP_NEAREST, INTERP_BILINEAR, INTERP_BICUBIC, or INTERP_BICUBIC2.</a><br>

</Table>

<p>When interpolations that require padding the source such as Bilinear or Bicubic interpolation are specified, the boundary of the source image needs to be extended such that it has the extra pixels needed to compute all the destination pixels. This extension is performed via the <code>BorderExtender</code> class. The type of border extension can be specified as a <code>RenderingHint</code> to the <code>JAI.create</code> method. If no border extension type is provided, a default extension of <code>BorderExtender.BORDER_COPY</code> will be used to perform the extension. See <a href="Programming-environ.doc.html#55991">Section &#32;3.7.3, "Rendering Hints</a>."
<p><a href="Geom-image-manip.doc.html#69491">Listing &#32;8-4</a> shows a code sample for a <code>Rotate</code> operation for a rotation angle of 45 degrees. Since the rotation angle must be specified in radians, the example first converts 45 degrees to radians.<p>
<caption><font size=-1><b>
<a name="69491">
<center><font size=-1><b><i>Listing 8-4	</i><img src="shared/sm-blank.gif" border=0> Example Rotate Operation &#32;</b></font></center>
</a><p>
</b></font></caption>
<hr>
<tr valign=top><td><pre>     // Create the rotation angle (45 degrees) and convert to
     // radians.
     int value = 45;
     float angle = (float)(value * (Math.PI/180.0F));
</pre>
<tr valign=top><td><pre>     // Create a ParameterBlock and specify the source and
     // parameters
     ParameterBlock pb = new ParameterBlock();
          pb.addSource(im);                   // The source image
          pb.add(0.0F);                       // The x origin
          pb.add(0.0F);                       // The y origin
          pb.add(angle);                      // The rotation angle
          pb.add(new InterpolationNearest()); // The interpolation
</pre>
<tr valign=top><td><pre>     // Create the rotate operation
     im = JAI.create("Rotate", pb, null);
</pre>

<hr>

<p><a name="51275">
<h3>8.3.4	<img src="shared/space.gif">Affine Transformation</h3>
</a>An <em>affine transform</em> is a transformation of an image in which straight lines remain straight and parallel lines remain parallel, but the distance between lines and the angles between lines may change. Affine transformations include translation, scaling, and rotation.
<p>Although there are separate JAI operations to handle translation, scaling, and rotation, the <code>Affine</code> operation can perform any of these transformations or any combination, such as scale and rotate.
<p>The <code>Affine</code> operation performs (possibly filtered) affine mapping between a source and a destination image. For each pixel (<em>x</em>, <em>y</em>) of the destination, the source value at the fractional subpixel position (<em>x</em>', <em>y</em>') is constructed by means of an <code>Interpolation</code> object and written to the destination.
<p>The <code>affine</code> operation takes one rendered or renderable source image and two parameters:<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="69165">
Parameter
</a><th><a name="69167">
Type
</a><th><a name="69169">
Description
</a>
<tr valign=top><td><a name="69171">
transform</a><br><td><a name="69173">
AffineTransform</a><br><td><a name="69175">
The affine transform matrix.</a><br>
<tr valign=top><td><a name="69177">
interpolation</a><br><td><a name="69179">
Interpolation</a><br><td><a name="69182">
The interpolation method for resampling. One of INTERP_NEAREST, INTERP_BILINEAR, INTERP_BICUBIC, or INTERP_BICUBIC2.</a><br>

</Table>

<p>The mapping between the destination pixel (<em>x</em>, <em>y</em>) and the source position (<em>x</em>', <em>y</em>') is given by:
<p>
<p>
<a name="68969">
<ul><table>
<tr><td width=430><em>x</em>' = <em>m</em>00 * <em>x</em> + <em>m</em>01 * <em>y</em> + <em>m</em>02<br><em>y</em>' = <em>m</em>10 * <em>x</em> + <em>m</em>11 * <em>y</em> + <em>m</em>12 </td>
<td>(8.2)</td></tr>
</table></ul>
</a>
<dl>
<a name="68970">
<dt><dd> where <em>m</em> is a 3 x 2 transform matrix that inverts the matrix supplied as the <code>transform</code> argument.
</a><P></dl>
The six elements of the transform matrix are <code>m00</code>, <code>m01</code>, <code>m02</code>, <code>m10</code>, <code>m11</code>, and <code>m12</code>. The constructor looks like this:
<p><pre>     AffineTransform tr = new AffineTransform(m00, m10,
                                              m01, m11,
                                              m02, m12);
</pre>These six elements affect the transformation as follows:<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="69204">
Element
</a><th><a name="69206">
Description
</a>
<tr valign=top><td><a name="69208">
m00</a><br><td><a name="69210">
The <em>x</em> coordinate scale element</a><br>
<tr valign=top><td><a name="69212">
m10</a><br><td><a name="69214">
The <em>y</em> coordinate shear element</a><br>
<tr valign=top><td><a name="69216">
m01</a><br><td><a name="69218">
The <em>x</em> coordinate shear element</a><br>
<tr valign=top><td><a name="69220">
m11</a><br><td><a name="69222">
The <em>y</em> coordinate scale element</a><br>
<tr valign=top><td><a name="69224">
m02</a><br><td><a name="69226">
The <em>x</em> coordinate translate element</a><br>
<tr valign=top><td><a name="69228">
m12</a><br><td><a name="69230">
The <em>y</em> coordinate translate element</a><br>

</Table>

<p>The following matrix will translate an image 100 pixels to the right and 200 pixels down:<p>
<caption><font size=-1><b></b></font></caption>
<hr>
<tr valign=top><td colspan=1 rowspan=6><pre>     AffineTransform tr = new AffineTransform(1.0,
                                              0.0,
                                              0.0,
                                              1.0,
                                              100.0,
                                              200.0);
</pre>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>

<hr>

<p>The following matrix will zoom an image by a factor of 2 in both the <em>x</em> and <em>y</em> directions:<p>
<caption><font size=-1><b></b></font></caption>
<hr>
<tr valign=top><td colspan=1 rowspan=6><pre>     AffineTransform tr = new AffineTransform(2.0,
                                              0.0,
                                              0.0,
                                              2.0,
                                              0.0,
                                              0.0);
</pre>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>
<tr valign=top>

<hr>

<p><a name="68644">
 <hr>
<center><img src="Geom-image-manip.doc.ancA3.gif"></center><hr>

</a>
<a name="73267">
<center><font size=-1><b><i>Figure 8-7	</i><img src="shared/sm-blank.gif" border=0> Affine Operation</b></font></center>
</a><p>
When interpolations that require padding the source such as Bilinear or Bicubic interpolation are specified, the boundary of the source image needs to be extended such that it has the extra pixels needed to compute all the destination pixels. This extension is performed via the <code>BorderExtender</code> class. The type of border extension can be specified as a <code>RenderingHint</code> to the <code>JAI.create</code> method. If no border extension type is provided, a default extension of <code>BorderExtender.BORDER_COPY</code> will be used to perform the extension. See <a href="Programming-environ.doc.html#55991">Section &#32;3.7.3, "Rendering Hints</a>."
<p><a href="Geom-image-manip.doc.html#69365">Listing &#32;8-5</a> shows a code sample for an <code>Affine</code> operation that performs a 45 degree counterclockwise rotation.<p>
<caption><font size=-1><b>
<a name="69365">
<center><font size=-1><b><i>Listing 8-5	</i><img src="shared/sm-blank.gif" border=0> Example Affine Transform Operation &#32;</b></font></center>
</a><p>
</b></font></caption>
<hr>
<tr valign=top><td><pre>     // Load the image.
     String filename = "images/Trees.gif";
     PlanarImage im = (PlanarImage)JAI.create("fileload",
                                               filename);
</pre>
<tr valign=top><td><pre>     // Create the affine transform matrix.
     AffineTransform tr = new AffineTransform(0.707107,
                                             -0.707106,
                                              0.707106,
                                              0.707106,
                                              0.0,
                                              0.0);
</pre>
<tr valign=top><td><pre>     // Specify the type of interpolation.
     Interpolation interp = new InterpolationNearest();
</pre>
<tr valign=top><td><pre>     // Create the affine operation.
     PlanarImage im2 = (PlanarImage)JAI.create("affine", im, tr,
                                                interp);
</pre>

<hr>

<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>java.awt.geom.AffineTransform 
</code>
<hr>
</td>
</table><pre><ul>
<li>static AffineTransform getTranslateInstance(double tx, 
       double &#32;ty)
<p></ul></pre><dl>
<a name="61338">
<dt><dd> returns a transform representing a translation transformation.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=2><em>Parameters</em>:
<p><td><code>tx</code>
<p><td>The distance by which coordinates are translated in the <em>x</em> axis direction.
<p>
<tr valign=top><td><code>ty</code>
<p><td>The distance by which coordinates are translated in the <em>y</em> axis direction
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>static AffineTransform getRotateInstance(double theta)
<p></ul></pre><dl>
<a name="61407">
<dt><dd> returns a transform representing a rotation transformation.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td><em>Parameters</em>:
<p><td><code>theta</code>
<p><td>The angle of rotation in radians.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>static AffineTransform getRotateInstance(double theta, 
       double &#32;x, double y)
<p></ul></pre><dl>
<a name="61442">
<dt><dd> returns a transform that rotates coordinates around an anchor point.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=3><em>Parameters</em>:
<p><td><code>theta</code>
<p><td>The angle of rotation in radians.
<p>
<tr valign=top><td><code>x</code>
<p><td>The <em>x</em> coordinate of the anchor point of the rotation.
<p>
<tr valign=top><td><code>y</code>
<p><td>The <em>y</em> coordinate of the anchor point of the rotation.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>static AffineTransform getScaleInstance(double sx, double sy)
<p></ul></pre><dl>
<a name="61496">
<dt><dd> returns a transform representing a scaling transformation.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=2><em>Parameters</em>:
<p><td><code>sx</code>
<p><td>The factor by which coordinates are scaled along the <em>x</em> axis direction.
<p>
<tr valign=top><td><code>sy</code>
<p><td>The factor by which coordinates are scaled along the <em>y</em> axis direction.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>static AffineTransform getShearInstance(double shx, double shy)
<p></ul></pre><dl>
<a name="61540">
<dt><dd> returns a transform representing a shearing transformation.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=2><em>Parameters</em>:
<p><td><code>shx</code>
<p><td>The multiplier by which coordinates are shifted in the direction of the positive <em>x</em> axis as a factor of their <em>y</em> coordinate.
<p>
<tr valign=top><td><code>shy</code>
<p><td>The multiplier by which coordinates are shifted in the direction of the positive <em>y</em> axis as a factor of their <em>x </em>coordinate.
<p>

</Table>

</a><P></dl>
<a name="55959">
<h2>8.4	<img src="shared/space.gif">Perspective Transformation</h2>
</a>Perspective distortions in images are sometimes introduced when the camera is at an angle to the subject. For an example, think of a camera in an aircraft above the earth. If the camera is aimed straight down, the resulting image will be a flat perspective image; that is, no distortion. All objects in the image appear in correct size relative to one another. However, if the camera is angled toward the earth horizon, perspective distortion is introduced. Objects closer to the camera appear larger than same-sized objects farther away from the camera. Perspective distortion has reduced the scale of the objects farthest away.
<p>Perspective distortion can be corrected by applying a <em>perspective transform</em>. The perspective transform maps an arbitrary quadrilateral into another arbitrary quadrilateral, while preserving the straightness of lines. Unlike an affine transformation, the parallelism of lines in the source is not necessarily preserved in the output.
<p>The perspective transform is represented by a 3 x 3 matrix that transforms homogenous source coordinates (<em>x</em>, <em>y</em>, 1) into destination coordinates (<em>x</em>', <em>y</em>', <em>w</em>). To convert back into non-homogenous coordinates, <em>x</em>' and <em>y</em>' are divided by <em>w</em>.
<p><dl>
<a name="55997">
<dt><dd> <img src="Geom-image-manip.doc.anc5.gif">
</a><P></dl>
The perspective transform is used with the perspective warp operation. See <a href="Geom-image-manip.doc.html#58571">Section &#32;8.7.7, "Perspective Warp</a>."
<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.PerspectiveTransform
</code>
<hr>
</td>
</table><pre><ul>
<li>PerspectiveTransform(float m00, float m01, float m02, 
       float &#32;m10, float m11, float m12, float m20, float m21, 
       float &#32;m22)
<p></ul></pre><dl>
<a name="56055">
<dt><dd> constructs a new <code>PerspectiveTransform</code> from nine float values.
</a><P></dl>
<pre><ul>
<li>PerspectiveTransform(float[] flatmatrix)
<p></ul></pre><dl>
<a name="56073">
<dt><dd> constructs a new <code>PerspectiveTransform</code> from a one-dimensional array of nine float values, in row-major order.
</a><P></dl>
<pre><ul>
<li>PerspectiveTransform(float[][] matrix)
<p></ul></pre><dl>
<a name="56092">
<dt><dd> constructs a new <code>PerspectiveTransform</code> from a two-dimensional array of float values.
</a><P></dl>
<pre><ul>
<li>PerspectiveTransform(double m00, double m01, double m02, 
       double &#32;m10, double m11, double m12, double m20, double m21, 
       double m22)
<p></ul></pre><dl>
<a name="56126">
<dt><dd> constructs a new <code>PerspectiveTransform</code> from nine double values.
</a><P></dl>
<pre><ul>
<li>PerspectiveTransform(double[] flatmatrix)
<p></ul></pre><dl>
<a name="56137">
<dt><dd> constructs a new <code>PerspectiveTransform</code> from a one-dimensional array of nine double values, in row-major order.
</a><P></dl>
<pre><ul>
<li>PerspectiveTransform(double[][] matrix)
<p></ul></pre><dl>
<a name="56164">
<dt><dd> constructs a new <code>PerspectiveTransform</code> from a two-dimensional array of double values.
</a><P></dl>
<pre><ul>
<li>PerspectiveTransform(AffineTransform transform)
<p></ul></pre><dl>
<a name="56178">
<dt><dd> constructs a new <code>PerspectiveTransform</code> with the same effect as an existing <code>AffineTransform</code>.
</a><P></dl>
<a name="66598">
<h3>8.4.1	<img src="shared/space.gif">Performing the Transform</h3>
</a>The <code>PerspectiveTransform</code> class contains methods that perform the perspective transform on a specified point, an array of point objects, an array of floating point coordinates, or an array of double precision coordinates.
<p><a name="56192">
<h3>8.4.2	<img src="shared/space.gif">Mapping a Quadrilateral</h3>
</a>The <code>PerspectiveTransform</code> class contains methods that may be used to create a perspective transform that can be used to map a unit square to or from an arbitrary quadrilateral and to map an arbitrary quadrilateral onto another arbitrary quadrilateral. The <code>getSquareToQuad</code> methods map the unit square onto an arbitrary quadrilateral:
<p><dl><dl>
<a name="66282">
<dt><dd> (0, 0) <img src="shared/chars/arrwrite.gif"> (<em>x</em>0, <em>y</em>0)<br>(1, 0) <img src="shared/chars/arrwrite.gif"> (<em>x</em>1, <em>y</em>1)<br>(1, 1) <img src="shared/chars/arrwrite.gif"> (<em>x</em>2, <em>y</em>2)<br>(0, 1) <img src="shared/chars/arrwrite.gif"> (<em>x</em>3, <em>y</em>3)
</a><P></dl>
</dl>The <code>getQuadToSquare</code> methods map an arbitrary quadrilateral onto the unit square:
<p><dl><dl>
<a name="66305">
<dt><dd> (<em>x</em>0, <em>y</em>0) <img src="shared/chars/arrwrite.gif"> (0, 0)<br>(<em>x</em>1, <em>y</em>1) <img src="shared/chars/arrwrite.gif"> (1, 0)<br>(<em>x</em>2, <em>y</em>2) <img src="shared/chars/arrwrite.gif"> (1, 1)<br>(x3, <em>y</em>3) <img src="shared/chars/arrwrite.gif"> (0, 1)
</a><P></dl>
</dl>The <code>getQuadToQuad</code> methods map an arbitrary quadrilateral onto another arbitrary quadrilateral:
<p><dl><dl>
<a name="66343">
<dt><dd> (<em>x</em>0, <em>y</em>0) <img src="shared/chars/arrwrite.gif"> (<em>x</em>0p, <em>y</em>0p)<br>(<em>x</em>1, <em>y</em>1) <img src="shared/chars/arrwrite.gif"> (<em>x</em>1p, <em>y</em>1p)<br>(<em>x</em>2, <em>y</em>2) <img src="shared/chars/arrwrite.gif"> (<em>x</em>2p, <em>y</em>2p)<br>(<em>x</em>3, <em>y</em>3) <img src="shared/chars/arrwrite.gif"> (<em>x</em>3p, <em>y</em>3p)
</a><P></dl>
</dl><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.PerspectiveTransform
</code>
<hr>
</td>
</table><pre><ul>
<li>static PerspectiveTransform getSquareToQuad(double x0, 
       double &#32;y0, double x1, double y1, double x2, double y2, 
       double x3, double y3)
<p></ul></pre><dl>
<a name="56233">
<dt><dd> creates a <code>PerspectiveTransform</code> that maps the unit square onto an arbitrary quadrilateral.
</a><P></dl>
<pre><ul>
<li>static PerspectiveTransform getSquareToQuad(float x0, float y0, 
       float x1, float y1, float x2, float y2, float x3, float y3)
<p></ul></pre><dl>
<a name="56306">
<dt><dd> creates a <code>PerspectiveTransform</code> that maps the unit square onto an arbitrary quadrilateral.
</a><P></dl>
<pre><ul>
<li>static PerspectiveTransform getQuadToSquare(double x0, 
       double &#32;y0, double x1, double y1, double x2, double y2, 
       double x3, double y3)
<p></ul></pre><dl>
<a name="56352">
<dt><dd> creates a <code>PerspectiveTransform</code> that maps an arbitrary quadrilateral onto the unit square.
</a><P></dl>
<pre><ul>
<li>static PerspectiveTransform getQuadToSquare(float x0, float y0, 
       float x1, float y1, float x2, float y2, float x3, float y3)
<p></ul></pre><dl>
<a name="56398">
<dt><dd> creates a <code>PerspectiveTransform</code> that maps an arbitrary quadrilateral onto the unit square.
</a><P></dl>
<pre><ul>
<li>static PerspectiveTransform getQuadToQuad(double x0, double y0, 
       double x1, double y1, double x2, double y2, double x3, 
       double y3, double x0p, double y0p, double x1p, double y1p, 
       double x2p, double y2p, double x3p, double y3p)
<p></ul></pre><dl>
<a name="56457">
<dt><dd> creates a <code>PerspectiveTransform</code> that maps an arbitrary quadrilateral onto another arbitrary quadrilateral.
</a><P></dl>
<pre><ul>
<li>static PerspectiveTransform getQuadToQuad(float x0, float y0, 
       float x1, float y1, float x2, float y2, float x3, float y3, 
       float x0p, float y0p, float x1p, float y1p, float x2p, 
       float &#32;y2p, float x3p, float y3p)
<p></ul></pre><dl>
<a name="56531">
<dt><dd> creates a <code>PerspectiveTransform</code> that maps an arbitrary quadrilateral onto another arbitrary quadrilateral.
</a><P></dl>
<a name="56537">
<h3>8.4.3	<img src="shared/space.gif">Mapping Triangles</h3>
</a>The <code>PerspectiveTransform</code> class contains methods that may be used to create a perspective transform that can be used to map one arbitrary triangle to another arbitrary triangle. This is done with one of the <code>getTriToTri</code> methods
<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.PerspectiveTransform
</code>
<hr>
</td>
</table><pre><ul>
<li>static AffineTransform getTriToTri(double x0, double y0, double 
       x1, double y1, double x2, double y2)
<p></ul></pre><dl>
<a name="56575">
<dt><dd> creates an <code>AffineTransform</code> that maps an arbitrary triangle onto another arbitrary triangle:
</a><P><dl>
<a name="56583">
<dt><dd> (<em>x</em>0, <em>y</em>0) <img src="shared/chars/arrwrite.gif"> (<em>x</em>0p, <em>y</em>0p)<br>(<em>x</em>1, <em>y</em>1) <img src="shared/chars/arrwrite.gif"> (<em>x</em>1p, <em>y</em>1p)<br>(<em>x</em>2, <em>y</em>2) <img src="shared/chars/arrwrite.gif"> (<em>x</em>2p, <em>y</em>2p)
</a><P></dl>
</dl>
<pre><ul>
<li>static AffineTransform getTriToTri(float x0, float y0, float 
       x1, float y1, float x2, float y2)
<p></ul></pre><dl>
<a name="56694">
<dt><dd> creates an <code>AffineTransform</code> that maps an arbitrary triangle onto another arbitrary triangle:
</a><P><dl>
<a name="56704">
<dt><dd> (<em>x</em>0, <em>y</em>0) <img src="shared/chars/arrwrite.gif"> (<em>x</em>0p, <em>y</em>0p)<br>(<em>x</em>1, <em>y</em>1) <img src="shared/chars/arrwrite.gif"> (<em>x</em>1p, <em>y</em>1p)<br>(<em>x</em>2, <em>y</em>2) <img src="shared/chars/arrwrite.gif"> (<em>x</em>2p, <em>y</em>2p) <em></em>
</a><P></dl>
</dl>
<a name="66375">
<h3>8.4.4	<img src="shared/space.gif">Inverse Perspective Transform</h3>
</a>The <code>PerspectiveTransform</code> class contains methods to perform an inverse perspective transform. One of the <code>inverseTransform</code> methods inverse transforms a specified Point2D to another Point2D. Another <code>inverseTransform</code> method inverse transforms an array of double-precision coordinates.
<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.PerspectiveTransform
</code>
<hr>
</td>
</table><pre><ul>
<li>Point2D inverseTransform(Point2D ptSrc, Point2D ptDst)
<p></ul></pre><dl>
<a name="66432">
<dt><dd> inverse transforms the specified <code>ptSrc</code> and stores the result in <code>ptDst</code>. If <code>ptDst</code> is null, a new <code>Point2D</code> object will be allocated before storing. In either case, <code>ptDst</code> containing the transformed point is returned for convenience. Note that <code>ptSrc</code> and <code>ptDst</code> can the same. In this case, the input point will be overwritten with the transformed point.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=2><em>Parameters</em>:
<p><td><code>ptSrc</code>
<p><td>The point to be inverse transformed.
<p>
<tr valign=top><td><code>ptDst</code>
<p><td>The resulting transformed point.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>inverseTransform(double[] srcPts, int srcOff, double[] dstPts, 
       int dstOff, int numPts)
<p></ul></pre><dl>
<a name="66525">
<dt><dd> inverse transforms an array of double precision coordinates by this transform.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=5><em>Parameters</em>:
<p><td><code>srcPts</code>
<p><td>The array containing the source point coordinates. Each point is stored as a pair of <em>x</em>,<em>y</em> coordinates.
<p>
<tr valign=top><td><code>srcOff</code>
<p><td>The offset to the first point to be transformed in the source array.
<p>
<tr valign=top><td><code>dstPts</code>
<p><td>The array where the transformed point coordinates are returned. Each point is stored as a pair of <em>x</em>,<em>y</em> coordinates.
<p>
<tr valign=top><td><code>dstOff</code>
<p><td>The offset to the location where the first transformed point is stored in the destination array.
<p>
<tr valign=top><td><code>numPts</code>
<p><td>The number of point objects to be transformed.
<p>

</Table>

</a><P></dl>
<a name="73535">
<h3>8.4.5	<img src="shared/space.gif">Creating the Adjoint of the Current Transform</h3>
</a>The <code>PerspectiveTransform</code> class contains a method for creating a new PerspectiveTransform that is the adjoint of the current transform. The adjoint is defined as the matrix of cofactors, which in turn are the determinants of the submatrices defined by removing  the row and column of each element from the original matrix in turn.
<p>The adjoint is a scalar multiple of the inverse matrix. Because points to be      transformed are converted into homogeneous coordinates, where scalar factors are irrelevant, the adjoint may be used in place of the true inverse. Since it is unnecessary to normalize the adjoint, it is both faster to compute and more numerically stable than the true inverse.
<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.PerspectiveTransform
</code>
<hr>
</td>
</table><pre><ul>
<li>public PerspectiveTransform createAdjoint()
<p></ul></pre><dl>
<a name="73580">
<dt><dd> returns a new PerpectiveTransform that is the adjoint of the current transform.
</a><P></dl>
<a name="66415">
<h2>8.5	<img src="shared/space.gif">Transposing</h2>
</a>The <code>Transpose</code> operation is a combination of flipping and rotating. With a <code>Transpose</code> operation, you can (see <a href="Geom-image-manip.doc.html#72052">Figure &#32;8-8</a>):
<p><ul>
<li>Flip an image vertically across an imaginary horizontal axis that runs through the center of the image (<code>FLIP_VERTICAL</code>).<p></ul><ul>
<li>Flip an image horizontally across an imaginary vertical axis that runs through the center of the image (<code>FLIP_HORIZONTAL</code>).<p></ul><ul>
<li>Flip an image across its main diagonal axis, which runs from the upper left to the lower right corner (<code>FLIP_DIAGONAL</code>).<p></ul><ul>
<li>Flip an image across its main anti-diagonal axis, which runs from the upper right to the lower left corner (<code>FLIP_ANTIDIAGONAL</code>).<p></ul><ul>
<li>Rotate an image counterclockwise about its center by 90, 180, or 270 degrees (<code>ROTATE_90</code>, <code>ROTATE_180</code>, <code>ROTATE_270</code>).<p></ul>The <code>transpose</code> operation takes one rendered or renderable source image and one parameter:<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="73592">
Parameter
</a><th><a name="73594">
Type
</a><th><a name="73596">
Description
</a>
<tr valign=top><td><a name="73598">
type</a><br><td><a name="73600">
Integer</a><br><td><a name="73602">
The type of flip operation to be performed. One of FLIP_VERTICAL, FLIP_HORIZONTAL, FLIP_DIAGONAL, FLIP_ANTIDIAGONAL, ROTATE_90, ROTATE_180, or ROTATE_270</a><br>

</Table>

<p><a name="72051">
 <hr>
<center><img src="Geom-image-manip.doc.ancA5.gif"></center><hr>

</a>
<a name="72052">
<center><font size=-1><b><i>Figure 8-8	</i><img src="shared/sm-blank.gif" border=0> Transpose Operations</b></font></center>
</a><p>
<a href="Geom-image-manip.doc.html#71691">Listing &#32;8-6</a> shows sample code for creating a <code>Transpose</code> operation. The example performs a horizontal flip on the source image and creates the destination image <code>im2</code>.<p>
<caption><font size=-1><b>
<a name="71691">
<center><font size=-1><b><i>Listing 8-6	</i><img src="shared/sm-blank.gif" border=0> Example Transpose Operation</b></font></center>
</a><p>
</b></font></caption>
<hr>
<tr valign=top><td><pre>     // Create a pattern image.
     ParameterBlock pb = new ParameterBlock();
     pb.add(image);
     PlanarImage im0 = (PlanarImage)JAI.create("awtImage", pb);
</pre>
<tr valign=top><td><pre>     // Transpose type : 0=FLIP_VERTICAL
     //                : 1=FLIP_HORIZONTAL
     //                : 2=FLIP_DIAGONAL
     //                : 3=FLIP_ANTIDIAGONAL
     //                : 4=ROTATE_90
     //                : 5=ROTATE_180
     //                : 6=ROTATE_270
     int type = 1;
</pre>
<tr valign=top><td><pre>     // Create the Transpose operation.
     PlanarImage im2 = (PlanarImage)JAI.create("transpose", im0,
                                               type);
</pre>

<hr>

<p><a name="57228">
<h2>8.6	<img src="shared/space.gif">Shearing</h2>
</a>Shearing can be visualized by thinking of an image superimposed onto a flexible rubber sheet. If you hold the sides of the sheet and move them up and down in opposite directions, the image will undergo a spatial stretching known as shearing. The <code>shear</code> operation shears an image either horizontally or vertically.
<p><a name="71762">
 <hr>
<center><img src="Geom-image-manip.doc.ancA6.gif"></center><hr>

</a>
<a name="71763">
<center><font size=-1><b><i>Figure 8-9	</i><img src="shared/sm-blank.gif" border=0> Shearing Operations</b></font></center>
</a><p>
For each pixel (<em>x</em>, <em>y</em>) of the destination, the source value at the fractional subpixel position (<em>x</em>', <em>y</em>') is constructed by means of an <code>Interpolation</code> object and written to the destination (see <a href="Geom-image-manip.doc.html#51290">"Interpolation" on page 249</a>).
<p>The <code>shear</code> operation takes one rendered source image and five parameters:<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="57345">
Parameters
</a><th><a name="57347">
Type
</a><th><a name="57349">
Description
</a>
<tr valign=top><td><a name="57351">
shear</a><br><td><a name="57353">
Float</a><br><td><a name="57355">
The shear value.</a><br>
<tr valign=top><td><a name="57357">
shearDir</a><br><td><a name="57359">
Integer</a><br><td><a name="57361">
The shear direction: SHEAR_HORIZONTAL or SHEAR_VERTICAL</a><br>
<tr valign=top><td><a name="57363">
xTrans</a><br><td><a name="57365">
Float</a><br><td><a name="57367">
The <em>x</em> translation.</a><br>
<tr valign=top><td><a name="57369">
yTrans</a><br><td><a name="57371">
Float</a><br><td><a name="57373">
The <em>y</em> translation.</a><br>
<tr valign=top><td><a name="57375">
interpolation</a><br><td><a name="57377">
Interpolation</a><br><td><a name="57379">
The interpolation method for resampling. One of INTERP_NEAREST, INTERP_BILINEAR, INTERP_BICUBIC, or INTERP_BICUBIC2.</a><br>

</Table>

<p>For a <code>shearDir</code> parameter of <code>SHEAR_HORIZONTAL</code>:
<p><dl>
<a name="61692">
<dt><dd> <img src="Geom-image-manip.doc.anc16.gif">
</a><P></dl>
For a <code>shearDir</code> parameter of <code>SHEAR_VERTICAL</code>:
<p><dl>
<a name="61702">
<dt><dd> <img src="Geom-image-manip.doc.anc17.gif">
</a><P></dl>
When interpolations that require padding the source such as Bilinear or Bicubic interpolation are specified, the boundary of the source image needs to be extended such that it has the extra pixels needed to compute all the destination pixels. This extension is performed via the <code>BorderExtender</code> class. The type of border extension can be specified as a <code>RenderingHint</code> to the <code>JAI.create</code> method. If no border extension type is provided, a default extension of <code>BorderExtender.BORDER_COPY</code> will be used to perform the extension. See <a href="Programming-environ.doc.html#55991">Section &#32;3.7.3, "Rendering Hints</a>."
<p><a href="Geom-image-manip.doc.html#69639">Listing &#32;8-7</a> shows a code sample for a <code>Shear</code> operation.<p>
<caption><font size=-1><b>
<a name="69639">
<center><font size=-1><b><i>Listing 8-7	</i><img src="shared/sm-blank.gif" border=0> Example Shear Operation &#32;</b></font></center>
</a><p>
</b></font></caption>
<hr>
<tr valign=top><td><pre>     // Load the image.
     String filename = "images/Picketfence.gif";
     PlanarImage im0 = (PlanarImage)JAI.create("fileload",
                                               filename);
</pre>
<tr valign=top><td><pre>     imagePanel1 = new ScrollingImagePanel(im0, 512, 512);
</pre>
<tr valign=top><td><pre>     // Specify the type of interpolation.
     Interpolation interp = new InterpolationNearest();
</pre>
<tr valign=top><td><pre>     // Set the shear direction:
     //     0 = SHEAR_HORIZONTAL
     //     1 = SHEAR_VERTICAL
     int shear_dir = 1;
</pre>
<tr valign=top><td><pre>     // Set the shear value and the x and y translation values.
     float shear_amt = 0.7F;
     float x_trans = 50.0F;
     float y_trans = 100.0F;
</pre>
<tr valign=top><td><pre>     // Create the Shear operation.
     PlanarImage im2 = (PlanarImage)JAI.create("shear",
                                                im0,
                                                shear_amt,
                                                shear_dir,
                                                x_trans,
                                                y_trans,
                                                interp);
</pre>
<tr valign=top><td><pre>     // Display the image.
     imagePanel2 = new ScrollingImagePanel(im2, 512, 512);
     add(imagePanel2);
     pack();
     show();
</pre>

<hr>

<p><a name="53798">
<h2>8.7	<img src="shared/space.gif">Warping</h2>
</a>The linear geometric transformations described in <a href="Geom-image-manip.doc.html#56707">Section &#32;8.3, "Geometric Transformation</a>," cannot introduce curvature in the mapping process. Image warping is a type of geometric transformation that introduces curvature into the mapping process. The introduction of curvature is important when an image has been distorted through lens aberrations and other non-linear processes.
<p>Warping transformations, also known as <em>rubber sheet</em> transformations, can arbitrarily stretch the image about defined points. This type of operation provides a nonlinear transformation between source and destination coordinates.
<p>JAI provides a transformation class, <code>Warp</code>, that is used for non-linear image coordinate transformation. As in the <code>Interpolation</code> class (see <a href="Geom-image-manip.doc.html#51290">Section &#32;8.2, "Interpolation</a>"), pixel positions in the <code>Warp</code> class are represented using fixed-point coordinates, yielding subpixel accuracy but still allowing the use of integer arithmetic. The degree of precision is set by means of the <code>getSubSampleBitsH</code> (horizontal) and <code>getSubSampleBitsV</code> (vertical) parameters to the <code>warpRect</code> method.
<p>The key method of this class is <code>warpRect</code>, which provides the locations of the pixels in source space that map to a given rectangular output region. The output region is specified using normal integer (full pixel) coordinates. The source positions returned by the method are specified in fixed-point, subpixel coordinates.
<p>JAI supports seven warping functions:
<p><ul>
<li>Polynomial warp - a polynomial-based description of an image warp (<code>WarpPolynomial</code>).<p></ul><ul>
<li>General polynomial warp - a general polynomial-based description of an image warp (<code>WarpGeneralPolynomial</code>).<p></ul><ul>
<li>Grid warp - a regular grid-based description of an image warp (<code>WarpGrid</code>).<p></ul><ul>
<li>Quadratic warp - a quadratic-based description of an image warp (<code>WarpQuadratic</code>).<p></ul><ul>
<li>Cubic warp - a cubic-based description of an image warp (<code>WarpCubic</code>).<p></ul><ul>
<li>Perspective warp - a perspective (projective) warp (<code>WarpPerspective</code>).<p></ul><ul>
<li>Affine warp - affine-based warp (<code>WarpAffine</code>).<p></ul><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.Warp
</code>
<hr>
</td>
</table><pre><ul>
<li>int[] warpRect(int x, int y, int width, int height, 
       int &#32;subsampleBitsH, int subsampleBitsV, int[] destRect)
<p></ul></pre><dl>
<a name="61842">
<dt><dd> computes the source subpixel positions for a given rectangular destination region. The destination region is specified using normal integral (full pixel) coordinates. The source positions returned by the method are specified in fixed point, subpixel coordinates using the current value of <code>getSubsampleBitsH()</code> and <code>getSubsampleBitsV()</code>.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td><em>Parameters</em>:
<p><td><code>x</code>
<p><td>The minimum <em>x</em> coordinate of the destination region.
<p>
<tr valign=top><td>
<p><td><code>y</code>
<p><td>The minimum <em>y</em> coordinate of the destination region.
<p>
<tr valign=top><td>
<p><td><code>width</code>
<p><td>The width of the destination region.
<p>
<tr valign=top><td>
<p><td><code>height</code>
<p><td>The height of the destination region.
<p>
<tr valign=top><td>
<p><td><code>subsampleBitsH</code>
<p><td>The number of fractional bits used to specify horizontal offsets in the <code>warpPositions</code> data.
<p>
<tr valign=top><td>
<p><td><code>subsampleBitsV</code>
<p><td>The number of fractional bits used to specify vertical offsets in the <code>warpPositions</code> data.
<p>
<tr valign=top><td>
<p><td><code>destRect</code>
<p><td>An int array containing at least 2*width*height elements, or null. If null, a new array will be constructed.
<p>

</Table>

</a><P><a name="62058">
<dt><dd> As a convenience, an implementation is provided for this method that calls <code>warpSparseRect()</code>. Subclasses may wish to provide their own implementations for better performance.
</a><P></dl>
<pre><ul>
<li>float[] warpRect(int x, int y, int width, int height, 
       float[] &#32;destRect)
<p></ul></pre><dl>
<a name="62010">
<dt><dd> computes the source subpixel positions for a given rectangular destination region. The destination region is specified using normal integral (full pixel) coordinates. The source positions returned by the method are specified in floating point. 
</a><P><a name="62014">
<dt><dd> As a convenience, an implementation is provided for this method that calls <code>warpSparseRect()</code>. Subclasses may wish to provide their own implementations for better performance.
</a><P></dl>
<pre><ul>
<li>int[] warpPoint(int x, int y, int subsampleBitsH, 
       int &#32;subsampleBitsV, int[] destRect)
<p></ul></pre><dl>
<a name="62065">
<dt><dd> computes the source subpixel position for a given destination pixel. The destination pixel is specified using normal integral (full pixel) coordinates. The source position returned by the method is specified in fixed point, subpixel coordinates using the <code>subsampleBitsH</code> and <code>subsampleBitsV</code> parameters.
</a><P><a name="62106">
<dt><dd> As a convenience, an implementation is provided for this method that calls <code>warpSparseRect()</code>. Subclasses may wish to provide their own implementations for better performance.
</a><P></dl>
<pre><ul>
<li>float[] warpPoint(int x, int y, float[] destRect)
<p></ul></pre><dl>
<a name="62124">
<dt><dd> computes the source subpixel position for a given destination pixel. The destination pixel is specified using normal integral (full pixel) coordinates. The source position returned by the method is specified in floating point. 
</a><P><a name="62128">
<dt><dd> As a convenience, an implementation is provided for this method that calls <code>warpRect()</code>. Subclasses may wish to provide their own implementations for better performance.
</a><P></dl>
<pre><ul>
<li>int[] warpSparseRect(int x, int y, int width, int height, 
       int &#32;periodX, int periodY, int subsampleBitsH, 
       int &#32;subsampleBitsV, int[] destRect)
<p></ul></pre><dl>
<a name="62182">
<dt><dd> computes the source subpixel positions for a given rectangular destination region, subsampled with an integral period. The destination region is specified using normal integral (full pixel) coordinates. The source positions returned by the method are specified in fixed point, subpixel coordinates using the <code>subsampleBitsH</code> and <code>subsampleBitsV</code> parameters.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=9><em>Parameters</em>:
<p><td><code>x</code>
<p><td>The minimum <em>X</em> coordinate of the destination region.
<p>
<tr valign=top><td><code>y</code>
<p><td>The minimum <em>Y</em> coordinate of the destination region.
<p>
<tr valign=top><td><code>width</code>
<p><td>The width of the destination region.
<p>
<tr valign=top><td><code>height</code>
<p><td>The height of the destination region.
<p>
<tr valign=top><td><code>periodX</code>
<p><td>The horizontal sampling period.
<p>
<tr valign=top><td><code>periodY</code>
<p><td>The horizontal sampling period.
<p>
<tr valign=top><td><code>subsample-BitsH</code>
<p><td>The number of fractional bits used to specify horizontal offsets in the <code>warpPositions</code> data.
<p>
<tr valign=top><td><code>subsample-BitsV</code>
<p><td>The number of fractional bits used to specify vertical offsets in the <code>warpPositions</code> data.
<p>
<tr valign=top><td><code>destRect</code>
<p><td>An int array containing at least <hr>
<center><img src="Geom-image-manip.doc.ancA18.gif"></center><hr>
 elements, or null. If null, a new array will be constructed.
<p>

</Table>

</a><P><a name="62187">
<dt><dd> As a convenience, an implementation is provided for this method that calls <code>warpSparseRect()</code> with a float <code>destRect</code> parameter. Subclasses may wish to provide their own implementations for better performance.
</a><P></dl>
<pre><ul>
<li>abstract float[] warpSparseRect(int x, int y, int width, 
       int &#32;height, int periodX, int periodY, float[] destRect)
<p></ul></pre><dl>
<a name="62342">
<dt><dd> computes the source subpixel positions for a given rectangular destination region, subsampled with an integral period. The destination region is specified using normal integral (full pixel) coordinates. The source positions returned by the method are specified in floating point. 
</a><P><a name="62346">
<dt><dd> This method is abstract in this class and must be provided in concrete subclasses.
</a><P></dl>
<pre><ul>
<li>Rectangle mapDestRect(Rectangle destRect)
<p></ul></pre><dl>
<a name="62373">
<dt><dd> computes a rectangle that is guaranteed to enclose the region of the source that is required in order to produce a given rectangular output region. The routine may return null if it is infeasible to compute such a bounding box.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td><em>Parameters</em>:
<p><td><code>destRect</code>
<p><td>The <code>Rectangle</code> in destination coordinates.
<p>

</Table>

</a><P><a name="62371">
<dt><dd> The default (superclass) implementation returns null.
</a><P></dl>
<a name="63708">
<h3>8.7.1	<img src="shared/space.gif">Performing a Warp Operation</h3>
</a>The <code>Warp</code> operation performs general warping on an image. The <code>warp</code> operation takes one rendered source image and two parameters:<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="73654">
Parameters
</a><th><a name="73656">
Type
</a><th><a name="73658">
Description
</a>
<tr valign=top><td><a name="73698">
warp</a><br><td><a name="73700">
Warp</a><br><td><a name="73702">
The warp object. One of</a><br><a name="73703">
 WarpAffine
</a><a name="73704">
 WarpGrid
</a><a name="73705">
 WarpPerspective
</a><a name="73706">
 WarpPolynomial
</a><a name="73707">
 WarpQuadratic
</a><a name="73708">
 WarpOpImage
</a>
<tr valign=top><td><a name="73684">
interpolation</a><br><td><a name="73686">
Interpolation</a><br><td><a name="73689">
The interpolation method for resampling. One of INTERP_NEAREST, INTERP_BILINEAR, INTERP_BICUBIC, or INTERP_BICUBIC2.</a><br>

</Table>

<p>To create a warp operation:
<p><ul>

1.	 Create the warp object, which specifies the type of warp operation. The warp object will be one of the following:<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="66940">
Object
</a><th><a name="66942">
Description
</a>
<tr valign=top><td><a name="66944">
WarpAffine</a><br><td><a name="66946">
An affine-based image warp. See <a href="Geom-image-manip.doc.html#58577">Section &#32;8.7.8, "Affine Warp</a>."</a><br>
<tr valign=top><td><a name="66948">
WarpCubic</a><br><td><a name="66950">
A cubic-based image warp. See <a href="Geom-image-manip.doc.html#66987">Section &#32;8.7.6, "Cubic Warp</a>."</a><br>
<tr valign=top><td><a name="66952">
WarpGeneralPolynomial</a><br><td><a name="66954">
A polynomial-based image warp for polynomials of a higher degree. See <a href="Geom-image-manip.doc.html#62828">Section &#32;8.7.3, "General Polynomial Warp</a>."</a><br>
<tr valign=top><td><a name="66956">
WarpGrid</a><br><td><a name="66958">
A grid-based image warp where the image may be warped in pieces. See <a href="Geom-image-manip.doc.html#62411">Section &#32;8.7.4, "Grid Warp</a>."</a><br>
<tr valign=top><td><a name="66960">
WarpPerspective</a><br><td><a name="66962">
A perspective or projective image warp. See <a href="Geom-image-manip.doc.html#58571">Section &#32;8.7.7, "Perspective Warp</a>."</a><br>
<tr valign=top><td><a name="66964">
WarpPolynomial</a><br><td><a name="66966">
A polynomial-based description of an image warp. See <a href="Geom-image-manip.doc.html#58097">Section &#32;8.7.2, "Polynomial Warp</a>."</a><br>
<tr valign=top><td><a name="66968">
WarpQuadratic</a><br><td><a name="66970">
A quadratic-based description of an image warp. See <a href="Geom-image-manip.doc.html#58581">Section &#32;8.7.5, "Quadratic Warp</a>."</a><br>

</Table>
<p>

2.	 Create the <code>ParameterBlock</code> object and add the source image and the necessary parameters to it. The <code>Warp</code> operation takes two parameters:<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="67163">
Parameter
</a><th><a name="67165">
Description
</a>
<tr valign=top><td><a name="67167">
warp</a><br><td><a name="67169">
The Warp object. One of WarpAffine, WarpCubic, WarpGeneralPolynomial, WarpGrid, WarpPerspective, WarpPolynomial, or WarpQuadratic.</a><br>
<tr valign=top><td><a name="67171">
interpolation</a><br><td><a name="67173">
The interpolation method for resampling. One of INTERP_NEAREST, INTERP_BILINEAR, INTERP_BICUBIC, or INTERP_BICUBIC2.</a><br>

</Table>
<p>
<dl>
<a name="68677">
<dt><dd> When interpolations that require padding the source such as Bilinear or Bicubic interpolation are specified, the boundary of the source image needs to be extended such that it has the extra pixels needed to compute all the destination pixels. This extension is performed via the <code>BorderExtender</code> class. The type of border extension can be specified as a <code>RenderingHint</code> to the <code>JAI.create</code> method. If no border extension type is provided, a default extension of <code>BorderExtender.BORDER_COPY</code> will be used to perform the extension. See <a href="Programming-environ.doc.html#55991">Section &#32;3.7.3, "Rendering Hints</a>."
</a><P></dl>

3.	 Create the warp operation with the <code>JAI.create</code> method.<p>
</ul>
<a href="Geom-image-manip.doc.html#69555">Listing &#32;8-8</a> shows a sample code for a simple second-order warp operation.<p>
<caption><font size=-1><b>
<a name="69555">
<center><font size=-1><b><i>Listing 8-8	</i><img src="shared/sm-blank.gif" border=0> Example of a Second-order Warp</b></font></center>
</a><p>
</b></font></caption>
<hr>
<tr valign=top><td><pre>     // Create WarpPolynomial object for a polynomial warp
     // operation.
     WarpPolynomial warp;
          float[] coeffs = { 1.0F, 0.0F, 0.0F, 0.0F, 1.0F, 0.0F };
</pre>
<tr valign=top><td><pre>     // Create the ParameterBlock and add the parameters to it.
     ParameterBlock pb = new ParameterBlock();
          pb.addSource(srcImage);
          pb.add(warp);
          pb.add(new InterpolationNearest());
</pre>
<tr valign=top><td><pre>     // Create the warp operation.
     dstImage = JAI.create("warp", pb);
</pre>

<hr>

<p><a name="58097">
<h3>8.7.2	<img src="shared/space.gif">Polynomial Warp</h3>
</a>The <code>WarpPolynomial</code> class provides a polynomial-based description of an image warp. The mapping is defined by two bivariate polynomial functions <em>X</em>(<em>x</em>, <em>y</em>) and <em>Y</em>(<em>x</em>, <em>y</em>) that define the source <em>x</em> and <em>y</em> positions that map to a given destination (<em>x</em>, &#32;<em>y</em>) pixel coordinate.
<p>The functions <em>X</em>(<em>x</em>, <em>y</em>) and <em>Y</em>(<em>x</em>, <em>y</em>) have the form:
<p>
<p>
<a name="58232">
<ul><table>
<tr><td width=430><img src="Geom-image-manip.doc.anc13.gif"> </td>
<td>(8.3)</td></tr>
</table></ul>
</a>
The <code>WarpPolynomial</code> constructor takes a <code>coeffs</code> parameter that must contain a number of coefficients of the form (<em>n</em> + 1)(<em>n</em> + 2) for some <em>n</em>, where <em>n</em> is the degree power of the polynomial. The coefficients appear in the following order:
<p><dl>
<a name="58507">
<dt><dd> <img src="Geom-image-manip.doc.anc14.gif">
</a><P></dl>
with the coefficients of the polynomial defining the source <em>x</em> coordinates appearing before those defining the <em>y</em> coordinates.
<p>The source (<em>x</em>, <em>y</em>) coordinate is pre-scaled by the factors <code>preScaleX</code> and <code>preScaleY</code> prior to the evaluation of the polynomial. The result of the polynomial evaluations are scaled by <code>postScaleX</code> and <code>postScaleY</code> to produce the destination pixel coordinates. This process allows for better precision of the results.
<p>The number of points needed to control the alignment of the image relates directly to the order of warp. Three control points constitute a first-order warp. Six points constitute a second-order warp. The number of points required for each degree of warp are as follows:<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="64068">
Degree of Warp
</a><th><a name="64070">
Number of Points
</a>
<tr valign=top><td><a name="64072">
1</a><br><td><a name="64074">
3</a><br>
<tr valign=top><td><a name="64076">
2</a><br><td><a name="64078">
6</a><br>
<tr valign=top><td><a name="64080">
3</a><br><td><a name="64082">
10</a><br>
<tr valign=top><td><a name="64084">
4</a><br><td><a name="64086">
15</a><br>
<tr valign=top><td><a name="64088">
5</a><br><td><a name="64090">
21</a><br>
<tr valign=top><td><a name="64092">
6</a><br><td><a name="64094">
28</a><br>
<tr valign=top><td><a name="64096">
7</a><br><td><a name="64098">
36</a><br>

</Table>

<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.WarpPolynomial
</code>
<hr>
</td>
</table><pre><ul>
<li>WarpPolynomial(float[] coeffs)
<p></ul></pre><dl>
<a name="58446">
<dt><dd> constructs a <code>WarpPolynomial</code> with pre- and post-scale factors of 1.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td><em>Parameters</em>:
<p><td><code>coeffs</code>
<p><td>The destination to source transform coefficients.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>WarpPolynomial(float[] coeffs, float preScaleX, float 
       preScaleY, float postScaleX, float postScaleY)
<p></ul></pre><dl>
<a name="62957">
<dt><dd> constructs a <code>WarpPolynomial</code> with a given transform mapping destination pixels into source space. Note that this is the inverse of the customary specification of the mapping of an image. <p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td><em>Parameters</em>:
<p><td><code>coeffs</code>
<p><td>The destination-to-source transform coefficients.
<p>
<tr valign=top><td>
<p><td><code>preScaleX</code>
<p><td>The scale factor to apply to source <em>x</em> positions.
<p>
<tr valign=top><td>
<p><td><code>preScaleY</code>
<p><td>The scale factor to apply to source <em>y</em> positions.
<p>
<tr valign=top><td>
<p><td><code>postScaleX</code>
<p><td>The scale factor to apply to destination <em>x</em> positions.
<p>
<tr valign=top><td>
<p><td><code>postScaleY</code>
<p><td>The scale factor to apply to destination <em>y</em> positions.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>float[] getCoeffs()
<p></ul></pre><dl>
<a name="63014">
<dt><dd> returns the raw coefficients array.
</a><P></dl>
<pre><ul>
<li>int getDegree()
<p></ul></pre><dl>
<a name="63024">
<dt><dd> returns the degree of the warp polynomials.
</a><P></dl>
<pre><ul>
<li>static WarpPolynomial createWarp(float[] sourceCoords, 
       int &#32;sourceOffset, float[] destCoords, int destOffset, 
       int &#32;numCoords, float preScaleX, float preScaleY, 
       float &#32;postScaleX, float postScaleY, int degree)
<p></ul></pre><dl>
<a name="63075">
<dt><dd> returns an instance of <code>WarpPolynomial</code> or its subclasses that approximately maps the given scaled destination image coordinates into the given scaled source image coordinates.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td><em>Parameters</em>:
<p><td><code>sourceCoords</code>
<p><td>An array of floats containing the source coordinates with <em>x</em> and <em>y</em> alternating.
<p>
<tr valign=top><td>
<p><td><code>sourceOffset</code>
<p><td>The initial entry of <code>sourceCoords</code> to be used.
<p>
<tr valign=top><td>
<p><td><code>destCoords</code>
<p><td>An array of floats containing the destination coordinates with <em>x</em> and <em>y</em> alternating.
<p>
<tr valign=top><td>
<p><td><code>destOffset</code>
<p><td>The initial entry of <code>destCoords</code> to be used.
<p>
<tr valign=top><td>
<p><td><code>numCoords</code>
<p><td>The number of coordinates from <code>sourceCoords</code> and <code>destCoords</code> to be used.
<p>
<tr valign=top><td>
<p><td><code>preScaleX</code>
<p><td>The scale factor to apply to source <em>x</em> positions.
<p>
<tr valign=top><td>
<p><td><code>preScaleY</code>
<p><td>The scale factor to apply to source <em>y</em> positions.
<p>
<tr valign=top><td>
<p><td><code>postScaleX</code>
<p><td>The scale factor to apply to destination <em>x</em> positions.
<p>
<tr valign=top><td>
<p><td><code>postScaleY</code>
<p><td>The scale factor to apply to destination <em>y</em> positions.
<p>
<tr valign=top><td>
<p><td><code>degree</code>
<p><td>The desired degree of the warp polynomials.
<p>

</Table>

</a><P></dl>
<a name="62828">
<h3>8.7.3	<img src="shared/space.gif">General Polynomial Warp</h3>
</a>The <code>WarpGeneralPolynomial</code> class provides a concrete implementation of <code>WarpPolynomial</code> for polynomials of a higher degree.
<p>The mapping is defined by two bivariate polynomial functions <em>X</em>(<em>x</em>, <em>y</em>) and <em>Y</em>(<em>x</em>, <em>y</em>) that define the source <em>X</em> and <em>Y</em> positions that map to a given destination (<em>x</em>, <em>y</em>) pixel coordinate.
<p>The functions <em>X</em>(<em>x</em>, <em>y</em>) and <em>Y</em>(<em>x</em>, <em>y</em>) have the form:
<p>
<p>
<a name="72545">
<ul><table>
<tr><td width=430><hr>
<center><img src="Geom-image-manip.doc.ancA7.gif"></center><hr>
 </td>
<td>(8.4)</td></tr>
</table></ul>
</a>
The <code>xCoeffs</code> and <code>yCoeffs</code> parameters must contain the same number of coefficients of the form (<em>n</em> + 1)(<em>n</em> + 2)/2 for some <em>n</em>, where <em>n</em> is the non-negative degree power of the polynomial. The coefficients, in order, are associated with the terms:
<p><dl>
<a name="72603">
<dt><dd> 1, x, y, x<sup>2</sup>, x*y, y<sup>2</sup>, ..., x<sup>n</sup>, x<sup>(n - 1)</sup>*y, ..., x*y<sup>(n - 1)</sup>, y<sup>n</sup>
</a><P></dl>
and coefficients of value 0 can not be omitted.
<p>The destination pixel coordinates (the arguments to the X() and Y() functions) are given in normal integral pixel coordinates, while the output of the functions is given in fixed-point, subpixel coordinates with a number of fractional bits specified by the <code>subsampleBitsH</code> and <code>subsampleBitsV</code> parameters.
<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.WarpGeneralPolynomial
</code>
<hr>
</td>
</table><pre><ul>
<li>WarpGeneralPolynomial(float[] xCoeffs, float[] yCoeffs)
<p></ul></pre><dl>
<a name="63543">
<dt><dd> constructs a <code>WarpGeneralPolynomial</code> with pre- and post-scale factors of 1.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=2><em>Parameters</em>:
<p><td><code>xCoeffs</code>
<p><td>The destination to source transform coefficients for the <em>x</em> coordinate.
<p>
<tr valign=top><td><code>yCoeffs</code>
<p><td>The destination to source transform coefficients for the <em>y</em> coordinate.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>WarpGeneralPolynomial(float[] xCoeffs, float[] yCoeffs, 
       float &#32;preScaleX,  float &#32;preScaleY, float postScaleX, 
       float &#32;postScaleY)
<p></ul></pre><dl>
<a name="63464">
<dt><dd> constructs a <code>WarpGeneralPolynomial</code> with a given transform mapping destination pixels into source space. Note that this is the inverse of the customary specification of the mapping of an image.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=6><em>Parameters</em>:
<p><td><code>xCoeffs</code>
<p><td>The destination to source transform coefficients for the <em>x</em> coordinate.
<p>
<tr valign=top><td><code>yCoeffs</code>
<p><td>The destination to source transform coefficients for the <em>y</em> coordinate.
<p>
<tr valign=top><td><code>preScaleX</code>
<p><td>The scale factor to apply to source <em>x</em> positions.
<p>
<tr valign=top><td><code>preScaleY</code>
<p><td>The scale factor to apply to source <em>y</em> positions.
<p>
<tr valign=top><td><code>postScaleX</code>
<p><td>The scale factor to apply to destination <em>x</em> positions.
<p>
<tr valign=top><td><code>postScaleY</code>
<p><td>The scale factor to apply to destination <em>y</em> positions.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>float[] warpSparseRect(int x, int y, int width, int height, 
       int &#32;periodX, int periodY, float[] destRect)
<p></ul></pre><dl>
<a name="63596">
<dt><dd> computes the source subpixel positions for a given rectangular destination region, subsampled with an integral period.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=7><em>Parameters</em>:
<p><td><code>x</code>
<p><td>The minimum <em>X</em> coordinate of the destination region.
<p>
<tr valign=top><td><code>y</code>
<p><td>The minimum <em>Y</em> coordinate of the destination region.
<p>
<tr valign=top><td><code>width</code>
<p><td>The width of the destination region.
<p>
<tr valign=top><td><code>height</code>
<p><td>The height of the destination region.
<p>
<tr valign=top><td><code>periodX</code>
<p><td>The horizontal sampling period.
<p>
<tr valign=top><td><code>periodY</code>
<p><td>The horizontal sampling period.
<p>
<tr valign=top><td><code>destRect</code>
<p><td>An int array containing at least <hr>
<center><img src="Geom-image-manip.doc.ancA8.gif"></center><hr>
 elements, or null. If null, a new array will be constructed.
<p>

</Table>

</a><P></dl>
<a name="62411">
<h3>8.7.4	<img src="shared/space.gif">Grid Warp</h3>
</a>If polynomial warping is impractical, the image may be warped in pieces using grid warping, also known as <em>control grid interpolation</em>. In the most common implementation of grid warping, specified input control points form a grid of contiguous, horizontally-oriented rectangles in the output image. The mapping from destination pixels to source positions is described by bilinear interpolation between a rectilinear grid of points with known mappings.
<p>Given a destination pixel coordinate (<em>x</em>, <em>y</em>) that lies within a cell having corners at (<em>x</em>0, <em>y</em>0), (<em>x</em>1, <em>y</em>0), (<em>x</em>0, <em>y</em>1), and (<em>x</em>1, <em>y</em>1), with source coordinates defined at each respective corner equal to (<em>sx</em>0, <em>sy</em>0), (<em>sx</em>1, <em>sy</em>1), (<em>sx</em>2, <em>sy</em>2), and (<em>sx</em>3, <em>sy</em>3), the source position (<em>sx</em>, <em>sy</em>) that maps onto (<em>x</em>, <em>y</em>) is given by the following equations:
<p>
<p>
<a name="62418">
<ul><table>
<tr><td width=430><img src="Geom-image-manip.doc.anc7.gif"> </td>
<td>(8.5)</td></tr>
</table></ul>
</a><p>
<a name="62423">
<ul><table>
<tr><td width=430><img src="Geom-image-manip.doc.anc8.gif"> </td>
<td>(8.6)</td></tr>
</table></ul>
</a><p>
<a name="62428">
<ul><table>
<tr><td width=430><img src="Geom-image-manip.doc.anc9.gif"> </td>
<td>(8.7)</td></tr>
</table></ul>
</a><p>
<a name="62433">
<ul><table>
<tr><td width=430><img src="Geom-image-manip.doc.anc10.gif"> </td>
<td>(8.8)</td></tr>
</table></ul>
</a>
The source <em>x</em> and <em>y</em> values are interpolated horizontally along the top and bottom edges of the grid cell, and the results are interpolated vertically, as shown in <a href="Geom-image-manip.doc.html#62467">Figure &#32;8-10</a>.
<p><a name="67644">
 <hr>
<center><img src="Geom-image-manip.doc.anc11.gif"></center><hr>

</a>
<a name="62467">
<center><font size=-1><b><i>Figure 8-10	</i><img src="shared/sm-blank.gif" border=0> Warp Grid</b></font></center>
</a><p>
The grid is defined by a set of equal-sized cells starting at (<code>xStart</code>, <code>yStart</code>). The width of each cell is defined by the <code>xStep</code> parameter and the height is defined by the <code>yStep</code> parameter. There are <code>xNumCells</code> cells horizontally and <code>yNumCells</code> cells vertically.
<p>The degree of warping within each cell is defined by the values in the <code>warpPositions</code> parameter. This parameter must contain the following values:
<p><dl>
<a name="62472">
<dt><dd> <img src="Geom-image-manip.doc.anc12.gif">
</a><P></dl>
These values alternately contain the source <em>x</em> and <em>y</em> coordinates that map to the upper-left corner of each cell in the destination image. The cells are enumerated in row-major order, that is, all the grid points along a row are enumerated first, then the gird points for the next row are enumerated, and so on.
<p>For example, if <code>xNumCells</code> is 2 and <code>yNumCells</code> is 1, the order of the data in the table would be as follows:
<p><pre>     x00, y00, x10, y10, x20, y20, x01, y01, x11, y11, x21, y21
</pre>for a total of 2(2 + 1)(1 + 1) = 12 elements.
<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.WarpGrid
</code>
<hr>
</td>
</table><pre><ul>
<li>WarpGrid(int xStart, int xStep, int xNumCells, int yStart, 
       int &#32;yStep, int yNumCells, float[] warpPositions)
<p></ul></pre><dl>
<a name="62478">
<dt><dd> constructs a <code>WarpGrid</code> with a given grid-based transform mapping destination pixels into source space. Note that this is the inverse of the customary specification of the mapping of an image.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=7><em>Parameters</em>:
<p><td><code>xStart</code>
<p><td>The minimum <em>x</em> coordinate of the grid.
<p>
<tr valign=top><td><code>xStep</code>
<p><td>The horizontal spacing between grid cells.
<p>
<tr valign=top><td><code>xNumCells</code>
<p><td>The number of grid cell columns.
<p>
<tr valign=top><td><code>yStart</code>
<p><td>The minimum <em>y</em> coordinate of the grid.
<p>
<tr valign=top><td><code>yStep</code>
<p><td>The vertical spacing between grid cells.
<p>
<tr valign=top><td><code>yNumCells</code>
<p><td>The number of grid cell rows.
<p>
<tr valign=top><td><code>warp-Positions</code>
<p><td>A float array of length <hr>
<center><img src="Geom-image-manip.doc.ancA16.gif"></center><hr>
 containing the warp positions at the grid points in row-major order.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>WarpGrid(Warp master, int xStart, int xStep, int xNumCells, 
       int &#32;yStart, int yStep, int yNumCells)
<p></ul></pre><dl>
<a name="62535">
<dt><dd> constructs a <code>WarpGrid</code> object by sampling the displacements given by another <code>Warp</code> object of any kind.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td><em>Parameters</em>:
<p><td><code>master</code>
<p><td>The <code>Warp</code> object used to initialized the grid displacements.
<p>
<tr valign=top><td>
<p><td><code>xStart</code>
<p><td>The minimum <em>x</em> coordinate of the grid.
<p>
<tr valign=top><td>
<p><td><code>xStep</code>
<p><td>The horizontal spacing between grid cells.
<p>
<tr valign=top><td>
<p><td><code>xNumCells</code>
<p><td>The number of grid cell columns.
<p>
<tr valign=top><td>
<p><td><code>yStart</code>
<p><td>The minimum <em>y</em> coordinate of the grid.
<p>
<tr valign=top><td>
<p><td><code>yStep</code>
<p><td>The vertical spacing between grid cells.
<p>
<tr valign=top><td>
<p><td><code>yNumCells</code>
<p><td>The number of grid cell rows.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>float[] warpSparseRect(int x, int y, int width, int height, 
       int &#32;periodX, int periodY, float[] destRect)
<p></ul></pre><dl>
<a name="62592">
<dt><dd> computes the source subpixel positions for a given rectangular destination region. The destination region is specified using normal integer (full pixel) coordinates. The source positions returned by the method are specified in fixed point, subpixel coordinates using the of <code>subsampleBitsH</code> and <code>subsampleBitsV</code> parameters.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td><em>Parameters</em>:
<p><td><code>x</code>
<p><td>The minimum <em>x</em> coordinate of the destination region.
<p>
<tr valign=top><td>
<p><td><code>y</code>
<p><td>The minimum <em>y</em> coordinate of the destination region.
<p>
<tr valign=top><td>
<p><td><code>width</code>
<p><td>The width of the destination region.
<p>
<tr valign=top><td>
<p><td><code>height</code>
<p><td>The height of the destination region.
<p>
<tr valign=top><td>
<p><td><code>periodX</code>
<p><td>The horizontal sampling period.
<p>
<tr valign=top><td>
<p><td><code>periodY</code>
<p><td>The vertical sampling period.
<p>
<tr valign=top><td>
<p><td><code>destRect</code>
<p><td>An int array containing at least <hr>
<center><img src="Geom-image-manip.doc.anc30.gif"></center><hr>
  elements, or null. If null, a new array will be constructed.
<p>

</Table>

</a><P></dl>
<a name="58581">
<h3>8.7.5	<img src="shared/space.gif">Quadratic Warp</h3>
</a>The <code>WarpQuadratic</code> class provides a quadratic-based description of an image warp. The source position (<em>x</em>', <em>y</em>') of a point (<em>x</em>, <em>y</em>) is given by the following quadratic bivariate polynomial:
<p>
<p>
<a name="58582">
<ul><table>
<tr><td width=430><img src="Geom-image-manip.doc.anc15.gif"> </td>
<td>(8.9)</td></tr>
</table></ul>
</a>
<table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.WarpQuadratic
</code>
<hr>
</td>
</table><pre><ul>
<li>WarpQuadratic(float[] xCoeffs, float[] yCoeffs, 
       float &#32;preScaleX, float preScaleY, float postScaleX, 
       float &#32;postScaleY)
<p></ul></pre><dl>
<a name="72773">
<dt><dd> constructs a WarpQuadratic with a given transform mapping destination pixels into source space. Note that this is the inverse of the customary specification of the mapping of an image. The coeffs arrays must each contain six floats corresponding to the coefficients c1, c2, etc. as shown in the class comment..<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=6><em>Parameters</em>:
<p><td><code>xCoeffs</code>
<p><td>The six destination-to-source transform coefficients for the <em>x</em> coordinate.
<p>
<tr valign=top><td><code>yCoeffs</code>
<p><td>The six destination-to-source transform coefficients for the <em>y</em> coordinate.
<p>
<tr valign=top><td><code>preScaleX</code>
<p><td>The scale factor to apply to source <em>x</em> positions.
<p>
<tr valign=top><td><code>preScaleY</code>
<p><td>The scale factor to apply to source <em>y</em> positions.
<p>
<tr valign=top><td><code>postScaleX</code>
<p><td>The scale factor to apply to destination <em>x</em> positions.
<p>
<tr valign=top><td><code>postScaleY</code>
<p><td>The scale factor to apply to destination <em>y</em> positions.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>WarpQuadratic(float[] xCoeffs, float[] yCoeffs)
<p></ul></pre><dl>
<a name="72769">
<dt><dd> constructs a WarpQuadratic with pre- and post-scale factors of 1.
</a><P></dl>
<pre><ul>
<li>float[] warpSparseRect(int x, int y, int width, int height, 
       int &#32;periodX, int periodY, float[] destRect)
<p></ul></pre><dl>
<a name="72818">
<dt><dd> computes the source subpixel positions for a given rectangular destination region, subsampled with an integral period. The destination region is specified using normal integral (full pixel) coordinates. The source positions returned by the method are specified in floating point.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td><em>Parameters</em>:<em></em>
<p><td><code>x</code>
<p><td>The minimum <em>x</em> coordinate of the destination region.
<p>
<tr valign=top><td>
<p><td><code>y</code>
<p><td>The minimum <em>y</em> coordinate of the destination region.
<p>
<tr valign=top><td>
<p><td><code>width</code>
<p><td>The width of the destination region.
<p>
<tr valign=top><td>
<p><td><code>height</code>
<p><td>The height of the destination region.
<p>
<tr valign=top><td>
<p><td><code>periodX</code>
<p><td>The horizontal sampling period.
<p>
<tr valign=top><td>
<p><td><code>periodY</code>
<p><td>The vertical sampling period.
<p>
<tr valign=top><td>
<p><td><code>destRect</code>
<p><td>A float array containing at least <hr>
<center><img src="Geom-image-manip.doc.ancA9.gif"></center><hr>
 elements, or null. If null, a new array will be constructed.
<p>

</Table>

</a><P></dl>
<a name="66987">
<h3>8.7.6	<img src="shared/space.gif">Cubic Warp</h3>
</a>The <code>WarpCubic</code> class performs a cubic-based image warp. The source position (<em>x</em>', <em>y</em>') of a point (<em>x</em>, <em>y</em>) is given by the following cubic polynomial:
<p>
<p>
<a name="62684">
<ul><table>
<tr><td width=430><img src="Geom-image-manip.doc.anc18.gif"> </td>
<td>(8.10)</td></tr>
</table></ul>
</a><p>
<a name="62690">
<ul><table>
<tr><td width=430><img src="Geom-image-manip.doc.anc19.gif"> </td>
<td>(8.11)</td></tr>
</table></ul>
</a>
<table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.WarpCubic
</code>
<hr>
</td>
</table><pre><ul>
<li>WarpCubic(float[] xCoeffs, float[] yCoeffs, float preScaleX, 
       float preScaleY, float postScaleX, float postScaleY)
<p></ul></pre><dl>
<a name="62727">
<dt><dd> constructs a <code>WarpCubic</code> with a given transform mapping destination pixels into source space. Note that this is the inverse of the customary specification of the mapping of an image. The <code>coeffs</code> array must contain 12 floats corresponding to the coefficients a, b, etc. as shown in the class comment.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td><em>Parameters</em>:
<p><td><code>xCoeffs</code>
<p><td>The ten destination to source transform coefficients for the <em>x</em> coordinate.
<p>
<tr valign=top><td>
<p><td><code>yCoeffs</code>
<p><td>The ten destination to source transform coefficients for the <em>y</em> coordinate.
<p>
<tr valign=top><td>
<p><td><code>preScaleX</code>
<p><td>The scale factor to apply to source <em>x</em> positions.
<p>
<tr valign=top><td>
<p><td><code>preScaleY</code>
<p><td>The scale factor to apply to source <em>y</em> positions.
<p>
<tr valign=top><td>
<p><td><code>postScaleX</code>
<p><td>The scale factor to apply to destination <em>x</em> positions.
<p>
<tr valign=top><td>
<p><td><code>postScaleY</code>
<p><td>The scale factor to apply to destination <em>y</em> positions.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>WarpCubic(float[] xCoeffs, float[] yCoeffs)
<p></ul></pre><dl>
<a name="62763">
<dt><dd> constructs a <code>WarpCubic</code> with pre- and post-scale factors of 1.
</a><P></dl>
<pre><ul>
<li>float[] warpSparseRect(int x, int y, int width, int height, 
       int &#32;periodX, int periodY, float[] destRect)
<p></ul></pre><dl>
<a name="62801">
<dt><dd> computes the source subpixel positions for a given rectangular destination region, subsampled with an integral period.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=7><em>Parameters</em>:
<p><td><code>x</code>
<p><td>The minimum <em>x</em> coordinate of the destination region.
<p>
<tr valign=top><td><code>y</code>
<p><td>The minimum <em>y</em> coordinate of the destination region.
<p>
<tr valign=top><td><code>width</code>
<p><td>The width of the destination region.
<p>
<tr valign=top><td><code>height</code>
<p><td>The height of the destination region.
<p>
<tr valign=top><td><code>periodX</code>
<p><td>The horizontal sampling period.
<p>
<tr valign=top><td><code>periodY</code>
<p><td>The vertical sampling period.
<p>
<tr valign=top><td><code>destRect</code>
<p><td>A float array containing at least <hr>
<center><img src="Geom-image-manip.doc.ancA10.gif"></center><hr>
 elements, or null. If null, a new array will be constructed.
<p>

</Table>

</a><P></dl>
<a name="58571">
<h3>8.7.7	<img src="shared/space.gif">Perspective Warp</h3>
</a>Perspective distortions in images caused by camera-to-target viewing angle can be restored through perspective warping. Perspective distortion appears as the reduction in scale of an object that recedes from the foreground into the background of the image.
<p>The <code>WarpPerspective</code> class provides a perspective (projective) warp. The transform is specified as a mapping from destination space to source space. In other words, it is the inverse of the normal specification of a perspective image transformation. See <a href="Geom-image-manip.doc.html#55959">Section &#32;8.4, "Perspective Transformation</a>," for a description of the <code>PerspectiveTransform</code> class.
<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.WarpPerspective
</code>
<hr>
</td>
</table><pre><ul>
<li>WarpPerspective(PerspectiveTransform transform)
<p></ul></pre><dl>
<a name="58775">
<dt><dd> constructs a <code>WarpPerspective</code> with a given transform mapping destination pixels into source space. Note that this is the inverse of the customary specification of perspective mapping of an image.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td><em>Parameters</em>:
<p><td><code>transform</code>
<p><td>The destination-to-source transform.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>PerspectiveTransform getTransform()
<p></ul></pre><dl>
<a name="58804">
<dt><dd> returns a clone of the <code>PerspectiveTransform</code> associated with this <code>WarpPerspective</code> object.
</a><P></dl>
<pre><ul>
<li>int[] warpSparseRect(int x, int y, int width, int height, 
       int &#32;periodX, int periodY, float[] destRect)
<p></ul></pre><dl>
<a name="58838">
<dt><dd> computes the source subpixel positions for a given rectangular destination regions subsampled with an integral period. The destination region is specified using normal integral (full pixel) coordinates. The source positions returned by the method are specified in floating-point.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td><em>Parameters</em>:
<p><td><code>x</code>
<p><td>The minimum <em>x</em> coordinate of the destination region.
<p>
<tr valign=top><td>
<p><td><code>y</code>
<p><td>The minimum <em>y</em> coordinate of the destination region.
<p>
<tr valign=top><td>
<p><td><code>width</code>
<p><td>The width of the destination region.
<p>
<tr valign=top><td>
<p><td><code>height</code>
<p><td>The height of the destination region.
<p>
<tr valign=top><td>
<p><td><code>periodX</code>
<p><td>The horizontal sampling period.
<p>
<tr valign=top><td>
<p><td><code>periodY</code>
<p><td>The vertical sampling period.
<p>
<tr valign=top><td>
<p><td><code>destRect</code>
<p><td>A float array containing at least <hr>
<center><img src="Geom-image-manip.doc.ancA12.gif"></center><hr>
 elements, or null. If null, a new array will be constructed.
<p>

</Table>

</a><P></dl>
<a name="58577">
<h3>8.7.8	<img src="shared/space.gif">Affine Warp</h3>
</a>The <code>WarpAffine</code> class provides an affine-based warp. The transform is specified as a mapping from destination space to source space. In other words, it is the inverse of the normal specification of an affine image transformation.
<p>The source position (<em>x</em>', <em>y</em>') of a point (<em>x</em>, <em>y</em>) is given by the quadratic bivariate polynomial:
<p>
<p>
<a name="67682">
<ul><table>
<tr><td width=430><img src="Geom-image-manip.doc.anc21.gif"> </td>
<td>(8.12)</td></tr>
</table></ul>
</a>
<a href="Geom-image-manip.doc.html#70181">Listing &#32;8-9</a> shows a code sample for an affine-based warp operation.<p>
<caption><font size=-1><b>
<a name="70181">
<center><font size=-1><b><i>Listing 8-9	</i><img src="shared/sm-blank.gif" border=0> Example Affine Warp &#32;</b></font></center>
</a><p>
</b></font></caption>
<hr>
<tr valign=top><td><pre>     // Create the transform parameter (WarpAffine).
     double m00 = 0.8;
     double m10 = 0.3;
     double m01 = -0.7;
     double m11 = 1.4;
     double m02 = 230.3;
     double m12 = -115.7;
     AffineTransform transform = new AffineTransform(m00, m10,
                                                     m01, m11,
                                                     m02, m12);
     Warp warp = new WarpAffine(transform);
</pre>
<tr valign=top><td><pre>     // Create the interpolation parameter.
     Interpolation interp = new InterpolationNearest(8);
</pre>
<tr valign=top><td><pre>     // Create the ParameterBlock.
     ParameterBlock pb = new ParameterBlock();
     pb.addSource(src);
     pb.add(warp);
     pb.add(interp);
</pre>
<tr valign=top><td><pre>     // Create the warp operation.
     return (RenderedImage)JAI.create("warp", pb);
</pre>

<hr>

<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.WarpAffine
</code>
<hr>
</td>
</table><pre><ul>
<li>public WarpAffine(float[] xCoeffs, float[] yCoeffs, 
       float &#32;preScaleX, float &#32;preScaleY, float postScaleX, 
       float &#32;postScaleY)
<p></ul></pre><dl>
<a name="67709">
<dt><dd> constructs a <code>WarpAffine</code> with a given transform mapping destination pixels into source space. The transform is given by:
</a><P></dl>
<pre>        x' = xCoeffs[0] + xCoeffs[1]*x + xCoeffs[2]*y;
        y' = yCoeffs[0] + yCoeffs[1]*x + yCoeffs[2]*y;
</pre><dl>
<a name="73008">
<dt><dd> where x' and y' are the source image coordinates and x and y are the destination image coordinates.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=6><em>Parameters</em>:
<p><td><code>xCoeffs</code>
<p><td>The three destination-to-source transform coefficients for the <em>x</em> coordinate.
<p>
<tr valign=top><td><code>yCoeffs</code>
<p><td>The three destination-to-source transform coefficients for the <em>y</em> coordinate.
<p>
<tr valign=top><td><code>preScaleX</code>
<p><td>The scale factor to apply to source <em>x</em> positions.
<p>
<tr valign=top><td><code>preScaleY</code>
<p><td>The scale factor to apply to source <em>y</em> positions.
<p>
<tr valign=top><td><code>postScaleX</code>
<p><td>The scale factor to apply to destination <em>x</em> positions.
<p>
<tr valign=top><td><code>postScaleY</code>
<p><td>The scale factor to apply to destination <em>y</em> positions.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>WarpAffine(float[] xCoeffs, float[] yCoeffs)
<p></ul></pre><dl>
<a name="73045">
<dt><dd> constructs a <code>WarpAffine</code> with pre- and post-scale factors of 1.
</a><P></dl>
<pre><ul>
<li>public WarpAffine(AffineTransform transform, float preScaleX, 
       float preScaleY, float postScaleX, float postScaleY)
<p></ul></pre><dl>
<a name="67825">
<dt><dd> constructs a <code>WarpAffine</code> with a given transform mapping destination pixels into source space.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=5><em>Parameters</em>:
<p><td><code>transform</code>
<p><td>The destination-to-source transform.
<p>
<tr valign=top><td><code>preScaleX</code>
<p><td>The scale factor to apply to source <em>x</em> positions.
<p>
<tr valign=top><td><code>preScaleY</code>
<p><td>The scale factor to apply to source <em>y</em> positions.
<p>
<tr valign=top><td><code>postScaleX</code>
<p><td>The scale factor to apply to destination <em>x</em> positions.
<p>
<tr valign=top><td><code>postScaleY</code>
<p><td>The scale factor to apply to destination <em>y</em> positions.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>WarpAffine(AffineTransform transform)
<p></ul></pre><dl>
<a name="67909">
<dt><dd> constructs a <code>WarpAffine</code> with pre- and post-scale factors of 1.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td><em>Parameters</em>:
<p><td><code>transform</code>
<p><td>An <code>AffineTransform</code>.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>AffineTransform getTransform()
<p></ul></pre><dl>
<a name="59000">
<dt><dd> returns a clone of the <code>AffineTransform</code> associated with this <code>WarpAffine</code> object.
</a><P></dl>
<pre><ul>
<li>float[] warpSparseRect(int x, int y, int width, int height, 
       int &#32;periodX, int periodY, float[] destRect)
<p></ul></pre><dl>
<a name="67963">
<dt><dd> computes the source subpixel positions for a given rectangular destination region, subsampled with an integral period. The destination region is specified using normal integral (full pixel) coordinates. The source positions returned by the method are specified in floating point.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td><em>Parameters</em>:
<p><td><code>x</code>
<p><td>The minimum <em>x</em> coordinate of the destination region.
<p>
<tr valign=top><td>
<p><td><code>y</code>
<p><td>The minimum <em>y</em> coordinate of the destination region.
<p>
<tr valign=top><td>
<p><td><code>width</code>
<p><td>The width of the destination region.
<p>
<tr valign=top><td>
<p><td><code>height</code>
<p><td>The height of the destination region.
<p>
<tr valign=top><td>
<p><td><code>periodX</code>
<p><td>The horizontal sampling period.
<p>
<tr valign=top><td>
<p><td><code>periodY</code>
<p><td>The vertical sampling period.
<p>
<tr valign=top><td>
<p><td><code>destRect</code>
<p><td>A float array containing at least <hr>
<center><img src="Geom-image-manip.doc.ancA14.gif"></center><hr>
 elements, or null. If null, a new array will be constructed.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>Rectangle mapDestRect(Rectangle destRect)
<p></ul></pre><dl>
<a name="59106">
<dt><dd> computes a <code>Rectangle</code> that is guaranteed to enclose the region of the source that is required in order to produce a given rectangular output region.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td><em>Parameter</em>:
<p><td><code>destRect</code>
<p><td>The <code>Rectangle</code> in destination coordinates.
<p>

</Table>

</a><P></dl>

<p>
<hr><br>
 
<center>
<a href="JAITOC.fm.html"><img src="shared/contents.gif" alt="Contents"></a> <a href="Image-enhance.doc.html"><img src="shared/previous.gif" alt="Previous"></a> <a href="Analysis.doc.html"><img src="shared/next.gif" alt="Next"></a> <p><font size=5><i>Programming in Java Advanced Imaging</i></font>
</center>
<br>
 


<h5><a href="copyright.html">Copyright</a> &#169; 1999, Sun Microsystems, Inc.   All rights
reserved.</h5>


<!-- Last updated: Tue Nov 02 17:49:11 1999 -->
</blockquote>
</body>
</html>
