<html><head><title>Image Enhancement</title></head>
<body bgcolor=#ffffff>
 
<center>
<a href="JAITOC.fm.html"><img src="shared/contents.gif" alt="Contents"></a> <a href="Image-manipulation.doc.html"><img src="shared/previous.gif" alt="Previous"></a> <a href="Geom-image-manip.doc.html"><img src="shared/next.gif" alt="Next"></a> <p><font size=5><i>Programming in Java Advanced Imaging</i></font>
</center>
<br>
 
<center>
<a name="47227">
<table width=90% border=0><tr>
<td align=right><font size=3>C H A P T E R</font><font size=7><img src="shared/sm-space.gif">7</td></table>
</a></center><center>
<a name="47285">
<table width=90% border=0><tr><td align=right>
<hr size=7 noshade>
<font size=6>Image Enhancement</font></td></table>
</a></center><blockquote>
<p><br><br><br><P><font size=7><b>T</b></font>HIS chapter describes the basics of improving the visual appearance of images through enhancement operations.
<p><a name="50856">
<h2>7.1	<img src="shared/space.gif">Introduction</h2>
</a>The JAI API image enhancement operations include:
<p><ul>
<li>Adding borders<p></ul><ul>
<li>Cropping an image<p></ul><ul>
<li>Amplitude rescaling<p></ul><ul>
<li>Histogram equalization<p></ul><ul>
<li>Lookup table modification<p></ul><ul>
<li>Convolution filtering<p></ul><ul>
<li>Median filtering<p></ul><ul>
<li>Frequency domain processing<p></ul><ul>
<li>Pixel point processing<p></ul><ul>
<li>Thresholding (binary contrast enhancement)<p></ul><a name="68364">
<h2>7.2	<img src="shared/space.gif">Adding Borders to Images</h2>
</a>JAI provides two different ways of adding a border to an image. These two ways are described in the following paragraphs.
<p><a name="68604">
<h3>7.2.1	<img src="shared/space.gif">The Border Operation</h3>
</a>The <code>Border</code> operation allows you to add a simple filled border around a source image. The border extends the source image's boundaries by a specified number of pixels.The amount of extension may be specified separately for the top, bottom, and left and right sides. The following types of border fill may be specified:
<p><ul>
<li>Zero fill - the border area is extended with zeros (<code>BORDER_ZERO_FILL</code>).<p></ul><ul>
<li>Constant fill - the border area is extended with a specified constant value (<code>BORDER_CONST_FILL</code>). An array of constants must be supplied. The array must have at least one element, in which case this same constant is applied to all destination image bands. Or, it may have a different constant entry for each corresponding band. For all other border types, this <code>constants</code> parameter may be <code>null</code>.<p></ul><ul>
<li>Extend - the border area is created by copying the edge and corner pixels (<code>BORDER_COPY</code>).<p></ul><ul>
<li>Reflection - the border area is created by reflection of the image's outer edge (<code>BORDER_REFLECT</code>).<p></ul><ul>
<li>Wrap - the border area is extended by "wrapping" the image plane toroidally, that is, joining opposite edges of the image (<code>BORDER_WRAP</code>).<p></ul><a name="68385">
 <hr>
<center><img src="Image-enhance.doc.ancA9.gif"></center><hr>

</a>
<a name="68386">
<center><font size=-1><b><i>Figure 7-1	</i><img src="shared/sm-blank.gif" border=0> Image Borders</b></font></center>
</a><p>
The image layout (tile width, height, and offsets; <code>SampleModel</code> and <code>ColorModel</code>) is copied from the source. The <code>Border</code> operation takes one rendered source image and six parameters:<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="68390">
Parameters
</a><th><a name="68392">
Type
</a><th><a name="68394">
Description
</a>
<tr valign=top><td><a name="68396">
leftPad</a><br><td><a name="68398">
Integer</a><br><td><a name="68400">
The image's left padding.</a><br>
<tr valign=top><td><a name="68402">
rightPad</a><br><td><a name="68404">
Integer</a><br><td><a name="68406">
The image's right padding.</a><br>
<tr valign=top><td><a name="68408">
topPad</a><br><td><a name="68410">
Integer</a><br><td><a name="68412">
The image's top padding.</a><br>
<tr valign=top><td><a name="68414">
bottomPad</a><br><td><a name="68416">
Integer</a><br><td><a name="68418">
The image's bottom padding.</a><br>
<tr valign=top><td><a name="68420">
type</a><br><td><a name="68422">
Integer</a><br><td><a name="68424">
The border type. One of BORDER_ZERO, BORDER_CONST_FILL, BORDER_COPY, BORDER_REFLECT, or BORDER_WRAP. The default is BORDER_ZERO.</a><br>
<tr valign=top><td><a name="68426">
constant</a><br><td><a name="68428">
double</a><br><td><a name="68430">
The constants used by the BORDER_CONST_FILL.</a><br>

</Table>

<p><a name="68606">
<h3>7.2.2	<img src="shared/space.gif">Extending the Edge of an Image</h3>
</a>Some area operations, such as convolve, scale, and rotate, benefit from the addition of an extended border around the source image. The extended border comes into play when the convolution kernel overlaps the source image as the key value is scanned over it.
<p>A <code>BorderExtender</code> may be applied to an operation using a suitable hint. The hints are defined in <a href="Image-enhance.doc.html#68640">Table &#32;7-1</a>.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b><a name="68640">
<i>Table 7-1	 </i><img src="shared/sm-blank.gif" border=0> BorderExtender Hints &#32;
</a></b></font></caption>
<tr valign=top><th><a name="68644">
Name
</a><th><a name="68646">
Description
</a>
<tr valign=top><td><a name="68648">
BorderExtenderZero</a><br><td><a name="68650">
Extends an image's border by filling all pixels outside the image bounds with zeros. See <a href="Image-enhance.doc.html#72409">Section &#32;7.2.2.1, "BorderExtenderZero</a>."</a><br>
<tr valign=top><td><a name="70811">
BorderExtenderConstant</a><br><td><a name="70813">
Extends an image's border by filling all pixels outside the image bounds with constant values. See <a href="Image-enhance.doc.html#72000">Section &#32;7.2.2.2, "BorderExtenderConstant</a>."</a><br>
<tr valign=top><td><a name="68652">
BorderExtenderCopy</a><br><td><a name="68697">
Extends an image's border by filling all pixels outside the image bounds with copies of the edge pixels. Useful as a way of padding source images prior to area or geometric operations, such as convolution, scaling, or rotation. See <a href="Image-enhance.doc.html#72770">Section &#32;7.2.2.3, "BorderExtenderCopy</a>."</a><br>
<tr valign=top><td><a name="68656">
BorderExtenderWrap</a><br><td><a name="68658">
Extends an image's border by filling all pixels outside the image bounds with copies of the whole image. This form of extension is appropriate for data that is inherently periodic, such as the Fourier transform of an image, or a wallpaper pattern. See <a href="Image-enhance.doc.html#73128">Section &#32;7.2.2.4, "BorderExtenderWrap</a>."</a><br>
<tr valign=top><td><a name="68660">
BorderExtenderReflect</a><br><td><a name="68662">
Extends an image's border by filling all pixels outside the image bounds with copies of the whole image. This form of extension avoids discontinuities around the edges of the image. See <a href="Image-enhance.doc.html#73456">Section &#32;7.2.2.5, "BorderExtenderReflect</a>."</a><br>

</Table>

<p>The <code>BorderExtender</code> class is the superclass for four classes that extend a <code>WritableRaster</code> with additional pixel data taken from a <code>PlanarImage</code>. Instances of <code>BorderExtender</code> are used by the <code>PlanarImage.getExtendedData</code> and <code>PlanarImage.copyExtendedData</code> methods.
<p>The <code>PlanarImage.getExtendedData</code> method returns a copy of an arbitrary rectangular region of the image in a <code>Raster</code>. The portion of the rectangle of interest outside the bounds of the image will be computed by calling the given <code>BorderExtender</code>. If the region falls entirely within the image, the extender will not be used. Thus it is possible to use a <code>null</code> value for the <code>extender</code> parameter when it is known that no actual extension will be required. The returned <code>Raster</code> should be considered non-writable. The <code>copyExtendedData</code> method should be used if the returned <code>Raster</code> is to be modified.
<p>The <code>PlanarImage.copyExtendedData</code> method copies an arbitrary rectangular region of the <code>RenderedImage</code> into a caller-supplied <code>WritableRaster</code>. The portion of the supplied <code>WritableRaster</code> that lies outside the bounds of the image is computed by calling the given <code>BorderExtender</code>. The supplied <code>WritableRaster</code> must have a <code>SampleModel</code> that is compatible with that of the image.
<p>Each instance of <code>BorderExtender</code> has an <code>extend</code> method that takes a <code>WritableRaster</code> and a <code>PlanarImage</code>. The portion of the raster that intersects the bounds of the image will already contain a copy of the image data. The remaining area is to be filled in according to the policy of the <code>BorderImage</code> subclass. The subclasses are described in <a href="Image-enhance.doc.html#68640">Table &#32;7-1</a>.
<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.Planarimage
</code>
<hr>
</td>
</table><pre><ul>
<li>Raster getExtendedData(Rectangle region, 
       BorderExtender &#32;extender)
<p></ul></pre><dl>
<a name="68977">
<dt><dd> returns a copy of an arbitrary rectangular region of this image in a Raster.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=2><em>Parameters</em>:
<p><td><code>region</code>
<p><td>The region of the image to be returned.
<p>
<tr valign=top><td><code>extender</code>
<p><td>An instance of <code>BorderExtender</code>, used only if the region exceeds the image bounds.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>void copyExtendedData(WritableRaster dest, 
       BorderExtender &#32;extender)
<p></ul></pre><dl>
<a name="69184">
<dt><dd> copies an arbitrary rectangular region of the <code>RenderedImage</code> into a caller-supplied <code>WritableRaster</code>.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=2><em>Parameters</em>:
<p><td><code>dest</code>
<p><td>A <code>WritableRaster</code> to hold the returned portion of the image.
<p>
<tr valign=top><td><code>extender</code>
<p><td>An instance of <code>BorderExtender</code>.
<p>

</Table>

</a><P></dl>
<table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.BorderExtender
</code>
<hr>
</td>
</table><pre><ul>
<li>static BorderExtender createInstance(int extenderType)
<p></ul></pre><dl>
<a name="68824">
<dt><dd> returns an instance of <code>BorderExtender</code> that implements a given extension policy. The policies understood by this method are:<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="68880">
Policy
</a><th><a name="68882">
Description
</a>
<tr valign=top><td><a name="68884">
BORDER_ZERO</a><br><td><a name="68886">
Set sample values to zero.</a><br>
<tr valign=top><td><a name="68888">
BORDER_COPY</a><br><td><a name="68890">
Set sample values to copies of the nearest valid pixel. For example, pixels to the left of the valid rectangle will take on the value of the valid edge pixel in the same row. Pixels both above and to the left of the valid rectangle will take on the value of the upper-left pixel.</a><br>
<tr valign=top><td><a name="68892">
BORDER_REFLECT</a><br><td><a name="68918">
The output image is defined as if mirrors were placed along the edges of the source image. Thus if the left edge of the valid rectangle lies at <em>x</em> = 10, pixel (9, <em>y</em>) will be a copy of pixel (10, <em>y</em>); pixel (6, <em>y</em>) will be a copy of pixel (13, <em>y</em>).</a><br>
<tr valign=top><td><a name="68896">
BORDER_WRAP</a><br><td><a name="68938">
The source image is tiled repeatedly in the plane.</a><br>

</Table>

</a><P></dl>
<pre><ul>
<li>abstract void extend(WritableRaster raster, PlanarImage im)
<p></ul></pre><dl>
<a name="68781">
<dt><dd> fills in the portions of a given <code>Raster</code> that lie outside the bounds of a given <code>PlanarImage</code> with data derived from that <code>PlanarImage</code>.
</a><P></dl>
<a name="72409">
<h4>7.2.2.1	<img src="shared/space.gif">BorderExtenderZero</h4>
</a>The <code>BorderExtenderZero</code> class is a subclass of <code>BorderExtender</code> that implements border extension by filling all pixels outside of the image bounds with zeros. For example, <a href="Image-enhance.doc.html#73911">Figure &#32;7-2</a> shows the result of using <code>BorderExtenderZero</code> to extend an image by adding two extra rows to the top and bottom and two extra columns on the left and right sides.
<p><a name="73910">
 <hr>
<center><img src="Image-enhance.doc.anc15.gif"></center><hr>

</a>
<a name="73911">
<center><font size=-1><b><i>Figure 7-2	</i><img src="shared/sm-blank.gif" border=0> BorderExtenderZero Example</b></font></center>
</a><p>
<table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.BorderExtenderZero
</code>
<hr>
</td>
</table><pre><ul>
<li>final void extend(WritableRaster raster, PlanarImage im)
<p></ul></pre><dl>
<a name="72720">
<dt><dd> fills in the portions of a given <code>Raster</code> that lie outside the bounds of a given <code>PlanarImage</code> with zeros. The portion of Raster that lies within <code>im.getBounds</code> is not altered.
</a><P></dl>
<a name="72000">
<h4>7.2.2.2	<img src="shared/space.gif">BorderExtenderConstant</h4>
</a>The <code>BorderExtenderConstant</code> class is a subclass of <code>BorderExtender</code> that implements border extension by filling all pixels outside of the image bounds with constant values. For example, <a href="Image-enhance.doc.html#74089">Figure &#32;7-3</a> shows the result of using <code>BorderExtenderConstant</code> to extend an image by adding two extra rows to the top and bottom and two extra columns on the left and right sides.
<p>In the figure, X is the constant fill value. The set of constants is clamped to the range and precision of the data type of the <code>Raster</code> being filled. The number of constants used is given by the number of bands of the <code>Raster</code>. If the <code>Raster</code> has <em>b</em> bands, and there are <em>c</em> constants, constants 0 through <em>b</em> - 1 are used when <em>b</em> <img src="shared/chars/lt_equal.gif"> <em>c</em>. If <em>b</em> &gt; <em>c</em>, zeros are used to fill out the constants array.
<p><a name="74088">
 <hr>
<center><img src="Image-enhance.doc.anc14.gif"></center><hr>

</a>
<a name="74089">
<center><font size=-1><b><i>Figure 7-3	</i><img src="shared/sm-blank.gif" border=0> BorderExtenderConstant Example</b></font></center>
</a><p>
<table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.BorderExtenderConstant
</code>
<hr>
</td>
</table><pre><ul>
<li>BorderExtenderConstant(double[] constants)
<p></ul></pre><dl>
<a name="72359">
<dt><dd> constructs an instance of <code>BorderExtenderConstant</code> with a given set of constants. The constants are specified as an array of <code>double</code>s.
</a><P></dl>
<pre><ul>
<li>final void extend(WritableRaster raster, PlanarImage im)
<p></ul></pre><dl>
<a name="72379">
<dt><dd> fills in the portions of a given <code>Raster</code> that lie outside the bounds of a given <code>PlanarImage</code> with constant values. The portion of <code>Raster</code> that lies within <code>im.getBounds</code> is not altered.
</a><P></dl>
<a name="72770">
<h4>7.2.2.3	<img src="shared/space.gif">BorderExtenderCopy</h4>
</a>The <code>BorderExtenderCopy</code> class is a subclass of <code>BorderExtender</code> that implements border extension by filling all pixels outside of the image bounds with copies of the edge pixels. For example, <a href="Image-enhance.doc.html#74281">Figure &#32;7-4</a> shows the result of using <code>BorderExtenderCopy</code> to extend an image by adding two extra rows to the top and bottom and two extra columns on the left and right sides.
<p>Although this type of extension is not particularly visually appealing, it is useful as a way of padding source images prior to area or geometric operations, such as convolution, scaling, or rotation.
<p><a name="74280">
 <hr>
<center><img src="Image-enhance.doc.anc17.gif"></center><hr>

</a>
<a name="74281">
<center><font size=-1><b><i>Figure 7-4	</i><img src="shared/sm-blank.gif" border=0> BorderExtenderCopy Example</b></font></center>
</a><p>
<table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.BorderExtenderCopy
</code>
<hr>
</td>
</table><pre><ul>
<li>final void extend(WritableRaster raster, PlanarImage im)
<p></ul></pre><dl>
<a name="73098">
<dt><dd> fills in the portions of a given <code>Raster</code> that lie outside the bounds of a given <code>PlanarImage</code> with copies of the edge pixels of the image. The portion of <code>Raster</code> that lies within <code>im.getBounds</code> is not altered.
</a><P></dl>
<a name="73128">
<h4>7.2.2.4	<img src="shared/space.gif">BorderExtenderWrap</h4>
</a>The <code>BorderExtenderWrap</code> class is a subclass of <code>BorderExtender</code> that implements border extension by filling all pixels outside of the image bounds with copies of the whole image. For example, <a href="Image-enhance.doc.html#74469">Figure &#32;7-5</a> shows the result of using <code>BorderExtenderWrap</code> to extend an image by adding two extra rows to the top and bottom and two extra columns on the left and right sides.
<p>This form of extension is appropriate for data that is inherently periodic, such as the Fourier transform of an image or a wallpaper pattern.
<p><a name="74468">
 <hr>
<center><img src="Image-enhance.doc.anc18.gif"></center><hr>

</a>
<a name="74469">
<center><font size=-1><b><i>Figure 7-5	</i><img src="shared/sm-blank.gif" border=0> BorderExtenderWrap Example</b></font></center>
</a><p>
<table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.BorderExtenderWrap
</code>
<hr>
</td>
</table><pre><ul>
<li>final void extend(WritableRaster raster, PlanarImage im)
<p></ul></pre><dl>
<a name="73485">
<dt><dd> Fills in the portions of a given <code>Raster</code> that lie outside the bounds of a given <code>PlanarImage</code> with copies of the entire image. The portion of <code>Raster</code> that lies within <code>im.getBounds</code> is not altered.
</a><P></dl>
<a name="73456">
<h4>7.2.2.5	<img src="shared/space.gif">BorderExtenderReflect</h4>
</a>The <code>BorderExtenderReflect</code> class is a subclass of <code>BorderExtender</code> that implements border extension by filling all pixels outside the image bounds with reflected copies of the whole image. For example, <a href="Image-enhance.doc.html#74693">Figure &#32;7-6</a> shows the result of using <code>BorderExtenderReflect</code> to extend an image by adding two extra rows to the top and bottom and one extra column on the left and right sides.
<p>This form of extension avoids discontinuities around the edges of the image.
<p><a name="74688">
 <hr>
<center><img src="Image-enhance.doc.anc3.gif"></center><hr>

</a>
<a name="74693">
<center><font size=-1><b><i>Figure 7-6	</i><img src="shared/sm-blank.gif" border=0> BorderExtenderReflect Example</b></font></center>
</a><p>
<table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.BorderExtenderReflect
</code>
<hr>
</td>
</table><pre><ul>
<li>final void extend(WritableRaster raster, PlanarImage im)
<p></ul></pre><dl>
<a name="73832">
<dt><dd> Fills in the portions of a given <code>Raster</code> that lie outside the bounds of a given <code>PlanarImage</code> with suitably reflected copies of the entire image. The portion of <code>Raster</code> that lies within <code>im.getBounds</code> is not altered.
</a><P></dl>
<a name="73080">
<h2>7.3	<img src="shared/space.gif">Cropping an Image</h2>
</a>The <code>Crop</code> operation crops a rendered or renderable image to a specified rectangular area. The <em>x</em>, <em>y</em>, width, and height values are clipped to the source image's bounding box. These values are rounded to type <code>int</code> for rendered images.
<p>The <code>Crop</code> operation takes one rendered or renderable source image and four parameters. None of the parameters have default values; all must be supplied.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="76471">
Parameter
</a><th><a name="76473">
Type
</a><th><a name="76475">
Description
</a>
<tr valign=top><td><a name="76477">
x</a><br><td><a name="76479">
Float</a><br><td><a name="76481">
The <em>x</em> origin for each band.</a><br>
<tr valign=top><td><a name="76483">
y</a><br><td><a name="76485">
Float</a><br><td><a name="76487">
The <em>y</em> origin for each band.</a><br>
<tr valign=top><td><a name="76489">
width</a><br><td><a name="76491">
Float</a><br><td><a name="76493">
The width for each band.</a><br>
<tr valign=top><td><a name="76495">
height</a><br><td><a name="76497">
Float</a><br><td><a name="76499">
The height for each band.</a><br>

</Table>

<p><a name="76505">
 <hr>
<center><img src="Image-enhance.doc.anc8.gif"></center><hr>

</a>
<a name="76506">
<center><font size=-1><b><i>Figure 7-7	</i><img src="shared/sm-blank.gif" border=0> Crop Operation</b></font></center>
</a><p>
<a name="76502">
<h2>7.4	<img src="shared/space.gif">Amplitude Rescaling</h2>
</a>Amplitude rescaling provides a linear amplitude transformation of input pixel values to output pixel values. Amplitude rescaling can be used to enhance images that have insufficient contrast between the lightest and darkest values, such as caused by underexposure or overexposure of the original image.
<p>The full dynamic range of one band of an eight-bit image is 0 to 255. An underexposed image may only contain pixel values from 10 to 180, resulting in an image that does not fully use the dynamic range of the display. Such an image can be greatly improved by linearly stretching the contrast range; mapping the lowest values to 0 and the highest values to 255.
<p>The <code>rescale</code> operation takes a rendered or renderable source image and maps the pixel values of the image from one range to another range by multiplying each pixel value by one of a set of constants and then adding another constant to the result of the multiplication. If the number of constants supplied is less than the number of bands of the destination, the constant from entry 0 is applied to all the bands. Otherwise, a constant from a different entry is applied to each band. There must be at least one entry in each of the constants and offsets arrays.
<p>The pixel values of the destination image are defined by the following pseudocode:
<p><pre>     constant = (constants.length &lt; dstNumBands) ?
                 constants[0] : constants[b];
     offset = (offsets.length &lt; dstNumBands) ?
               offsets[0] : offsets[b];
     
     dst[x][y][b] = src[x][y][b]*constant + offset;
</pre>The pixel arithmetic is performed using the data type of the destination image. By default, the destination will have the same data type as the source image unless an <code>ImageLayout</code> containing a <code>SampleModel</code> with a different data type is supplied as a rendering hint.
<p>The values of the lowest and highest pixel amplitudes must be known. This information can be acquired through the <code>Extrema</code> operation (see <a href="Analysis.doc.html#54907">Section &#32;9.3, "Finding the Extrema of an Image</a>").
<p>The following equations show the relationships between the extrema and the scale and offset factors.
<p>
<p>
<a name="59303">
<ul><table>
<tr><td width=430><img src="Image-enhance.doc.anc9.gif"> </td>
<td>(7.1)</td></tr>
</table></ul>
</a><p>
<a name="59312">
<ul><table>
<tr><td width=430><img src="Image-enhance.doc.anc10.gif"> </td>
<td>(7.2)</td></tr>
</table></ul>
</a>
<dl>
<a name="59319">
<dt><dd> where <em>max</em>(<em>b</em>) and <em>min</em>(<em>b</em>) are the largest and smallest pixel values in the band, respectively.
</a><P></dl>
The <code>rescale</code> operation takes one rendered or renderable source image and two parameters:<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="61691">
Parameter
</a><th><a name="61693">
Type
</a><th><a name="61695">
Description
</a>
<tr valign=top><td><a name="61697">
constants</a><br><td><a name="61699">
double</a><br><td><a name="61701">
The per-band constants to multiply by.</a><br>
<tr valign=top><td><a name="61703">
offsets</a><br><td><a name="61705">
double</a><br><td><a name="61707">
The per-band offsets to be added.</a><br>

</Table>

<p><a name="70862">
<h2>7.5	<img src="shared/space.gif">Histogram Equalization</h2>
</a>An image histogram is an analytic tool used to measure the amplitude distribution of pixels within an image. For example, a histogram can be used to provide a count of the number of pixels at amplitude 0, the number at amplitude 1, and so on. By analyzing the distribution of pixel amplitudes, you can gain some information about the visual appearance of an image. A high-contrast image contains a wide distribution of pixel counts covering the entire amplitude range. A low contrast image has most of the pixel amplitudes congregated in a relatively narrow range.
<p>See <a href="Analysis.doc.html#54836">Section &#32;9.4, "Histogram Generation</a>," for information on how to generate a histogram for an image. The next two sections describe JAI operations that use an image histogram to enhance an image's appearance.
<p><a name="70864">
<h3>7.5.1	<img src="shared/space.gif">Piecewise Linear Mapping</h3>
</a>The <code>Piecewise</code> operation performs a piecewise linear mapping of an image's pixel values. The piecewise linear mapping is described by a set of breakpoints that are provided as an array of the form:
<p><pre>     float breakPoints[N][2][numBreakPoints]
</pre><dl>
<a name="70922">
<dt><dd> where the value of <em>N</em> may be either unity or the number of bands in the source image.
</a><P></dl>
If <em>N</em> is unity, the same set of breakpoints will be applied to all bands in the image. The abscissas of the supplied breakpoints must be monotonically increasing.
<p>The pixel values of the destination image are defined by the following pseudocode:
<p><pre>     if(src[x][y][b] &lt; breakPoints[b][0][0])
         dst[x][y][b] = breakPoints[b][1][0]);
     } else if(src[x][y][b] &gt; breakPoints[b][0][numBreakPoints-1]) {
         dst[x][y][b] = breakPoints[b][1][numBreakPoints-1]);
     } else {
         int i = 0;
         while(breakPoints[b][0][i+1] &lt; src[x][y][b]) {
             i++;
         }
         dst[x][y][b] = breakPoints[b][1][i] +
                         (src[x][y][b] - breakPoints[b][0][i])*
                         (breakPoints[b][1][i+1] - breakPoints[b][1][i])/
                         (breakPoints[b][0][i+1] - breakPoints[b][0][i]);
</pre>The <code>Piecewise</code> operation takes one rendered or renderable source image and one parameter:<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="71037">
Parameter
</a><th><a name="71039">
Type
</a><th><a name="71041">
Description
</a>
<tr valign=top><td><a name="71043">
breakPoints</a><br><td><a name="71045">
Float</a><br><td><a name="71047">
The breakpoint array.</a><br>

</Table>

<p><a href="Image-enhance.doc.html#74848">Listing &#32;7-1</a> shows a code sample of a <code>Piecewise</code> operation, showing only the construction of the piecewise-mapped image and the operation. The generation of the source image, fmt, is not shown.<p>
<caption><font size=-1><b>
<a name="74848">
<center><font size=-1><b><i>Listing 7-1	</i><img src="shared/sm-blank.gif" border=0> Example Piecewise Operation</b></font></center>
</a><p>
</b></font></caption>
<hr>
<tr valign=top><td><pre>     // Create a piecewise-mapped image emphasizing low values.
     float[][][] bp = new float[numBands][2][];
     for(int b = 0; b &lt; numBands; b++) {
         bp[b][0] = new float[] {0.0F, 32.0F, 64.0F, 255.0F};
         bp[b][1] = new float[] {0.0F, 64.0F, 112.0F, 255.0F};
     }
</pre>
<tr valign=top><td><pre>     // Create the Piecewise operation.
     RenderedOp pw = JAI.create("piecewise", fmt, bp);
</pre>

<hr>

<p><a name="71727">
<h3>7.5.2	<img src="shared/space.gif">Histogram Matching</h3>
</a>It is sometimes desirable to transform an image so that its histogram matches that of a specified functional form. The <code>MatchCDF</code> operation performs a piecewise linear mapping of the pixel values of an image such that the cumulative distribution function (CDF) of the destination image matches as closely as possible a specified cumulative distribution function.
<p>The CDF of an image is its area-normalized threshold area function. The desired CDF for the <code>MatchCDF</code> operation is described by an array of the form:
<p><pre>     float CDF[numBands][numBins[b]]
</pre><dl>
<a name="71396">
<dt><dd> where <code>numBins</code> denotes the number of bins in the histogram of the source image for band <em>b</em>.
</a><P></dl>
Each element in the array <code>CDF[b]</code> must be non-negative, the array must represent a non-decreasing sequence, and the last element of the array must be 1.0F. The source image must have a <code>Histogram</code> object available via its <code>getProperty</code> method.
<p>The <code>MatchCDF</code> operation takes one rendered or renderable source image and one parameter:<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="71456">
Parameter
</a><th><a name="71458">
Type
</a><th><a name="71460">
Description
</a>
<tr valign=top><td><a name="71462">
CDF</a><br><td><a name="71464">
Float</a><br><td><a name="71466">
The desired cumulative distribution function.</a><br>

</Table>

<p>The operation requires that the image histogram be available.
<p><a href="Image-enhance.doc.html#74900">Listing &#32;7-2</a> shows a code sample of a <code>MatchCDF</code> operation, showing only the histogram operation, construction of two different CDFs, and the operations that use them.<p>
<caption><font size=-1><b>
<a name="74900">
<center><font size=-1><b><i>Listing 7-2	</i><img src="shared/sm-blank.gif" border=0> Example MatchCDF Operation &#32;</b></font></center>
</a><p>
</b></font></caption>
<hr>
<tr valign=top><td><pre>     // Retrieves a histogram for the image.
     private static Histogram getHistogram(RenderedOp img,
                                          int binCount) {
</pre>
<tr valign=top><td><pre>         // Get the band count.
         int numBands = img.getSampleModel().getNumBands();
</pre>
<tr valign=top><td><pre>         // Allocate histogram memory.
         int[] numBins = new int[numBands];
         double[] lowValue = new double[numBands];
         double[] highValue = new double[numBands];
         for(int i = 0; i &lt; numBands; i++) {
             numBins[i] = binCount;
             lowValue[i] = 0.0;
             highValue[i] = 255.0;
         }
</pre>
<tr valign=top><td><pre>         // Create the Histogram object.
         Histogram hist = new Histogram(numBins, lowValue, highValue);
</pre>
<tr valign=top><td><pre>         // Set the ROI to the entire image.
         ROIShape roi = new ROIShape(img.getBounds());
</pre>
<tr valign=top><td><pre>         // Create the histogram op.
         RenderedOp histImage =
             JAI.create("histogram", img,
                         hist, roi, new Integer(1), new Integer(1));
</pre>
<tr valign=top><td><pre>         // Retrieve the histogram.
         hist = (Histogram)histImage.getProperty("histogram");
</pre>
<tr valign=top><td><pre>         return hist;
     }
</pre>
<tr valign=top><td><pre>     // Create an equalization CDF.
     float[][] CDFeq = new float[numBands][];
     for(int b = 0; b &lt; numBands; b++) {
         CDFeq[b] = new float[binCount];
         for(int i = 0; i &lt; binCount; i++) {
             CDFeq[b][i] = (float)(i+1)/(float)binCount;
         }
     }
</pre>
<tr valign=top><td><pre>     // Create a normalization CDF.
     double[] mean = new double[] {128.0, 128.0, 128.0};
     double[] stDev = new double[] {64.0, 64.0, 64.0};
     float[][] CDFnorm = new float[numBands][];
     for(int b = 0; b &lt; numBands; b++) {
         CDFnorm[b] = new float[binCount];
         double mu = mean[b];
         double twoSigmaSquared = 2.0*stDev[b]*stDev[b];
         CDFnorm[b][0] =
             (float)Math.exp(-mu*mu/twoSigmaSquared);
         for(int i = 1; i &lt; binCount; i++) {
             double deviation = i - mu;
             CDFnorm[b][i] = CDFnorm[b][i-1] +
                (float)Math.exp(-deviation*deviation/twoSigmaSquared);
         }
     }
     for(int b = 0; b &lt; numBands; b++) {
         double CDFnormLast = CDFnorm[b][binCount-1];
        for(int i = 0; i &lt; binCount; i++) {
            CDFnorm[b][i] /= CDFnormLast;
        }
     }
</pre>
<tr valign=top><td><pre>     // Create a histogram-equalized image.
     RenderedOp eq = JAI.create("matchcdf", fmt, CDFeq);
</pre>
<tr valign=top><td><pre>     // Create a histogram-normalized image.
     RenderedOp nm = JAI.create("matchcdf", fmt, CDFnorm);
</pre>

<hr>

<p><a name="71424">
<h2>7.6	<img src="shared/space.gif">Lookup Table Modification</h2>
</a>The lookup table modification provides a non-linear amplitude transformation. Non-linear amplitude transformation is useful if you have a non-linear amplitude response difference between the sensor that captures the image data and the display.
<p>The lookup table modification mechanism allows you to arbitrarily convert between the source image byte, short, or integer pixel value and one or more output values. The output value can be a byte, short, integer, float, or double image pixel.
<p>The input pixel value acts as an address to the lookup table inputs, as shown in <a href="Image-enhance.doc.html#51273">Figure &#32;7-8</a>. Each location in the lookup table stores the desired output value for that particular address.
<p><a name="51271">
 <hr>
<center><img src="Image-enhance.doc.anc.gif"></center><hr>

</a>
<a name="51273">
<center><font size=-1><b><i>Figure 7-8	</i><img src="shared/sm-blank.gif" border=0> Lookup Table</b></font></center>
</a><p>
The lookup table is first loaded with the necessary data. <a href="Image-enhance.doc.html#51279">Table &#32;7-2</a> shows a partial listing of an example lookup table. In this example, the input values range from 0 to 255. The output values provide a scaled square root transformation between the input and output, according to the following equation:
<p><dl>
<a name="51325">
<dt><dd> <img src="Image-enhance.doc.anc1.gif"><p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b><a name="51279">
<i>Table 7-2	 </i><img src="shared/sm-blank.gif" border=0> Example Lookup Table
</a></b></font></caption>
<tr valign=top><th><a name="51283">
Input
</a><th><a name="51285">
Output
</a>
<tr valign=top><td><a name="51287">
0</a><br><td><a name="51289">
0</a><br>
<tr valign=top><td><a name="51291">
1</a><br><td><a name="51293">
16</a><br>
<tr valign=top><td><a name="51295">
2</a><br><td><a name="51297">
23</a><br>
<tr valign=top><td><a name="51299">
3</a><br><td><a name="51301">
28</a><br>
<tr valign=top><td><a name="51303">
.</a><br><td><a name="51305">
.</a><br>
<tr valign=top><td><a name="51307">
253</a><br><td><a name="51309">
254</a><br>
<tr valign=top><td><a name="51332">
254</a><br><td><a name="51334">
255</a><br>
<tr valign=top><td><a name="51336">
255</a><br><td><a name="51338">
255</a><br>

</Table>

</a><P></dl>
This example provides a non-linear amplitude transformation between input and output pixel values, in which the smaller input amplitude values are amplified and the larger input values are attenuated. Other types of lookup values can be used to solve nearly any non-linear amplitude scaling problem.
<p><a name="51408">
<h3>7.6.1	<img src="shared/space.gif">Creating the Lookup Table</h3>
</a>The <code>LookupTableJAI</code> object represents a single- or multi-banded table or a color cube of any supported data types. A single- or multi-banded source image of integer data types is passed through the table and transformed into a single- or multi-banded destination image of both integral and float or double data types.
<p>The <code>LookupTableJAI</code> object is used for the <code>ErrorDiffusion</code> operation, where it describes a color map, and the <code>Lookup</code> operation, where it describes the lookup table. For the <code>Lookup</code> operation, the table data may cover only a subrange of the legal range of the input data type. The subrange is selected by means of an offset parameter that is to be subtracted from the input value before indexing into the table array.
<p>The procedures for constructing a lookup table vary slightly, depending on whether the input image is single-banded or multi-banded. For a single-band input image, you construct a single lookup table. For a multi-band image, you construct a single lookup table with entries for each band.
<p><a name="56774">
<h4>7.6.1.1	<img src="shared/space.gif">Creating a Single-band Lookup Table</h4>
</a>The single-banded lookup table contains data for a single channel or image component. To create a lookup table for a single-band input image, use one of the single-band constructors. The constructors take up to three parameters:
<p><ul>
<li>A pointer to the data to be stored in the table. The data may be of type <code>Byte</code>, <code>Short</code>, <code>UShort</code>, <code>Int</code>, <code>Float</code>, or <code>Double</code>.<p></ul><ul>
<li>The offset. The offset selects the lookup table subrange. The offset value is subtracted from the input value before indexing into the table array.<p></ul><ul>
<li>A boolean flag that indicates whether Short data is of type Short or UShort.<p></ul><a href="Image-enhance.doc.html#69572">Listing &#32;7-3</a> shows an example of the construction of a single-band byte lookup table.<p>
<caption><font size=-1><b>
<a name="69572">
<center><font size=-1><b><i>Listing 7-3	</i><img src="shared/sm-blank.gif" border=0> Example Single-band Lookup Table</b></font></center>
</a><p>
</b></font></caption>
<hr>
<tr valign=top><td><pre>     byte[] tableData = new byte[0x10000];
     for (int i = 0; i &lt; 0x10000; i++) {
     tableData[i] = (byte)(i &gt;&gt; 8);
     }
     
     // Create a LookupTableJAI object to be used with the
     // "lookup" operator.
     LookupTableJAI table = new LookupTableJAI(tableData);
</pre>

<hr>

<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.LookupTableJAI
</code>
<hr>
</td>
</table><pre><ul>
<li>LookupTableJAI(byte[] data)
<p></ul></pre><dl>
<a name="52020">
<dt><dd> constructs a single-banded byte lookup table with an index offset of 0.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td><em>Parameters</em>:
<p><td><code>data</code>
<p><td>The single-banded byte data
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>LookupTableJAI(byte[] data, int offset)
<p></ul></pre><dl>
<a name="55653">
<dt><dd> constructs a single-banded byte lookup table with an index offset.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=2><em>Parameters</em>:
<p><td><code>data</code>
<p><td>The single-banded byte data
<p>
<tr valign=top><td><code>offset</code>
<p><td>The offset
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>LookupTableJAI(short[] data, boolean isUShort)
<p></ul></pre><dl>
<a name="55831">
<dt><dd> constructs a single-banded short or unsigned short lookup table with an index offset of 0.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=2><em>Parameters</em>:
<p><td><code>data</code>
<p><td>The single-banded short data
<p>
<tr valign=top><td><code>isUShort</code>
<p><td>True if the data type is <code>DataBuffer.TYPE_USHORT</code>; false if the data type is <code>DataBuffer.TYPE_SHORT</code>.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>LookupTableJAI(short[] data, int offset, boolean isUShort)
<p></ul></pre><dl>
<a name="55893">
<dt><dd> constructs a single-banded short or unsigned short lookup table with an index offset.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=3><em>Parameters</em>:
<p><td><code>data</code>
<p><td>The single-banded short data
<p>
<tr valign=top><td><code>offset</code>
<p><td>The offset
<p>
<tr valign=top><td><code>isUShort</code>
<p><td>True if the data type is <code>DataBuffer.TYPE_USHORT</code>; false if the data type is <code>DataBuffer.TYPE_SHORT</code>.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>LookupTableJAI(int[] data)
<p></ul></pre><dl>
<a name="56100">
<dt><dd> constructs a single-banded int lookup table with an index offset<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td><em>Parameters</em>:
<p><td><code>data</code>
<p><td>The single-banded int data
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>LookupTableJAI(int[] data, int offset)
<p></ul></pre><dl>
<a name="56136">
<dt><dd> constructs a single-banded int lookup table with an index offset<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=2><em>Parameters</em>:
<p><td><code>data</code>
<p><td>The single-banded int data
<p>
<tr valign=top><td><code>offset</code>
<p><td>The offset
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>LookupTableJAI(float[] data)
<p></ul></pre><dl>
<a name="56333">
<dt><dd> constructs a single-banded float lookup table with an index offset of 0<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td><em>Parameters</em>:
<p><td><code>data</code>
<p><td>The single-banded float data
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>LookupTableJAI(float[] data, int offset)
<p></ul></pre><dl>
<a name="56373">
<dt><dd> constructs a single-banded float lookup table with an index offset<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=2><em>Parameters</em>:
<p><td><code>data</code>
<p><td>The single-banded float data
<p>
<tr valign=top><td><code>offset</code>
<p><td>The offset
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>LookupTableJAI(double[] data)
<p></ul></pre><dl>
<a name="56522">
<dt><dd> constructs a single-banded double lookup table with an index offset of 0<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td><em>Parameters</em>:
<p><td><code>data</code>
<p><td>The single-banded double data
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>LookupTableJAI(double[] data, int offset)
<p></ul></pre><dl>
<a name="56558">
<dt><dd> constructs a single-banded double lookup table with an index offset<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=2><em>Parameters</em>:
<p><td><code>data</code>
<p><td>The single-banded double data
<p>
<tr valign=top><td><code>offset</code>
<p><td>The offset
<p>

</Table>

</a><P></dl>
<a name="56722">
<h4>7.6.1.2	<img src="shared/space.gif">Creating a Multi-band Lookup Table</h4>
</a>The multi-band lookup table contains data for more than one channels or image components, such as separate arrays for R, G, and B. To create a lookup table for a multi-band input image, use one of the multi-band constructors. Like the single-band constructors, the multi-band constructors take up to three parameters:
<p><ul>
<li>A pointer to the data to be stored in the table. The data may be of type Byte, Short, UShort, Int, Float, or Double.<p></ul><ul>
<li>The offset. The offset selects the lookup table subrange. The offset value is subtracted from the input value before indexing into the table array. The constructors allow you to specify one offset for all of the bands or separate offsets for each band.<p></ul><ul>
<li>A boolean flag that indicates whether Short data is of type Short or UShort.<p></ul><a href="Image-enhance.doc.html#69599">Listing &#32;7-4</a> shows an example of the construction of a multi-banded byte lookup table.<p>
<caption><font size=-1><b>
<a name="69599">
<center><font size=-1><b><i>Listing 7-4	</i><img src="shared/sm-blank.gif" border=0> Example Multi-band Lookup Table</b></font></center>
</a><p>
</b></font></caption>
<hr>
<tr valign=top><td><pre>     // Create the table data.
     byte[][] tableData = new byte[3][0x10000];
     for (int i = 0; i &lt; 0x10000; i++) {
     tableData[0][i] = (byte)(i &gt;&gt; 8); // this may be different
     tableData[1][i] = (byte)(i &gt;&gt; 8); // for each band
     tableData[2][i] = (byte)(i &gt;&gt; 8);
     }
</pre>
<tr valign=top><td><pre>     // Create a LookupTableJAI object to be used with the
     // "lookup" operator.
     LookupTableJAI table = new LookupTableJAI(tableData);
</pre>

<hr>

<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.LookupTableJAI
</code>
<hr>
</td>
</table><pre><ul>
<li>LookupTableJAI(byte[][] data)
<p></ul></pre><dl>
<a name="56728">
<dt><dd> constructs a multi-banded byte lookup table with an index offset for each band of 0.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td><em>Parameters</em>:
<p><td><code>data</code>
<p><td>The multi-banded byte data in [band][index] format
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>LookupTableJAI(byte[][] data, int offset)
<p></ul></pre><dl>
<a name="56737">
<dt><dd> constructs a multi-banded byte lookup table where all bands have the same index offset.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=2><em>Parameters</em>:
<p><td><code>data</code>
<p><td>The multi-banded byte data in [band][index] format
<p>
<tr valign=top><td><code>offset</code>
<p><td>The common offset for all bands
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>LookupTableJAI(byte[][] data, int[] offsets)
<p></ul></pre><dl>
<a name="56752">
<dt><dd> constructs a multi-banded byte lookup table where each band has a different index offset.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=2><em>Parameters</em>:
<p><td><code>data</code>
<p><td>The multi-banded byte data in [band][index] format
<p>
<tr valign=top><td><code>offsets</code>
<p><td>The offsets for the bands
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>LookupTableJAI(short[][] data, boolean isUShort)
<p></ul></pre><dl>
<a name="56793">
<dt><dd> constructs a multi-banded short or unsigned short lookup table. The index offset for each band is 0<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=2><em>Parameters</em>:
<p><td><code>data</code>
<p><td>The multi-banded short data in [band][index] format.
<p>
<tr valign=top><td><code>isUShort</code>
<p><td>True if the data type is <code>DataBuffer.TYPE_USHORT</code>; false if the data type is <code>DataBuffer.TYPE_SHORT</code>.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>LookupTableJAI(short[][] data, int offset, boolean isUShort)
<p></ul></pre><dl>
<a name="56808">
<dt><dd> constructs a multi-banded short or unsigned short lookup table where all bands have the same index offset<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=3><em>Parameters</em>:
<p><td><code>data</code>
<p><td>The multi-banded short data in [band][index] format
<p>
<tr valign=top><td><code>offset</code>
<p><td>The common offset for all bands
<p>
<tr valign=top><td><code>isUShort</code>
<p><td>True if the data type is <code>DataBuffer.TYPE_USHORT</code>; false if the data type is <code>DataBuffer.TYPE_SHORT</code>.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>LookupTableJAI(short[][] data, int[] offsets, boolean isUShort)
<p></ul></pre><dl>
<a name="56829">
<dt><dd> constructs a multi-banded short or unsigned short lookup table where each band has a different index offset<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=3><em>Parameters</em>:
<p><td><code>data</code>
<p><td>The multi-banded short data in [band][index] format
<p>
<tr valign=top><td><code>offset</code>
<p><td>The offsets for the bands
<p>
<tr valign=top><td><code>isUShort</code>
<p><td>True if the data type is <code>DataBuffer.TYPE_USHORT</code>; false if the data type is <code>DataBuffer.TYPE_SHORT</code>.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>LookupTableJAI(int[][] data)
<p></ul></pre><dl>
<a name="56866">
<dt><dd> constructs a multi-banded int lookup table. The index offset for each band is 0<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td><em>Parameters</em>:
<p><td><code>data</code>
<p><td>The multi-banded int data in [band][index] format
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>LookupTableJAI(int[][] data, int offset)
<p></ul></pre><dl>
<a name="56868">
<dt><dd> constructs a multi-banded int lookup table where all bands have the same index offset<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=2><em>Parameters</em>:
<p><td><code>data</code>
<p><td>The multi-banded int data in [band][index] format
<p>
<tr valign=top><td><code>offset</code>
<p><td>The common offset for all bands
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>LookupTableJAI(int[][] data, int[] offsets)
<p></ul></pre><dl>
<a name="56883">
<dt><dd> constructs a multi-banded int lookup table where each band has a different index offset<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=2><em>Parameters</em>:
<p><td><code>data</code>
<p><td>The multi-banded int data in [band][index] format
<p>
<tr valign=top><td><code>offset</code>
<p><td>The offsets for the bands
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>LookupTableJAI(float[][] data)
<p></ul></pre><dl>
<a name="56907">
<dt><dd> constructs a multi-banded float lookup table. The index offset for each band is 0<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td><em>Parameters</em>:
<p><td><code>data</code>
<p><td>The multi-banded float data in [band][index] format
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>LookupTableJAI(float[][] data, int offset)
<p></ul></pre><dl>
<a name="56916">
<dt><dd> constructs a multi-banded float lookup table where all bands have the same index offset<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=2><em>Parameters</em>:
<p><td><code>data</code>
<p><td>The multi-banded float data in [band][index] format
<p>
<tr valign=top><td><code>offset</code>
<p><td>The common offset for all bands
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>LookupTableJAI(float[][] data, int[] offsets)
<p></ul></pre><dl>
<a name="56931">
<dt><dd> constructs a multi-banded float lookup table where each band has a different index offset<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=2><em>Parameters</em>:
<p><td><code>data</code>
<p><td>The multi-banded float data in [band][index] format
<p>
<tr valign=top><td><code>offset</code>
<p><td>The offsets for the bands
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>LookupTableJAI(double[][] data)
<p></ul></pre><dl>
<a name="56955">
<dt><dd> constructs a multi-banded double lookup table. The index offset for each band is 0<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td><em>Parameters</em>:
<p><td><code>data</code>
<p><td>The multi-banded double data in [band][index] format
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>LookupTableJAI(double[][] data, int offset)
<p></ul></pre><dl>
<a name="56964">
<dt><dd> constructs a multi-banded double lookup table where all bands have the same index offset<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=2><em>Parameters</em>:
<p><td><code>data</code>
<p><td>The multi-banded double data in [band][index] format
<p>
<tr valign=top><td><code>offset</code>
<p><td>The common offset for all bands
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>LookupTableJAI(double[][] data, int[] offsets)
<p></ul></pre><dl>
<a name="56979">
<dt><dd> constructs a multi-banded double lookup table where each band has a different index offset<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=2><em>Parameters</em>:
<p><td><code>data</code>
<p><td>The multi-banded double data in [band][index] format
<p>
<tr valign=top><td><code>offsets</code>
<p><td>The offsets for the bands
<p>

</Table>

</a><P></dl>
<a name="62701">
<h4>7.6.1.3	<img src="shared/space.gif">Creating a Color-cube Lookup Table</h4>
</a><strong></strong>Dithering operations that use a color cube are considerably faster than those that use a generic lookup table. However, the color cube provides less control over the exact contents of the lookup table.
<p>The <code>ColorCube</code> class is a subclass of <code>LookupTableJAI</code> and represents a color cube lookup table. You create a colorcube using one of the <code>ColorCube.createColorCube</code> methods. Rather than specifying the data to be loaded into the lookup table, you provide an array of <code>dimensions</code>. The <code>dimensions</code> parameter specifies the size (or number of levels) of each band of the image.
<p>Although a color cube implies three dimensions, that is not always the case. The color cube has the same number of <code>dimensions</code> as the image has bands. For example, a monochrome image requires only one <code>dimension</code> parameter.
<p>The values in the <code>dimensions</code> parameter are signed. A positive value indicates that the corresponding color ramp increases. A negative value indicates that the ramp decreases.
<p>JAI provides two predefined color cubes, which can be used for the ordered dither operation (see <a href="Image-manipulation.doc.html#56241">Section &#32;6.6.1, "Ordered Dither</a>"):<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="64972">
ColorCube
</a><th><a name="64974">
Description
</a>
<tr valign=top><td><a name="64977">
BYTE_496</a><br><td><a name="64979">
A ColorCube with dimensions 4:9:6, useful for dithering RGB images into 216 colors. The offset of this ColorCube is 38. This color cube dithers blue values in the source image to one of 4 blue levels, green values to one of 9 green levels, and red values to one of 6 red levels. This is the default color cube for the ordered dither operation.</a><br>
<tr valign=top><td><a name="64982">
BYTE_855</a><br><td><a name="64984">
A ColorCube with dimensions 8:5:5, useful for dithering YC<sub>b</sub>C<sub>r</sub> images into 200 colors. The offset of this ColorCube is 54. This color cube dithers blue values in the source image to one of 8 blue levels, green values to one of 5 green levels, and red values to one of 5 red levels.</a><br>

</Table>

<p>These color cubes are specified by the <code>colorMap</code> parameter that is required by the <code>OrderedDither</code> operation.
<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.ColorCube
</code>
<hr>
</td>
</table><pre><ul>
<li>static ColorCube createColorCube(int dataType, int offset, 
       int[] dimensions)
<p></ul></pre><dl>
<a name="62726">
<dt><dd> creates a multi-banded <code>ColorCube</code> of a specified data type.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=3><em>Parameters</em>:
<p><td><code>dataType</code>
<p><td>The data type of the <code>ColorCube</code>. One of <code>DataBuffer.TYPE_BYTE</code>, <code>DataBuffer.TYPE_SHORT</code>, <code>DataBuffer.TYPE_USHORT</code>, <code>DataBuffer.TYPE_INT</code>, <code>DataBuffer.TYPE_FLOAT</code>, or <code>DataBuffer.TYPE_DOUBLE</code>.
<p>
<tr valign=top><td><code>offset</code>
<p><td>The common offset for all bands.
<p>
<tr valign=top><td><code>dimensions</code>
<p><td>The signed dimensions for each band.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>static ColorCube createColorCube(int dataType, 
       int[] &#32;dimensions)
<p></ul></pre><dl>
<a name="62781">
<dt><dd> create a multi-banded <code>ColorCube</code> of a specified data type with zero offset for all bands.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=2><em>Parameters</em>:
<p><td><code>dataType</code>
<p><td>The data type of the <code>ColorCube</code>. One of <code>DataBuffer.TYPE_BYTE</code>, <code>DataBuffer.TYPE_SHORT</code>, <code>DataBuffer.TYPE_USHORT</code>, <code>DataBuffer.TYPE_INT</code>, <code>DataBuffer.TYPE_FLOAT</code>, or <code>DataBuffer.TYPE_DOUBLE</code>.
<p>
<tr valign=top><td><code>dimensions</code>
<p><td>The signed dimensions for each band.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>static ColorCube createColorCubeByte(int[] dimensions)
<p></ul></pre><dl>
<a name="62818">
<dt><dd> constructs a multi-banded byte <code>ColorCube</code>.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td><em>Parameters</em>:
<p><td><code>dimensions</code>
<p><td>A list of signed sizes of each side of the color cube.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>static ColorCube createColorCubeByte(int offset, 
       int[] &#32;dimensions)
<p></ul></pre><dl>
<a name="62876">
<dt><dd> constructs a multi-banded byte ColorCube with an index offset common to all bands.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=2><em>Parameters</em>:
<p><td><code>offset</code>
<p><td>The common offset for all bands.
<p>
<tr valign=top><td><code>dimensions</code>
<p><td>A list of signed sizes of each side of the color cube.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>static ColorCube createColorCubeShort(int[] dimensions)
<p></ul></pre><dl>
<a name="62921">
<dt><dd> constructs a multi-banded short <code>ColorCube</code>.
</a><P></dl>
<pre><ul>
<li>static ColorCube createColorCubeShort(int offset, 
       int[] &#32;dimensions)
<p></ul></pre><dl>
<a name="62936">
<dt><dd> constructs a multi-banded short <code>ColorCube</code> with an index offset common to all bands.
</a><P></dl>
<pre><ul>
<li>static ColorCube createColorCubeUShort(int[] dimensions)
<p></ul></pre><dl>
<a name="62950">
<dt><dd> constructs a multi-banded unsigned short <code>ColorCube</code>.
</a><P></dl>
<pre><ul>
<li>static ColorCube createColorCubeUShort(int offset, 
       int[] &#32;dimensions)
<p></ul></pre><dl>
<a name="62971">
<dt><dd> constructs a multi-banded unsigned short <code>ColorCube</code> with an index offset common to all bands.
</a><P></dl>
<pre><ul>
<li>static ColorCube createColorCubeInt(int[] dimensions)
<p></ul></pre><dl>
<a name="62990">
<dt><dd> constructs a multi-banded int <code>ColorCube</code>.
</a><P></dl>
<pre><ul>
<li>static ColorCube createColorCubeInt(int offset, 
       int[] &#32;dimensions)
<p></ul></pre><dl>
<a name="63007">
<dt><dd> constructs a multi-banded int <code>ColorCube</code> with an index offset common to all bands.
</a><P></dl>
<pre><ul>
<li>static ColorCube createColorCubeFloat(int[] dimensions)
<p></ul></pre><dl>
<a name="63021">
<dt><dd> constructs a multi-banded float <code>ColorCube</code>.
</a><P></dl>
<pre><ul>
<li>static ColorCube createColorCubeFloat(int offset, 
       int[] &#32;dimensions)
<p></ul></pre><dl>
<a name="63038">
<dt><dd> constructs a multi-banded float ColorCube with an index offset common to all bands.
</a><P></dl>
<pre><ul>
<li>static ColorCube createColorCubeDouble(int[] dimensions)
<p></ul></pre><dl>
<a name="63048">
<dt><dd> constructs a multi-banded double <code>ColorCube</code> with an index offset common to all bands.
</a><P></dl>
<pre><ul>
<li>static ColorCube createColorCubeDouble(int offset, 
       int[] &#32;dimensions)
<p></ul></pre><dl>
<a name="63063">
<dt><dd> constructs a multi-banded double <code>ColorCube</code> with an index offset common to all bands.
</a><P></dl>
<a name="56300">
<h3>7.6.2	<img src="shared/space.gif">Performing the Lookup</h3>
</a>The <code>lookup</code> operation performs a general table lookup on a rendered or renderable image. The destination image is obtained by passing the source image through the lookup table. The source image may be single- or multi-banded of data types <code>byte</code>, <code>ushort</code>, <code>short</code>, or <code>int</code>. The lookup table may be single- or multi-banded of any JAI-supported data types.
<p>The destination image must have the same data type as the lookup table, and its number of bands is determined based on the number of bands of the source and the table. If the source is single-banded, the destination has the same number of bands as the lookup table; otherwise, the destination has the same number of bands as the source.
<p>If either the source or the table is single-banded and the other one is multi-banded, the single band is applied to every band of the multi-banded object. If both are multi-banded, their corresponding bands are matched up.
<p>The table may have a set of offset values, one for each band. This value is subtracted from the source pixel values before indexing into the table data array.
<p>It is the user's responsibility to make certain the lookup table supplied is suitable for the source image. Specifically, the table data must cover the entire range of the source data. Otherwise, the result of this operation is undefined.
<p>By the nature of this operation, the destination may have a different number of bands and/or data type from the source. The <code>SampleModel</code> of the destination is created in accordance with the actual lookup table used in a specific case.
<p>There are three specific cases of table lookup that determine the pixel values of the destination image:
<p><ul>
<li>If the source image is single-banded and the lookup table is single- or multi-banded, the destination image has the same number of bands as the lookup table:<p></ul><pre>          for (int h = 0; h &lt; dstHeight; h++) {
              for (int w = 0; w &lt; dstWidth; w++) {
                  for (int b = 0; b &lt; dstNumBands; b++) {
                      dst[h][w][b] = table[b][src[h][w][0] - offsets[b]]
                  }
              }
          }
     
</pre><ul>
<li>If the source image is multi-banded and the lookup table is single-banded, the destination image has the same number of bands as the source image:<p></ul><pre>          for (int h = 0; h &lt; dstHeight; h++) {
              for (int w = 0; w &lt; dstWidth; w++) {
                  for (int b = 0; b &lt; dstNumBands; b++) {
                      dst[h][w][b] = table[0][src[h][w][b] - offsets[0]]
                 }
               }
          }
     
</pre><ul>
<li>If the source image is multi-banded and the lookup table is multi-banded, with the same number of bands as the source image, the destination image will have the same number of bands as the source image:<p></ul><pre>          for (int h = 0; h &lt; dstHeight; h++) {
              for (int w = 0; w &lt; dstWidth; w++) {
                  for (int b = 0; b &lt; dstNumBands; b++) {
                      dst[h][w][b] = table[b][src[h][w][b] - offsets[b]]
                  }
              }
          }
</pre>The <code>lookup</code> operation takes one rendered or renderable source image and one parameter:<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="61187">
Parameter
</a><th><a name="61189">
Type
</a><th><a name="61191">
Description
</a>
<tr valign=top><td><a name="61193">
table</a><br><td><a name="61195">
LookupTableJAI</a><br><td><a name="61197">
The lookup table through which the source image is passed.</a><br>

</Table>

<p>See <a href="Image-enhance.doc.html#51408">Section &#32;7.6.1, "Creating the Lookup Table</a>" for more information.
<p>For a complete example of the <code>Lookup</code> operation, see <a href="Examples.doc.html#73865">Listing &#32;A-1 on page 417</a>.
<p><a name="64998">
<h3>7.6.3	<img src="shared/space.gif">Other Lookup Table Operations</h3>
</a><a name="52351">
<h4>7.6.3.1	<img src="shared/space.gif">Reading the Table Data</h4>
</a>Several methods are available to read the current contents of the lookup table. The choice of method depends on the data format: byte, short, integer, floating-point, or double floating-point.
<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.LookupTableJAI
</code>
<hr>
</td>
</table><pre><ul>
<li>java.awt.image.DataBuffer getData()
<p></ul></pre><dl>
<a name="57520">
<dt><dd> returns the table data as a <code>DataBuffer</code>.
</a><P></dl>
<pre><ul>
<li>byte[][] getByteData()
<p></ul></pre><dl>
<a name="57534">
<dt><dd> returns the byte table data in array format.
</a><P></dl>
<pre><ul>
<li>byte[] getByteData(int band)
<p></ul></pre><dl>
<a name="57544">
<dt><dd> returns the byte table data of a specific band in array format.
</a><P></dl>
<pre><ul>
<li>short[][] getShortData()
<p></ul></pre><dl>
<a name="57558">
<dt><dd> returns the short table data in array format.
</a><P></dl>
<pre><ul>
<li>short[] getShortData(int band)
<p></ul></pre><dl>
<a name="57568">
<dt><dd> returns the short table data of a specific band in array format.
</a><P></dl>
<pre><ul>
<li>int[][] getIntData()
<p></ul></pre><dl>
<a name="57582">
<dt><dd> returns the integer table data in array format.
</a><P></dl>
<pre><ul>
<li>int[] getIntData(int band)
<p></ul></pre><dl>
<a name="57592">
<dt><dd> returns the integer table data of a specific band in array format.
</a><P></dl>
<pre><ul>
<li>float[][] getFloatData()
<p></ul></pre><dl>
<a name="57606">
<dt><dd> returns the float table data in array format.
</a><P></dl>
<pre><ul>
<li>float[] getFloatData(int band)
<p></ul></pre><dl>
<a name="57620">
<dt><dd> returns the float table data of a specific band in array format.
</a><P></dl>
<pre><ul>
<li>double[][] getDoubleData()
<p></ul></pre><dl>
<a name="57630">
<dt><dd> returns the double table data in array format.
</a><P></dl>
<pre><ul>
<li>double[] getDoubleData(int band)
<p></ul></pre><dl>
<a name="57648">
<dt><dd> returns the double table data of a specific band in array format.
</a><P></dl>
<a name="57653">
<h4>7.6.3.2	<img src="shared/space.gif">Reading the Table Offsets</h4>
</a>There are three methods for reading the offset values within the current lookup table.
<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.LookupTableJAI
</code>
<hr>
</td>
</table><pre><ul>
<li>int[] getOffsets()
<p></ul></pre><dl>
<a name="57676">
<dt><dd> returns the index offsets of entry 0 for all bands.
</a><P></dl>
<pre><ul>
<li>int getOffset()
<p></ul></pre><dl>
<a name="57686">
<dt><dd> returns the index offset of entry 0 for the default band.
</a><P></dl>
<pre><ul>
<li>int getOffset(int band)
<p></ul></pre><dl>
<a name="57696">
<dt><dd> returns the index offset of entry 0 for a specific band.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td><em>Parameters</em>:
<p><td><code>band</code>
<p><td>The band to read
<p>

</Table>

</a><P></dl>
<a name="57714">
<h4>7.6.3.3	<img src="shared/space.gif">Reading the Number of Bands</h4>
</a>A single method is used to read the number of bands in the lookup table.
<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.LookupTableJAI
</code>
<hr>
</td>
</table><pre><ul>
<li>int getNumBands()
<p></ul></pre><dl>
<a name="57729">
<dt><dd> returns the number of bands of the table.
</a><P></dl>
<a name="57734">
<h4>7.6.3.4	<img src="shared/space.gif">Reading the Number of Entries Per Band</h4>
</a>A single method is used to read the number of entries per band in the lookup table.
<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.LookupTableJAI
</code>
<hr>
</td>
</table><pre><ul>
<li>int getNumEntries()
<p></ul></pre><dl>
<a name="57749">
<dt><dd> returns the number of entries per band of the table.
</a><P></dl>
<a name="57754">
<h4>7.6.3.5	<img src="shared/space.gif">Reading the Data Type</h4>
</a>A single method is used to read the data type of the lookup table.
<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.LookupTableJAI
</code>
<hr>
</td>
</table><pre><ul>
<li>int getDataType()
<p></ul></pre><dl>
<a name="57769">
<dt><dd> returns the data type of the table data.
</a><P></dl>
<a name="57774">
<h4>7.6.3.6	<img src="shared/space.gif">Reading the Destination Bands and SampleModel</h4>
</a><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.LookupTableJAI
</code>
<hr>
</td>
</table><pre><ul>
<li>int getDestNumBands(int sourceNumBands)
<p></ul></pre><dl>
<a name="57790">
<dt><dd> returns the number of bands of the destination image, based on the number of bands of the source image and lookup table.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td><em>Parameters</em>:
<p><td><code>sourceNum-Bands</code>
<p><td>The number of bands of the source image.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>java.awt.image.SampleModel 
       getDestSampleModel(java.awt.image.SampleModel 
       srcSampleModel)
<p></ul></pre><dl>
<a name="57828">
<dt><dd> returns a <code>SampleModel</code> suitable for holding the output of a lookup operation on the source data described by a given <code>SampleModel</code> with this table. The width and height of the destination <code>SampleModel</code> are the same as that of the source. This method returns null if the source <code>SampleModel</code> has a non-integral data type.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td><em>Parameters</em>:
<p><td><code>srcSample-Model</code>
<p><td>The <code>SampleModel</code> of the source image.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>java.awt.image.SampleModel 
       getDestSampleModel(java.awt.image.SampleModel 
       srcSampleModel, int width, int height)
<p></ul></pre><dl>
<a name="57874">
<dt><dd> returns a <code>SampleModel</code> suitable for holding the output of a lookup operation on the source data described by a given <code>SampleModel</code> with this table. This method will return null if the source <code>SampleModel</code> has a non-integral data type.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=3><em>Parameters</em>:
<p><td><code>srcSample-Model</code>
<p><td>The <code>SampleModel</code> of the source image.
<p>
<tr valign=top><td><code>width</code>
<p><td>The width of the destination <code>SampleModel</code>.
<p>
<tr valign=top><td><code>height</code>
<p><td>The height of the destination <code>SampleModel</code>.
<p>

</Table>

</a><P></dl>
<a name="51172">
<h2>7.7	<img src="shared/space.gif">Convolution Filtering</h2>
</a>Convolution filtering is often used to reduce the effects of noise in images or to sharpen the detail in blurred images. Convolution filtering is a form of <em>spatial filtering</em> that computes each output sample by multiplying elements of a kernel with the samples surrounding a particular source sample.
<p>Convolution filtering operates on a group of input pixels surrounding a center pixel. The adjoining pixels provide important information about brightness trends in the area of the pixel being processed.
<p>Convolution filtering moves across the source image, pixel by pixel, placing resulting pixels into the destination image. The resulting brightness of each source pixel depends on the group of pixels surrounding the source pixel. Using the brightness information of the source pixel's neighbors, the convolution process calculates the spatial frequency activity in the area, making it possible to filter the brightness based on the spatial frequency of the area.
<p>Convolution filtering uses a <em>convolve kernel</em>, containing an array of convolution coefficient values, called <em>key elements</em>, as shown in <a href="Image-enhance.doc.html#52989">Figure &#32;7-9</a>. The array is not restricted to any particular size, and does not even have to be square. The kernel can be 1 x 1, 3 x 3, 5 x 5, <code>M</code> x <code>N, </code>and so on. A larger kernel size affords a more precise filtering operation by increasing the number of neighboring pixels used in the calculation. However, the kernel cannot be bigger in any dimension than the image data. Also, the larger the kernel, the more computations that are required to be performed. For example, given a 640  x 480 image and a 3 x 3 kernel, the convolve operation requires over five million total multiplications and additions.
<p>The convolution filtering operation computes each output sample by multiplying the key elements of the kernel with the samples surrounding a particular source pixel. For each destination pixel, the kernel is rotated 180 degrees and its key element is placed over the source pixel corresponding with the destination pixel. The key elements are multiplied with the source pixels under them, and the resulting products are summed together to produce the destination sample value.
<p>The selection of the weights for the key elements determines the nature of the filtering action, such as <em>high-pass</em> or <em>low-pass</em>. If the values of the key elements are the reciprocal of the number of key elements in the kernel (for example, 1/9 for a 3 x 3 kernel), the result is a conventional low-pass averaging process. If the weights are altered, certain pixels in the kernel will have an increased or decreased influence in the average. <a href="Image-enhance.doc.html#53832">Figure &#32;7-10</a> shows three example convolve filters, low-pass, high-pass, and Laplacian.
<p><a name="52987">
 <hr>
<center><img src="Image-enhance.doc.anc5.gif"></center><hr>

</a>
<a name="52989">
<center><font size=-1><b><i>Figure 7-9	</i><img src="shared/sm-blank.gif" border=0> Convolve Kernel</b></font></center>
</a><p><a name="53830">
 <hr>
<center><img src="Image-enhance.doc.anc7.gif"></center><hr>

</a><a name="53832">
<center><font size=-1><b><i>Figure 7-10	</i><img src="shared/sm-blank.gif" border=0> Convolve Filter Samples</b></font></center>
</a><p>
The low-pass filter, also known as a <em>box filter</em>, attenuates the high-spatial frequency components of an image and has little affect on the low-frequency components. The effect of passing an image through a low-pass filter is a slight blurring. This is caused by attenuating the sharp brightness transitions between edges and makes the image appear to have less detail. See also <a href="Image-enhance.doc.html#59705">Section &#32;7.7.2, "Box Filter</a>."
<p>The high-pass filter has the opposite effect of the low-pass filter, accentuating the high-frequency components and offering little affect on the low-frequency components. The effect of passing an image through a high-pass filter is a sharper image with increased detail in the areas of brightness transition.
<p>The Laplacian filter is another image detail sharpening filter that works well for noise-free images. This filter subtracts the brightness values of the four neighboring pixels from the central pixel. The result of applying this filter is to reduce the gray level to zero.
<p><a name="53067">
<h3>7.7.1	<img src="shared/space.gif">Performing the Convolve Operation</h3>
</a>The following example code shows a <code>convolve</code> operation on a single sample <code>dst[x][y]</code>, which assumes that the kernel is of size <code>M</code> x <code>N</code> and has already been rotated through 180 degrees. The kernel's key element is located at position (<code>xKey</code>, <code>yKey</code>).
<p><pre>     dst[x][y] = 0;
         for (int i = -xOrigin; i &lt; -xOrigin + width; i++) {
         for (int j = -yOrigin; j &lt; -yOrigin + height; j++) {
           dst[x][y] += src[x + i][y + j]*kernel[xOrigin + i][yOrigin + j];
          }
     }
</pre>Convolution, or any neighborhood operation, leaves a band of pixels around the edges undefined. For example, for a 3 x 3 kernel, only four kernel elements and four source pixels contribute to the destination pixel located at (0,0). Such pixels are not included in the destination image. A border extension may be added via the <code>BorderExtender</code> class. The type of border extension can be specified as a <code>RenderingHint</code> to the <code>JAI.create</code> method. If no border extension type is provided, a default extension of <code>BorderExtender.BORDER_COPY</code> will be used to perform the extension. See <a href="Programming-environ.doc.html#55991">Section &#32;3.7.3, "Rendering Hints</a>."
<p>The <code>convolve</code> operation takes one rendered source image and one parameter:<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="69382">
Parameter
</a><th><a name="69384">
Type
</a><th><a name="69386">
Description
</a>
<tr valign=top><td><a name="69388">
kernel</a><br><td><a name="69390">
KernelJAI</a><br><td><a name="69394">
The convolution kernel. See <a href="Image-manipulation.doc.html#70882">Section &#32;6.9, "Constructing a Kernel</a>."</a><br>

</Table>

<p>The default <code>kernel</code> is <code>null</code>. 
<p><a href="Image-enhance.doc.html#69630">Listing &#32;7-5</a> shows a code sample for a <code>Convolve</code> operation.<p>
<caption><font size=-1><b>
<a name="69630">
<center><font size=-1><b><i>Listing 7-5	</i><img src="shared/sm-blank.gif" border=0> Example Convolve Operation</b></font></center>
</a><p>
</b></font></caption>
<hr>
<tr valign=top><td><pre>     // Create the kernel.
     kernel = new KernelJAI
     float[] = {  0.0F, -1.0F,  0.0F,
                 -1.0F,  5.0F, -1.0F,
                  0.0F, -1.0F,  0.0F };
</pre>
<tr valign=top><td><pre>     // Create the convolve operation.
     im1 = JAI.create("convolve", im, kernel);
</pre>

<hr>

<p><a name="59705">
<h3>7.7.2	<img src="shared/space.gif">Box Filter</h3>
</a>The <code>BoxFilter</code> operation is a special case of convolve operation in which each source pixel contributes the same weight to the destination pixel. The box filter operation determines the intensity of a pixel in an image by averaging the source pixels within a rectangular area around the pixel. The pixel values of the destination image are defined by the following pseudocode:
<p><pre>     int count = width * height; // # of pixels in the box
     for (int b = 0; b &lt; numBands; b++) {
          int total = 0;
          for (int j = -yKey; j &lt; -yKey + height; j++) {
               for (int i = -xKey; i &lt; -xKey + width; i++) {
                   total += src[x+i][y+j][b];
                }
           }
          dst[x][y][b] = (total + count/2) / count; // round
     }
</pre>The <code>BoxFilter</code> operation uses a low-pass filter that passes (leaves untouched) the low spatial frequency components of the image and attenuates the high-frequency components. In an area of the image that has constant brightness, the brightness values are passed untouched. When the filter passes over an area of sharp black to white transitions, the brightness range is greatly attenuated.
<p>Convolution, like any neighborhood operation, leaves a band of pixels around the edges undefined. For example, for a 3 x 3 kernel, only four kernel elements and four source pixels contribute to the convolution pixel at the corners of the source image. Pixels that do not allow the full kernel to be applied to the source are not included in the destination image. A <code>Border</code> operation (see <a href="Image-enhance.doc.html#68364">Section &#32;7.2, "Adding Borders to Images</a>") may be used to add an appropriate border to the source image to avoid shrinkage of the image boundaries.
<p>The kernel may not be bigger in any dimension than the image data.
<p>The <code>BoxFilter</code> operation takes one rendered source image and four parameters:<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="61238">
Parameter
</a><th><a name="61240">
Type
</a><th><a name="61242">
Description
</a>
<tr valign=top><td><a name="76667">
width</a><br><td><a name="76669">
Integer</a><br><td><a name="76671">
The width of the box.</a><br>
<tr valign=top><td><a name="76673">
height</a><br><td><a name="76675">
Integer</a><br><td><a name="76677">
The height of the box.</a><br>
<tr valign=top><td><a name="61244">
xKey</a><br><td><a name="61246">
Integer</a><br><td><a name="61248">
The <em>x</em> position of the key element.</a><br>
<tr valign=top><td><a name="61250">
yKey</a><br><td><a name="61252">
Integer</a><br><td><a name="61254">
The <em>y</em> position of the key element.</a><br>

</Table>

<p>The <code>width</code> parameter is required. The remaining parameters may be <code>null</code> and, if not supplied, default to the following values:
<p><dl>
<a name="76684">
<dt><dd> <hr>
<center><img src="Image-enhance.doc.anc13.gif"></center><hr>

</a><P></dl>
<a href="Image-enhance.doc.html#69683">Listing &#32;7-6</a> shows a code sample for a <code>BoxFilter</code> operation.<p>
<caption><font size=-1><b>
<a name="69683">
<center><font size=-1><b><i>Listing 7-6	</i><img src="shared/sm-blank.gif" border=0> Example BoxFilter Operation &#32;</b></font></center>
</a><p>
</b></font></caption>
<hr>
<tr valign=top><td><pre>     // Read the arguments.
     String fileName = args.length &gt; 0 ? args[0] : DEFAULT_FILE;
     int width = args.length &gt; 1 ?
         Integer.decode(args[1]).intValue() : DEFAULT_SIZE;
     int height = args.length &gt; 2 ?
         Integer.decode(args[2]).intValue() : width;
</pre>
<tr valign=top><td><pre>     new BoxFilterExample(fileName, width, height);
     }
</pre>
<tr valign=top><td><pre>     public BoxFilterExample(String fileName, int width, int height)
</pre>
<tr valign=top><td><pre>     // Load the image.
     RenderedOp src =  JAI.create("fileload", fileName);
</pre>
<tr valign=top><td><pre>     // Create the BoxFilter operation.
     RenderedOp dst = JAI.create("boxfilter", src,
                                 width, height,
                                 width/2, height/2);
</pre>

<hr>

<p><a name="66803">
<h2>7.8	<img src="shared/space.gif">Median Filtering</h2>
</a>A median filter is used to remove impulse noise spikes from an image and thus smoothing the image. Impulse noise spikes appear as bright or dark pixels randomly distributed throughout the image. Noise spikes are normally significantly brighter or darker than their neighboring pixels and can easily be found by comparing the median value of a group of input pixels.
<p>The median filter is a neighborhood-based ranking filter in which the pixels in the neighborhood are ranked in the order of their levels. The median value of the group is then stored in the output pixel. The resulting image is then free of pixel brightnesses that are at the extremes in each input group of pixels.
<p>The noise-reducing effect that the median filter has on an image depends on two related things: the spatial extent of the neighborhood (the mask) and the number of pixels involved in the computation. The <code>MedianFilter</code> operation supports three different mask shapes, a square, a plus, and an X-shape, as shown in <a href="Image-enhance.doc.html#66848">Figure &#32;7-11</a>.
<p><a name="66845">
 <hr>
<center><img src="Image-enhance.doc.anc2.gif"></center><hr>

</a>
<a name="66848">
<center><font size=-1><b><i>Figure 7-11	</i><img src="shared/sm-blank.gif" border=0> Median Filter Masks</b></font></center>
</a><p>
The <code>MedianFilter</code> operation may also be used to compute the <em>separable median</em> of a 3 x 3 or 5 x 5 region of pixels. The separable median is defined as the median of the medians of each row. For example, if the pixel values in a 3 x 3 window are as follows:
<p><a name="66871">
 <hr>
<center><img src="Image-enhance.doc.anc4.gif"></center><hr>

</a>the overall (non-separable) median value is 5, while the separable median is equal to the median of the three row medians: median(1, 2, 3) = 2, median(5, 6, 7) = 6, and median(4, 8, 9) = 8, yielding an overall median of 6. The separable median may be obtained by specifying a mask of type <code>MEDIAN_MASK_SQUARE_SEPARABLE</code>.
<p>The <code>MedianFilter</code> operation takes one rendered source image and two parameters:<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="66877">
Parameter
</a><th><a name="66879">
Type
</a><th><a name="66881">
Default
</a><th><a name="66883">
Description
</a>
<tr valign=top><td><a name="66885">
maskShape</a><br><td><a name="66887">
Integer</a><br><td><a name="66889">
MASK_<br>SQUARE</a><br><td><a name="66891">
The shape of the mask to be used for Median Filtering</a><br>
<tr valign=top><td><a name="66893">
maskSize</a><br><td><a name="66895">
Integer</a><br><td><a name="66897">
3</a><br><td><a name="66899">
The size (width and height) of the mask to be used in Median Filtering.</a><br>

</Table>

<p>The <code>maskShape</code> parameter is one of the following:<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="66904">
maskShape
</a><th><a name="66906">
Description
</a>
<tr valign=top><td><a name="66909">
MEDIAN_MASK_SQUARE</a><br><td><a name="66911">
A square-shaped mask. The default.</a><br>
<tr valign=top><td><a name="66914">
MEDIAN_MASK_PLUS</a><br><td><a name="66916">
A plus-shaped mask.</a><br>
<tr valign=top><td><a name="66919">
MEDIAN_MASK_X</a><br><td><a name="66921">
An X-shaped mask.</a><br>
<tr valign=top><td><a name="66923">
MEDIAN_MASK_SQUARE_<br>SEPARABLE</a><br><td><a name="66925">
A separable square mask, used for the separable median operation.</a><br>

</Table>

<p>The <code>maskSize</code> parameter must be 1 (1 x 1) or greater. The default value, if one is not provided, is 3 (3 x 3). For large masks, the noise reduction effect of more pixels used in the computation of the median value reaches a point of diminishing returns. Typical mask sizes are 3 x 3 and 5 x 5.
<p><a name="59829">
<h2>7.9	<img src="shared/space.gif">Frequency Domain Processing</h2>
</a>Images contain spatial details that are seen as brightness transitions, cycling from dark to light and back to dark. The rate at which the transitions occur in an image represent the image's <em>spatial frequency</em>.
<p>An image's spatial frequency can be measured horizontally, vertically, or at any diagonal in between. An image contains many spatial frequencies that, when combined in the correct magnitude and phase, form the complex details of the image.
<p>A <em>frequency transform</em> decomposes an image from its spatial domain form of brightness into a frequency domain form of fundamental frequency components. Each frequency component contains a magnitude and phase value. An <em>inverse frequency transform</em> converts an image from its frequency form back to its spatial form.
<p><a name="65663">
<h3>7.9.1	<img src="shared/space.gif">Fourier Transform</h3>
</a>JAI supports the most common type of frequency transform, the <em>discrete Fourier transform</em> and its inverse, the inverse discrete Fourier transform. The discrete Fourier transform of an image is a two-dimensional process. The result of the transform is a two-dimensional array of values, each having two parts: real and imaginary. Each value represents a distinct spatial frequency component. The frequency-transform image has as many values as there are pixels in the source image.
<p>The real portion of the values can be displayed as an image, visually showing the frequency components of the source image. The result is in "wrap around" order, with the zero-frequency point (also known as "DC" for direct current) at the upper left corner and the high frequencies at the center.
<p><a name="64002">
<h4>7.9.1.1	<img src="shared/space.gif">Discrete Fourier Transform</h4>
</a>The <code>DFT</code> (discrete Fourier transform) operation computes the discrete Fourier transform of an image. A negative exponential is used as the basis function for the transform. The operation supports real-to-complex, complex-to-complex, and complex-to-real transforms. A complex image must have an even number of bands, with the even bands (0, 2, etc.) representing the real parts and the odd bands (1, 3, etc.) the imaginary parts of each complex pixel.
<p>If an underlying fast Fourier transform (FFT) implementation is used that requires that the image dimensions be powers of 2, the width and height may each be increased to the power of 2 greater than or equal to the original width and height, respectively.
<p>The <code>dft</code> operation takes one rendered or renderable source image and two parameters.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="64052">
Parameter
</a><th><a name="64054">
Type
</a><th><a name="64056">
Description
</a>
<tr valign=top><td><a name="64058">
scalingType</a><br><td><a name="64060">
Integer</a><br><td><a name="64062">
The type of scaling to perform. One of DFTDescriptor.SCALING_NONE, DFTDescriptor.SCALING_UNITARY, or DFTDescriptor.SCALING_DIMENSIONS.</a><br>
<tr valign=top><td><a name="70169">
dataNature</a><br><td><a name="70171">
Integer</a><br><td><a name="70173">
The nature of the data. One of DFTDescriptor.REAL_TO_COMPLEX, DFTDescriptor.COMPLEX_TO_COMPLEX, or</a><br><a name="70208">
DFTDescriptor.COMPLEX_TO_REAL.</a><br>

</Table>

<p>The default parameters for this operation are <code>SCALING_NONE</code> and <code>REAL_TO_COMPLEX</code>.
<p>The <code>scalingType</code> parameter defines how the image dimensions may be scaled, as follows:<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="64767">
scalingType
</a><th><a name="64769">
Description
</a>
<tr valign=top><td><a name="64772">
DFTDescriptor.SCALING_NONE</a><br><td><a name="64774">
The transform is not to be scaled (the default).</a><br>
<tr valign=top><td><a name="64777">
DFTDescriptor.SCALING_UNITARY</a><br><td><a name="64779">
The transform is to be scaled by the square root of the product of its dimensions.</a><br>
<tr valign=top><td><a name="64782">
DFTDescriptor.SCALING_DIMENSIONS</a><br><td><a name="64784">
The transform is to be scaled by the product of its dimensions.</a><br>

</Table>

<p>The <code>dataNature</code> parameter specifies the nature of the source and destination data, as follows.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="76420">
dataNature
</a><th><a name="76422">
Description
</a>
<tr valign=top><td><a name="76425">
DFTDescriptor.REAL_TO_COMPLEX</a><br><td><a name="76427">
The source data are real and the destination data complex.</a><br>
<tr valign=top><td><a name="76430">
DFTDescriptor.COMPLEX_TO_COMPLEX</a><br><td><a name="76432">
The source and destination data are both complex.</a><br>
<tr valign=top><td><a name="76435">
DFTDescriptor.COMPLEX_TO_REAL</a><br><td><a name="76437">
The source data are complex and the destination data real.</a><br>

</Table>

<p>If the source data are complex, the number of bands in the source image must be a multiple of 2. The number of bands in the destination must match that which would be expected given the number of bands in the source image and the specified nature of the source and destination data. If the source image is real, the number of bands in the destination will be twice that in the source. If the destination image is real, the number of bands in the destination will be half that in the source. Otherwise the number of bands in the source and destination must be equal.
<p>The <code>DFT</code> operation defines a <code>PropertyGenerator</code> that sets the <code>COMPLEX</code> property of the image to <code>FALSE</code> if the <code>dataNature</code> parameter is <code>COMPLEX_TO_REAL</code> and to <code>TRUE</code> if the <code>dataNature</code> parameter is <code>REAL_TO_COMPLEX</code> or <code>COMPLEX_TO_COMPLEX</code>. The value of this property may be retrieved by calling the getProperty() method with <code>COMPLEX</code> as the property name.
<p><a href="Image-enhance.doc.html#70321">Listing &#32;7-7</a> shows a code sample for a <code>DFT</code> operation.<p>
<caption><font size=-1><b>
<a name="70321">
<center><font size=-1><b><i>Listing 7-7	</i><img src="shared/sm-blank.gif" border=0> Example DFT Operation &#32;</b></font></center>
</a><p>
</b></font></caption>
<hr>
<tr valign=top><td><pre>     // Create the ParameterBlock.
     ParameterBlock pb = new ParameterBlock();
     pb.addSource(src)
     pb.add(DFTDescriptor.SCALING_NONE);
     pb.add(DFTDescriptor.REAL_TO_COMPLEX);
</pre>
<tr valign=top><td><pre>     // Create the DFT operation.
     PlanarImage dft = (PlanarImage)JAI.create("dft", pb, null);
</pre>
<tr valign=top><td><pre>     // Get the DFT image information.
     int width = dft.getWidth();
     int height = dft.getHeight();
     int numBands = dft.getSampleModel().getNumBands();
     int dataType = dft.getSampleModel().getDataType();
</pre>
<tr valign=top><td><pre>     // Calculate the cutoff "frequencies" from the threshold.
     threshold /= 200.0F;
     int minX = (int)(width*threshold);
     int maxX = width - 1 - minX;
     int minY = (int)(height*threshold);
     int maxY = height - 1 - minY;
</pre>
<tr valign=top><td><pre>     // Retrieve the DFT data.
     Raster dftData = dft.getData();
     double[] real =
          dftData.getSamples(0, 0, width, height, 0, (double[])null);
     double[] imag =
          dftData.getSamples(0, 0, width, height, 1, (double[])null);
</pre>
<tr valign=top><td><pre>     double[] HR = new double[real.length];
     double[] HI = new double[imag.length];
     double[] LR = new double[real.length];
     double[] LI = new double[imag.length];
</pre>

<hr>

<p><a name="59922">
<h4>7.9.1.2	<img src="shared/space.gif">Inverse Discrete Fourier Transform</h4>
</a>The <code>IDFT</code> (inverse discrete Fourier transform) operation computes the inverse discrete Fourier transform of an image. A positive exponential is used as the basis function for the transform. The operation supports real-to-complex, complex-to-complex, and complex-to-real transforms. A complex image must have an even number of bands, with the even bands (0, 2, etc.) representing the real parts and the odd bands (1, 3, etc.) the imaginary parts of each complex pixel.
<p>If an underlying fast Fourier transform (FFT) implementation is used that requires that the image dimensions be powers of 2, the width and height may each be increased to the power of 2 greater than or equal to the original width and height, respectively.
<p>The <code>IDFT</code> operation takes one rendered or renderable source image and two parameters.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="64139">
Parameter
</a><th><a name="64141">
Type
</a><th><a name="64143">
Description
</a>
<tr valign=top><td><a name="64145">
scalingType</a><br><td><a name="64147">
Integer</a><br><td><a name="64149">
The type of scaling to perform. One of DFTDescriptor.SCALING_NONE, DFTDescriptor.SCALING_UNITARY, or DFTDescriptor.SCALING_DIMENSIONS.</a><br>
<tr valign=top><td><a name="70383">
dataNature</a><br><td><a name="70385">
Integer</a><br><td><a name="70387">
The nature of the data. One of DFTDescriptor.REAL_TO_COMPLEX, DFTDescriptor.COMPLEX_TO_COMPLEX, or</a><br><a name="70388">
DFTDescriptor.COMPLEX_TO_REAL.</a><br>

</Table>

<p>The default parameters for this operation are <code>SCALING_DIMENSIONS</code> and <code>COMPLEX_TO_REAL</code>.
<p>The <code>scalingType</code> parameter defines how the image dimensions may be scaled, as follows:<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="64684">
scalingType
</a><th><a name="64686">
Description
</a>
<tr valign=top><td><a name="64688">
DFTDescriptor.SCALING_NONE</a><br><td><a name="64690">
The transform is not to be scaled.</a><br>
<tr valign=top><td><a name="64692">
DFTDescriptor.SCALING_UNITARY</a><br><td><a name="64694">
The transform is to be scaled by the square root of the product of its dimensions.</a><br>
<tr valign=top><td><a name="64696">
DFTDescriptor.SCALING_DIMENSIONS</a><br><td><a name="64698">
The transform is to be scaled by the product of its dimensions (the default).</a><br>

</Table>

<p>The <code>dataNature</code> parameter specifies the nature of the source and destination data, as follows.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="76394">
dataNature
</a><th><a name="76396">
Description
</a>
<tr valign=top><td><a name="76399">
DFTDescriptor.REAL_TO_COMPLEX</a><br><td><a name="76401">
The source data are real and the destination data complex.</a><br>
<tr valign=top><td><a name="76404">
DFTDescriptor.COMPLEX_TO_COMPLEX</a><br><td><a name="76406">
The source and destination data are both complex.</a><br>
<tr valign=top><td><a name="76409">
DFTDescriptor.COMPLEX_TO_REAL</a><br><td><a name="76411">
The source data are complex and the destination data real.</a><br>

</Table>

<p>If the source data are complex, the number of bands in the source image must be a multiple of 2. The number of bands in the destination must match that which would be expected given the number of bands in the source image and the specified nature of the source and destination data. If the source image is real, the number of bands in the destination will be twice that in the source. If the destination image is real, the number of bands in the destination will be half that in the source. Otherwise the number of bands in the source and destination must be equal.
<p>The <code>IDFT</code> operation defines a <code>PropertyGenerator</code> that sets the <code>COMPLEX</code> property of the image to <code>FALSE</code> if the <code>dataNature</code> parameter is <code>COMPLEX_TO_REAL</code> and to <code>TRUE</code> if the <code>dataNature</code> parameter is <code>REAL_TO_COMPLEX</code> or <code>COMPLEX_TO_COMPLEX</code>. The value of this property may be retrieved by calling the getProperty() method with <code>COMPLEX</code> as the property name.
<p><a name="65675">
<h3>7.9.2	<img src="shared/space.gif">Cosine Transform</h3>
</a>The discrete cosine transform (DCT) is similar to the discrete Fourier transform (see <a href="Image-enhance.doc.html#64002">Section &#32;7.9.1.1, "Discrete Fourier Transform</a>"). However, the DCT is better at compactly representing very small images. Like the discrete Fourier transform (DFT), the DCT also has an inverse operation, the <em>inverse discrete cosine transform</em> (IDCT).
<p><a name="65622">
<h4>7.9.2.1	<img src="shared/space.gif">Discrete Cosine Transform (DCT)</h4>
</a>The <code>DCT</code> operation computes the even discrete cosine transform of an image. Each band of the destination image is derived by performing a two-dimensional DCT on the corresponding band of the source image.
<p>The <code>DCT</code> operation takes one rendered or renderable source image and no parameters.
<p><a href="Image-enhance.doc.html#69770">Listing &#32;7-8</a> shows a code sample for a DCT operation.<p>
<caption><font size=-1><b>
<a name="69770">
<center><font size=-1><b><i>Listing 7-8	</i><img src="shared/sm-blank.gif" border=0> Example DCT Operation</b></font></center>
</a><p>
</b></font></caption>
<hr>
<tr valign=top><td><pre>     // Load the source image.
     RenderedImage src = (RenderedImage)JAI.create("fileload",
                         fileName);
</pre>
<tr valign=top><td><pre>     // Calculate a DCT image from the source image.
     ParameterBlock pb = (new ParameterBlock()).addSource(src);
     PlanarImage dct = JAI.create("dct", pb, null);
</pre>
<tr valign=top><td><pre>     // Get the DCT image data.
     int width = dct.getWidth();
     int height = dct.getHeight();
     int numBands = dct.getSampleModel().getNumBands();
     int dataType = dct.getSampleModel().getDataType();
     double[] dctData =
         dct.getData().getPixels(0, 0, width, height,
                                (double[])null);
     double[] pixels = new double[dctData.length];
</pre>

<hr>

<p><a name="65632">
<h4>7.9.2.2	<img src="shared/space.gif">Inverse Discrete Cosine Transform (IDCT)</h4>
</a>The <code>IDCT</code> operation computes the inverse even discrete cosine transform of an image. Each band of the destination image is derived by performing a two-dimensional inverse DCT on the corresponding band of the source image.
<p>The <code>IDCT</code> operation takes one rendered or renderable source image and no parameters.
<p><a href="Image-enhance.doc.html#69814">Listing &#32;7-9</a> shows a code sample for an operation that first takes the discrete cosine transform of an image, then computes the inverse discrete cosine transform.<p>
<caption><font size=-1><b>
<a name="69814">
<center><font size=-1><b><i>Listing 7-9	</i><img src="shared/sm-blank.gif" border=0> Example IDCT Operation</b></font></center>
</a><p>
</b></font></caption>
<hr>
<tr valign=top><td><pre>     // Calculate a DCT image from the source image.
     System.out.println("Creating DCT of source image ...");
     ParameterBlock pb = (new ParameterBlock()).addSource(src);
     PlanarImage dct = JAI.create("dct", pb, null);
</pre>
<tr valign=top><td><pre>     // Calculate an IDCT image from the DCT image.
     System.out.println("Creating IDCT of DCT of source image ...");
     pb = (new ParameterBlock()).addSource(dct);
     PlanarImage idct = JAI.create("idct", pb, null);
</pre>
<tr valign=top><td><pre>     // Create display image for inverse DCT of DCT of source image.
     System.out.println("Creating display image for IDCT of DCT");
     pixels = idct.getData().getPixels(0, 0, width, height,
                                       (double[])pixels);
     BufferedImage bi = createBI(colorImage, width, height, pixels);
</pre>

<hr>

<p><a name="66700">
<h3>7.9.3	<img src="shared/space.gif">Magnitude Enhancement</h3>
</a>The <code>magnitude</code> operation computes the magnitude of each pixel of a complex image. The source image must have an even number of bands, with the even bands (0, 2, etc.) representing the real parts and the odd bands (1, 3, etc.) the imaginary parts of each complex pixel. The destination image has at most half the number of bands of the source image with each sample in a pixel representing the magnitude of the corresponding complex source sample.
<p>The magnitude values of the destination image are defined by the following pseudocode:
<p><pre>     dstPixel[x][y][b] = sqrt(src[x][y][2b]<sup>2</sup> + src[x][y][2b + 1]<sup>2</sup>)
</pre><dl>
<a name="66706">
<dt><dd> where the number of bands <em>b</em> varies from zero to one less than the number of bands in the destination image.
</a><P></dl>
For integral image data types, the result is rounded and clamped as needed.
<p>The <code>magnitude</code> operation takes one rendered or renderable source image containing complex data and no parameters.
<p><a href="Image-enhance.doc.html#69889">Listing &#32;7-10</a> shows a code sample for a <code>magnitude</code> operation.<p>
<caption><font size=-1><b>
<a name="69889">
<center><font size=-1><b><i>Listing 7-10	</i><img src="shared/sm-blank.gif" border=0> Example Magnitude Operation</b></font></center>
</a><p>
</b></font></caption>
<hr>
<tr valign=top><td><pre>     // Calculate a DFT image from the source image.
     pb = new ParameterBlock();
     pb.addSource(src).add(DFTDescriptor.SCALING_NONE);
     PlanarImage dft = JAI.create("dft", pb, null);
</pre>
<tr valign=top><td><pre>     // Create the ParameterBlock specifying the source image.
     pb = new ParameterBlock();
     pb.addSource(dft);
</pre>
<tr valign=top><td><pre>     // Calculate the magnitude.
     PlanarImage magnitude = JAI.create("magnitude", pb, null);
</pre>

<hr>

<p><a name="66728">
<h3>7.9.4	<img src="shared/space.gif">Magnitude-squared Enhancement</h3>
</a>The <code>MagnitudeSquared</code> operation computes the squared magnitude of each pixel of a complex image. The source image must have an even number of bands, with the even bands (0, 2, etc.) representing the real parts and the odd bands (1, 3, etc.) the imaginary parts of each complex pixel. The destination image has at most half the number of bands of the source image with each sample in a pixel representing the magnitude of the corresponding complex source sample.
<p>The squared magnitude values of the destination image are defined by the following pseudocode:
<p><pre>     dstPixel[x][y][b] = src[x][y][2b]<sup>2</sup> + src[x][y][2b + 1]<sup>2
</sup></pre><dl>
<a name="66734">
<dt><dd> where the number of bands <em>b</em> varies from zero to one less than the number of bands in the destination image.
</a><P></dl>
For integral image data types, the result is rounded and clamped as needed.
<p>The <code>MagnitudeSquared</code> operation takes one rendered or renderable source image containing complex data and no parameters.
<p><a name="66739">
<h3>7.9.5	<img src="shared/space.gif">Phase Enhancement</h3>
</a>The <code>Phase</code> operation computes the phase angle of each pixel of a complex image. The source image must have an even number of bands, with the even bands (0, 2, etc.) representing the real parts and the odd bands (1, 3, etc.) the imaginary parts of each complex pixel. The destination image has at most half the number of bands of the source image with each sample in a pixel representing the phase angle of the corresponding complex source sample.
<p>The angle values of the destination image are defined by the following pseudocode:
<p><pre>     dst[x][y][b] = atan2(src[x][y][2b + 1], src[x][y][2b])
</pre><dl>
<a name="66745">
<dt><dd> where the number of bands <em>b</em> varies from zero to one less than the number of bands in the destination image.
</a><P></dl>
For integral image data types, the result is rounded and scaled so the "natural" arctangent range from [-<img src="shared/chars/pi.gif">, <img src="shared/chars/pi.gif">) is remapped into the range [0, MAXVALUE). The result for floating point image data types is the value returned by the <code>atan2()</code> method.
<p>The <code>phase</code> operation takes one rendered or renderable source image containing complex data and no parameters.
<p><a name="66360">
<h3>7.9.6	<img src="shared/space.gif">Complex Conjugate</h3>
</a>The <code>Conjugate</code> operation computes the complex conjugate of a complex image. The operation negates the imaginary components of a rendered or renderable source image containing complex data. The source image must contain an even number of bands with the even-indexed bands (0, 2, etc.) representing the real and the odd-indexed bands (1, 3, etc.) the imaginary parts of each pixel. The destination image similarly contains an even number of bands with the same interpretation and with contents defined by:
<p><pre>     dst[x][y][2*k]   =  src[x][y][2*k];
     dst[x][y][2*k+1] = -src[x][y][2*k+1];
</pre><dl>
<a name="66400">
<dt><dd> where the index <em>k</em> varies from zero to one less than the number of complex components in the destination image.
</a><P></dl>
The <code>Conjugate</code> operation takes one rendered or renderable source image containing complex data and no parameters.
<p><a name="66438">
<h3>7.9.7	<img src="shared/space.gif">Periodic Shift</h3>
</a>The <code>PeriodicShift</code> operation computes the periodic translation of an image. The destination image of the <code>PeriodicShift</code> operation is the infinite periodic extension of the source image with horizontal and vertical periods equal to the image width and height, respectively, shifted by a specified amount along each axis and clipped to the bounds of the source image. Thus for each band <em>b</em> the destination image sample at location (<em>x</em>,<em>y</em>) is defined by:
<p><pre>     if(x &lt; width - shiftX) {
         if(y &lt; height - shiftY) {
             dst[x][y][b] = src[x + shiftX][y + shiftY][b];
         } else {
             dst[x][y][b] = src[x + shiftX][y - height + shiftY][b];
         }
     } else {
         if(y &lt; height - shiftY) {
             dst[x][y][b] = src[x - width + shiftX][y + shiftY][b];
         } else {
             dst[x][y][b] = src[x - width + shiftX][y - height +
                                                    shiftY][b];
         }
     }
</pre><dl>
<a name="67378">
<dt><dd> where <code>shiftX</code> and <code>shiftY</code> denote the translation factors along the <em>x</em> and <em>y</em> axes, respectively.
</a><P></dl>
The <code>PeriodicShift</code> operation takes one rendered or renderable source image and two parameters.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="67392">
Parameter
</a><th><a name="67394">
Type
</a><th><a name="67396">
Description
</a>
<tr valign=top><td><a name="67398">
shiftX</a><br><td><a name="67400">
Integer</a><br><td><a name="67402">
The displacement in the <em>x</em> direction.</a><br>
<tr valign=top><td><a name="67404">
shiftY</a><br><td><a name="67406">
Integer</a><br><td><a name="67408">
The displacement in the <em>y</em> direction.</a><br>

</Table>

<p><a name="67381">
<h3>7.9.8	<img src="shared/space.gif">Polar to Complex</h3>
</a>The <code>PolarToComplex</code> operation computes a complex image from a magnitude and a phase image. The operation creates an image with complex-valued pixels from two images, the respective pixel values of which represent the magnitude (modulus) and phase of the corresponding complex pixel in the destination image.
<p>The source images should have the same number of bands. The first source image contains the magnitude values and the second source image the phase values. The destination will have twice as many bands with the even-indexed bands (0, 2, etc.) representing the real and the odd-indexed bands (1, 3, etc.) the imaginary parts of each pixel.
<p>The pixel values of the destination image are defined for a given complex sample by the following pseudocode:
<p><pre>     dst[x][y][2*b]   = src0[x][y][b]*Math.cos(src1[x][y][b])
     dst[x][y][2*b+1] = src0[x][y][b]*Math.sin(src1[x][y][b])
</pre><dl>
<a name="66654">
<dt><dd> where the index <em>b</em> varies from zero to one less than the number of bands in the source images.
</a><P></dl>
For phase images with integral data type, it is assumed that the actual phase angle is scaled from the range [-<code>PI</code>, <code>PI</code>] to the range [0, <code>MAX_VALUE</code>] where <code>MAX_VALUE</code> is the maximum value of the data type in question.
<p>The <code>PolarToComplex</code> operation takes two rendered or renderable source images and no parameters.
<p><a name="67438">
<h3>7.9.9	<img src="shared/space.gif">Images Based on a Functional Description</h3>
</a>The <code>ImageFunction</code> operation generates an image from a functional description. This operation permits the creation of images on the basis of a functional specification, which is provided by an object that is an instance of a class that implements the <code>javax.media.jai.ImageFunction</code> interface. In other words, to use this operation, a class containing the functional information must be created and this class must implement the <code>ImageFunction</code> interface.
<p>The <code>ImageFunction</code> interface merely defines the minimal set of methods required to represent such a function. The actual implementation of a class implementing this interface is left to the programmer.
<p>For example, if the function you wanted to generate was the negative exponential
<p><pre>         exp(-|x| - |y|)
</pre>The <code>javax.media.jai.ImageFunction</code> implementation would return the following values:
<p><ul>
<li><code>isComplex()</code> would return false<p></ul><ul>
<li><code>getNumElements()</code> would return 1<p></ul><ul>
<li><code>float[] real = new real[width*height];<br>getElements(x, y, width, height, real, null);</code><p></ul>and the implementation would initialize the array <code>real</code> such that
<p><pre>     <code>real[j*width + i] = exp(-|x + i| - |y + j|)
</code></pre>or, equivalently
<p><pre>     <code>real[k] = exp(-|x + (k % width)]| - |y + (k / width)|)
</code></pre><dl>
<a name="67570">
<dt><dd> where 0 <img src="shared/chars/lt_equal.gif"> k &lt; width*height.
</a><P></dl>
The (<em>x</em>,<em>y</em>) coordinates passed to the <code>ImageFunction.getElements()</code> methods are derived by applying an optional translation and scaling to the image <em>x</em> and <em>y</em> coordinates. The image <em>x</em> and <em>y</em> coordinates as usual depend on the values of the minimum <em>x</em> and <em>y</em> coordinates of the image, which need not be zero.
<p>Specifically, the function coordinates passed to <code>getElements()</code> are calculated from the image coordinates as:
<p><pre>     functionX = xScale*imageX + xTrans;
     functionY = yScale*imageY + yTrans;
</pre>The number of bands in the destination image will be equal to the value returned by the <code>ImageFunction.getNumElements()</code> method unless the <code>ImageFunction.isComplex()</code> method returns <code>true</code>, in which case it will be twice that. The data type of the destination image is determined by the <code>SampleModel</code> specified by an <code>ImageLayout</code> object provided via a hint. If no layout hint is provided, the data type will default to single-precision floating point.
<p>The double precision floating point form of the <code>getElements()</code> method will be invoked if and only if the data type is specified to be <code>double</code>. For all other data types the single precision form of <code>getElements()</code> will be invoked and the destination sample values will be clamped to the data type of the image.
<p>The <code>ImageFunction</code> operation takes seven parameters.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="67738">
Parameter
</a><th><a name="67740">
Type
</a><th><a name="67742">
Description
</a>
<tr valign=top><td><a name="67744">
function</a><br><td><a name="67746">
ImageFunction</a><br><td><a name="67748">
The functional description.</a><br>
<tr valign=top><td><a name="67750">
width</a><br><td><a name="67752">
Integer</a><br><td><a name="67754">
The image width.</a><br>
<tr valign=top><td><a name="67756">
height</a><br><td><a name="67797">
Integer</a><br><td><a name="67760">
The image height.</a><br>
<tr valign=top><td><a name="67762">
xScale</a><br><td><a name="67799">
Float</a><br><td><a name="67766">
The <em>x</em> scale factor.</a><br>
<tr valign=top><td><a name="67768">
yScale</a><br><td><a name="67803">
Float</a><br><td><a name="67772">
The <em>y</em> scale factor.</a><br>
<tr valign=top><td><a name="67774">
xTrans</a><br><td><a name="67805">
Float</a><br><td><a name="67778">
The <em>x</em> translation.</a><br>
<tr valign=top><td><a name="67780">
yTrans</a><br><td><a name="67807">
Float</a><br><td><a name="67784">
The <em>y</em> translation.</a><br>

</Table>

<p>The image width and height are provided explicitly as parameters. These values override the width and height specified by an <code>ImageLayout</code> if such is provided.
<p><table border = 0>
<tr>
<td><img src = "shared/cistine.gif"></td>
<td><hr>
<b>API:</b> <code>javax.media.jai.ImageFunction
</code>
<hr>
</td>
</table><pre><ul>
<li>boolean isComplex();
<p></ul></pre><dl>
<a name="67862">
<dt><dd> returns whether or not each value's elements are complex.
</a><P></dl>
<pre><ul>
<li>int getNumElements();
<p></ul></pre><dl>
<a name="67872">
<dt><dd> returns the number of elements per value at each position.
</a><P></dl>
<pre><ul>
<li>void getElements(float startX, float startY, float deltaX, 
       float deltaY, int countX, int countY, int element, 
       float[] &#32;real, float[] imag);
<p></ul></pre><dl>
<a name="68127">
<dt><dd> returns all values of a given element for a specified set of coordinates.<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><td colspan=1 rowspan=9><em>Parameters</em>:
<p><td><code>startX</code>
<p><td>The <em>x</em> coordinate of the upper left location to evaluate.
<p>
<tr valign=top><td><code>startY</code>
<p><td>The <em>y</em> coordinate of the upper left location to evaluate.
<p>
<tr valign=top><td><code>deltaX</code>
<p><td>The horizontal increment.
<p>
<tr valign=top><td><code>deltaY</code>
<p><td>The vertical increment.
<p>
<tr valign=top><td><code>countX</code>
<p><td>The number of points in the horizontal direction.
<p>
<tr valign=top><td><code>countY</code>
<p><td>The number of points in the vertical direction.
<p>
<tr valign=top><td><code>element</code>
<p><td>The element.
<p>
<tr valign=top><td><code>real</code>
<p><td>A pre-allocated float array of length at least <code>countX</code>*<code>countY</code> in which the real parts of all elements will be returned.
<p>
<tr valign=top><td><code>imag</code>
<p><td>A pre-allocated float array of length at least <code>countX</code>*<code>countY</code> in which the imaginary parts of all elements will be returned; may be null for real data, i.e., when <code>isComplex()</code> returns false.
<p>

</Table>

</a><P></dl>
<pre><ul>
<li>void getElements(double startX, double startY, double deltaX, 
       double deltaY, int countX, int countY, int element, 
       double[] &#32;real, double[] imag);
<p></ul></pre><dl>
<a name="68215">
<dt><dd> returns all values of a given element for a specified set of coordinates.
</a><P></dl>
<a name="60152">
<h2>7.10	<img src="shared/space.gif">Single-image Pixel Point Processing</h2>
</a>Pixel point operations are the most basic, yet necessary image processing operations. The pixel point operations are primarily contrast enhancement operations that alter the gray levels of an image's pixels. One-by-one, the gray level of each pixel in the source image is modified to a new value, usually by a mathematical relationship.
<p>JAI supports the following single-image pixel point operations:
<p><ul>
<li>Pixel inverting (<code>Invert</code>)<p></ul><ul>
<li>Logarithmic enhancement (<code>Log</code>)<p></ul><a name="64866">
<h3>7.10.1	<img src="shared/space.gif">Pixel Inverting</h3>
</a>The <code>Invert</code> operation inverts the pixel values of an image. For source images with signed data types, the pixel values of the destination image are defined by the following pseudocode:
<p><pre>     dst[x][y][b] = -src[x][y][b]
</pre>For unsigned data types, the destination values are defined by the following pseudocode:
<p><pre>     dst[x][y][b] = MAX_VALUE - src[x][y][b]
</pre><dl>
<a name="60011">
<dt><dd> where <code>MAX_VALUE</code> is the maximum value supported by the system of the data type of the source pixel.
</a><P></dl>
The <code>Invert</code> operation takes one rendered or renderable source image and no parameters.
<p><a href="Image-enhance.doc.html#76289">Figure &#32;7-12</a> shows a simple example of an <code>Invert</code> operation.
<p><a name="76288">
 <hr>
<center><img src="Image-enhance.doc.ancA7.gif"></center><hr>

</a>
<a name="76289">
<center><font size=-1><b><i>Figure 7-12	</i><img src="shared/sm-blank.gif" border=0> Pixel Inverting</b></font></center>
</a><p>
<a name="60051">
<h3>7.10.2	<img src="shared/space.gif">Logarithmic Enhancement</h3>
</a>Occasionally, it is desirable to quantize an image on a logarithmic scale rather than a linear scale. The human eye has a logarithmic intensity response but some images are digitized by equipment that quantizes the samples on a linear scale. To make the image better for use by a human observer, these images may be made to have a logarithmic response by the <code>Log</code> operation.
<p>The <code>Log</code> operation takes the logarithm of the pixel values of the source image. The pixel values of the destination image are defined by the following pseudocode:
<p><pre>     dst[x][y][b] = java.lang.Math.log(src[x][y][b])
</pre>For integral image data types, the result is rounded and clamped as needed. For all integral data types, the log of 0 is set to 0. For signed integral data types (<code>short</code> and <code>int</code>), the log of a negative pixel value is set to -1. For all floating point data types (<code>float</code> and <code>double</code>), the log of 0 is set to -<code>Infinity</code>, and the log of a negative pixel value is set to <code>NaN</code>.
<p>The <code>Log</code> operation takes one rendered or renderable source image and no parameters.
<p><a href="Image-enhance.doc.html#69925">Listing &#32;7-11</a> shows a code sample for a <code>Log</code> operation.<p>
<caption><font size=-1><b>
<a name="69925">
<center><font size=-1><b><i>Listing 7-11	</i><img src="shared/sm-blank.gif" border=0> Example Log Operation &#32;</b></font></center>
</a><p>
</b></font></caption>
<hr>
<tr valign=top><td><pre>     // Create the ParameterBlock specifying the source image.
     pb = new ParameterBlock();
     pb.addSource(image);
</pre>
<tr valign=top><td><pre>     // Create the Log operation.
     RenderedImage dst = JAI.create("log", pb);
</pre>

<hr>

<p><a name="60966">
<h2>7.11	<img src="shared/space.gif">Dual Image Pixel Point Processing</h2>
</a>The previous section described pixel point operations for single images. This section deals with pixel point processing on two images, also known as <em>dual-image point processing</em>. Dual-image point processing maps two pixel brightnesses, one from each image, to an output image.
<p>JAI supports the following dual-image pixel point operations:
<p><ul>
<li>Overlay images (<code>Overlay</code> operation)<p></ul><ul>
<li>Image compositing (<code>Composite</code> operation)<p></ul><a name="60992">
<h3>7.11.1	<img src="shared/space.gif">Overlay Images</h3>
</a>The <code>Overlay</code> operation takes two rendered or renderable source images, and overlays the second source image on top of the first source image. Usually, the images are identical scenes, but may have been acquired at different times through different spectral filters.
<p>The two source images must have the same data type and number of bands. However, their <code>SampleModel</code> types may differ. The destination image will always have the same bounding rectangle as the first source image, that is, the image on the bottom, and the same data type and number of bands as the two source images. If the two source images don't intersect, the destination will be the same as the first source.
<p>The <code>Overlay</code> operation is defined by the following pseudocode:
<p><pre>     if (srcs[1] contains the point (x, y)) {
         dst[x][y][b] = srcs[1][x][y][b];
     } else {
         dst[x][y][b] = srcs[0][x][y][b];
     }
</pre>The <code>Overlay</code> operation takes two rendered or renderable source images and no parameters.
<p><a name="61005">
<h3>7.11.2	<img src="shared/space.gif">Image Compositing</h3>
</a>The <code>Composite</code> operation merges unrelated objects from two images. The result is a new image that didn't exist before. The <code>Composite</code> operation combines two images based on their alpha values at each pixel. This is done on a per-band basis, and the source images are expected to have the same number of bands and the same data type. The destination image has the same data type as the two sources, but one extra band than the source images, which represents the result alpha channel.
<p>The destination pixel values may be viewed as representing a fractional pixel coverage or transparency factor. Specifically, the <code>Composite</code> operation implements the Porter-Duff "over" rule<a href="#61010"><sup>1</sup></a>, in which the output color of a pixel with source value and alpha tuples (<em>A</em>, <em>a</em>) and (<em>B</em>, <em>b</em>) is given by:
<p><dl>
<a name="61011">
<dt><dd> <em>a</em>*<em>A</em> + (1 - <em>a</em>)*(<em>b</em>*<em>B</em>)
</a><P></dl>
The output alpha value is given by:
<p><dl>
<a name="61013">
<dt><dd> <em>a</em> + (1 - <em>a</em>)*<em>b</em>
</a><P></dl>
For premultiplied sources tuples (<em>a</em>*<em>A</em>, <em>a</em>) and (<em>b</em>*<em>B</em>, <em>b</em>), the premultiplied output value is simply:
<p><dl>
<a name="61015">
<dt><dd> (<em>a</em>*<em>A</em>) + (1 - <em>a</em>)*(<em>b</em>*<em>B</em>)
</a><P></dl>
The color channels of the two source images are supplied via <code>source1</code> and <code>source2</code>. The two sources must either both be pre-multiplied by alpha or not. Alpha channel should not be included in <code>source1</code> and <code>source2</code>.
<p>The <code>Composite</code> operation takes two rendered or renderable source images and four parameters:<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="61126">
Parameter
</a><th><a name="61128">
Type
</a><th><a name="61130">
Description
</a>
<tr valign=top><td><a name="61132">
source1Alpha</a><br><td><a name="61134">
PlanarImage</a><br><td><a name="61136">
An alpha image to override the alpha for the first source. </a><br>
<tr valign=top><td><a name="61138">
source2Alpha</a><br><td><a name="61140">
PlanarImage</a><br><td><a name="61142">
An alpha image to override the alpha for the second source.</a><br>
<tr valign=top><td><a name="61144">
alphaPremultiplied</a><br><td><a name="61146">
Boolean</a><br><td><a name="61148">
True if alpha has been premultiplied to both sources and the destination.</a><br>
<tr valign=top><td><a name="61150">
destAlpha</a><br><td><a name="61152">
Integer</a><br><td><a name="76916">
Indicates if the destination image should include an extra alpha channel, and if so, whether it should be the first or last band. One of: CompositeDescriptor.DESTINATION_ALPHA_FIRST CompositeDescriptor.DESTINATION_ALPHA_LAST CompositeDescriptor.NO_DESTINATION_ALPHA</a><br>

</Table>

<p>The alpha channel of the first source images must be supplied via the <code>source1Alpha</code> parameter. This parameter may not be null. The alpha channel of the second source image may be supplied via the <code>source2Alpha</code> parameter. This parameter may be null, in which case the second source is considered completely opaque. The alpha images should be single-banded, and have the same data type as the source image. 
<p>The <code>alphaPremultiplied</code> parameter indicates whether or not the supplied alpha image is premultiplied to both the source images. 
<p>The destination image is the combination of the two source images. It has the color channels and one additional alpha channel (the band index depends on the <code>alphaFirst</code> parameter). Whether the alpha value is pre-multiplied to the color channels also depends on the value of <code>alphaPremultiplied</code> (pre-multiplied if true).
<p><a href="Image-enhance.doc.html#69950">Listing &#32;7-12</a> shows a code sample for a composite operation.<p>
<caption><font size=-1><b>
<a name="69950">
<center><font size=-1><b><i>Listing 7-12	</i><img src="shared/sm-blank.gif" border=0> Example Composite Operation &#32;</b></font></center>
</a><p>
</b></font></caption>
<hr>
<tr valign=top><td><pre>     // Get the first image.
     pb = new ParameterBlock();
     pb.add(s1);
     RenderedImage src1 = (RenderedImage)JAI.create("jpeg", pb);
</pre>
<tr valign=top><td><pre>     // Get the second image
     pb = new ParameterBlock();
     pb.add(s2);
     RenderedImage src2 = (RenderedImage)JAI.create("jpeg", pb);
</pre>
<tr valign=top><td><pre>     // Create the ParameterBlock
     pb = new ParameterBlock();
     pb.addSource(src1);
     pb.addSource(src2);
     pb.add(new Boolean(false));
     pb.add(new Boolean(false));
</pre>
<tr valign=top><td><pre>     // Create the composite operation.
     RenderedImage dst = (RenderedImage)JAI.create("composite", pb);
</pre>

<hr>

<p><a name="63249">
<h2>7.12	<img src="shared/space.gif">Thresholding</h2>
</a>Thresholding, also known as <em>binary contrast enhancement</em>, provides a simple means of defining the boundaries of objects that appear on a contrasting background. The <code>Threshold</code> operation takes one rendered image, and maps all the pixels of this image whose values fall within a specified range to a specified constant. The range is specified by a low value and a high value.
<p>The pixel values of the destination image are defined by the following pseudocode:
<p><pre>     lowVal = (low.length &lt; dstNumBands) ?
               low[0] : low[b];
     highVal = (high.length &lt; dstNumBands) ?
                high[0] : high[b];
     const = (constants.length &lt; dstNumBands) ?
              constants[0] : constants[b];
     
     if (src[x][y][b] &gt;= lowVal &amp;&amp; src[x][y][b] &lt;= highVal) {
         dst[x][y][b] = const;
     } else {
         dst[x][y][b] = src[x][y][b];
     }
</pre>The <code>Threshold</code> operation takes one rendered or renderable source image and three parameters:<p> 
<Table Border="3" cellpadding=3>
<caption><font size=-1><b></b></font></caption>
<tr valign=top><th><a name="76955">
Parameters
</a><th><a name="76957">
Type
</a><th><a name="76959">
Description
</a>
<tr valign=top><td><a name="76961">
low</a><br><td><a name="76963">
double[]</a><br><td><a name="76965">
The low value.</a><br>
<tr valign=top><td><a name="76967">
high</a><br><td><a name="76969">
double[]</a><br><td><a name="76971">
The high value</a><br>
<tr valign=top><td><a name="76973">
constants</a><br><td><a name="76975">
double[]</a><br><td><a name="76977">
The constant the pixels are mapped to.</a><br>

</Table>

<p>If the number of elements supplied via the <code>high</code>, <code>low</code>, and <code>constants</code> arrays are less than the number of bands of the source image, the element from entry 0 is applied to all the bands. Otherwise, the element from a different entry is applied to its corresponding band.
<p>The <code>low</code> parameter defines the lower bound for the <code>threshold</code> operation for each band of the image. The operation will affect only values greater than or equal to <code>low[0]</code> in band 0, only values greater than or equal to <code>low[1]</code> in band 1, and so on. The <code>high</code> parameter defines the upper bound for the <code>threshold</code> operation for each band of the image.
<p>A common way to arrive at the optimal values for the <code>low</code> and <code>high</code> parameters is to perform an <code>extrema</code> operation on the image (see <a href="Analysis.doc.html#54907">Section &#32;9.3, "Finding the Extrema of an Image</a>").
<p><a href="Image-enhance.doc.html#69988">Listing &#32;7-13</a> shows a code sample for a <code>threshold</code> operation in which the three parameters are passed as arguments to the operation.<p>
<caption><font size=-1><b>
<a name="69988">
<center><font size=-1><b><i>Listing 7-13	</i><img src="shared/sm-blank.gif" border=0> Example Threshold Operation &#32;</b></font></center>
</a><p>
</b></font></caption>
<hr>
<tr valign=top><td><pre>     // Set up the operation parameters.
     PlanarImage src, dst;
     Integer [] low, high, map;
     int bands;
</pre>
<tr valign=top><td><pre>     low  = new Integer[bands];
     high = new Integer[bands];
     map  = new Integer[bands];
</pre>
<tr valign=top><td><pre>     for (int i = 0; i &lt; bands; i++) {
        low[i]  = new Integer(args[1]);
        high[i] = new Integer(args[2]);
        map[i]  = new Integer(args[3]);
     }
</pre>
<tr valign=top><td><pre>     // Create the threshold operation.
     pb = new ParameterBlock();
     pb.addSource(src);
     pb.add(low);
     pb.add(high);
     pb.add(map);
     RenderedImage dst = JAI.create("threshold", pb);
</pre>

<hr>

<p>
<p>
<hr><br>
 
<center>
<a href="JAITOC.fm.html"><img src="shared/contents.gif" alt="Contents"></a> <a href="Image-manipulation.doc.html"><img src="shared/previous.gif" alt="Previous"></a> <a href="Geom-image-manip.doc.html"><img src="shared/next.gif" alt="Next"></a> <p><font size=5><i>Programming in Java Advanced Imaging</i></font>
</center>
<br>
 
<sup>1</sup><a name="61010">
 See <em>Computer Graphics</em>, July 1984 pp. 253-259.
</a>

<h5><a href="copyright.html">Copyright</a> &#169; 1999, Sun Microsystems, Inc.   All rights
reserved.</h5>


<!-- Last updated: Tue Nov 02 17:38:37 1999 -->
</blockquote>
</body>
</html>
